[
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/152",
    "id": 3710466506,
    "node_id": "I_kwDOQfMfks7dKTnK",
    "number": 152,
    "title": "[Scope 4][Chunk 7] Epic – SBI protocol completeness (Reset, tokens, Finalize, SrPolicy stubs)",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9738572054,
        "node_id": "LA_kwDOQfMfks8AAAACRHbRFg",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:tracking",
        "name": "type:tracking",
        "color": "4eaa16",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139252,
        "node_id": "LA_kwDOQfMfks8AAAACRw-ZdA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:7-sbi-protocol-completeness",
        "name": "chunk:7-sbi-protocol-completeness",
        "color": "1cbd8b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T11:31:42Z",
    "updated_at": "2025-12-09T11:32:21Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 6,
      "completed": 0,
      "percent_completed": 0
    },
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the end of **Scope 4 / Chunk 6** you have:\n\n- SBI scheduling and telemetry plumbing in place:\n  - `ControlDataPlaneInterface.ReceiveRequests` implemented on the controller.\n  - Agent-side `ReceiveRequests` client loop and local schedule queue.\n  - `ScheduledAction` domain model hooked up to `ScenarioState` (beams/routes).\n- Telemetry end-to-end:\n  - `TelemetryService.ExportMetrics` on the controller.\n  - Agent-side telemetry loop emitting per-interface metrics on a sim-time interval.\n- Basic CDPI server behaviour:\n  - Agents connect and send `Hello`.\n  - Controller can send `CreateEntry`, `DeleteEntry`, `FinalizeRequest` messages.\n  - Agents execute scheduled actions at the right sim time and send `Response`.\n\nWhat is **still missing** is **full SBI protocol semantics**, as described in your Scope 4 plan and Aalyria SBI docs:\n\n- Proper handling of **Reset** semantics:\n  - Agents can request a reset of their schedule state.\n  - Controller clears its notion of pending entries for that agent.\n  - A new `schedule_manipulation_token` is minted and used from then on.\n- Enforcing **schedule_manipulation_token** and **seqno**:\n  - Controller must send the correct token and monotonically increasing `seqno` per agent.\n  - Agents must validate tokens and (at minimum) log / ignore mismatched messages.\n- Correct **FinalizeRequest** behaviour:\n  - Controller can declare a cutoff time before which it will no longer modify schedule entries.\n  - Agents drop scheduled actions older than the cutoff and keep future entries.\n- Accepting **SetSrPolicy/DeleteSrPolicy**:\n  - Controller and agent should handle these messages without panicking.\n  - For Scope 4, SrPolicy effects remain **stubbed**: stored/logged but no impact on connectivity.\n\nThis epic groups the work required to bring your SBI behaviour in line with the protocol expectations, **without** introducing advanced optimization or policy logic (that remains for later scopes).\n\n## Goal\n\nDeliver a **protocol-complete** SBI implementation for Scope 4:\n\n- Reset semantics:\n  - Agents can request reset and clear local schedule state.\n  - Controller resets its per-agent state and issues a new schedule token.\n- Token and sequence enforcement:\n  - Controller sends `schedule_manipulation_token` and `seqno` on every scheduling message.\n  - Agents validate tokens and handle mismatches safely.\n- Finalize semantics:\n  - Controller can send `FinalizeRequest` with a cutoff time.\n  - Agents drop all scheduled actions with `When < cutoff`.\n- SrPolicy acceptance:\n  - `SetSrPolicy` / `DeleteSrPolicy` messages are accepted by both sides.\n  - SrPolicy is stored in memory but has no effect on routing yet (explicitly documented).\n- Tests:\n  - Focused unit tests covering Reset, tokens, Finalize, and SrPolicy stubs.\n  - Small in-process gRPC tests where useful, to prove controller↔agent protocol flows.\n\nAfter this epic, your SBI implementation should match the **mechanics** described in the Requirements/Roadmap for Scope 4, with a clearly-defined behaviour for Reset, tokens, Finalize, and SrPolicy messages.\n\n## Where to look\n\nCore SBI types and generated protos:\n\n- Scheduling SBI protos under something like:\n  - `internal/genproto/scheduling/v1alpha`\n- Look for:\n  - `ControlDataPlaneInterface` service.\n  - `ResetRequest`, `ResetResponse` (if present).\n  - `CreateEntryRequest`, `DeleteEntryRequest`, `FinalizeRequest`.\n  - `SetSrPolicyRequest`, `DeleteSrPolicyRequest` (or similarly named messages).\n  - Fields:\n    - `schedule_manipulation_token`\n    - `seqno`\n    - `cutoff_time`\n    - Any SrPolicy-related types.\n\nCDPI controller implementation (previous Chunk 5 issues):\n\n- `internal/sbi/controller/cdpi_server.go` (or similar):\n  - `CDPIServer` struct and `AgentHandle`.\n  - `ReceiveRequests` RPC implementation.\n  - Controller-side helpers:\n    - `SendCreateEntry`\n    - `SendDeleteEntry`\n    - `SendFinalize`\n- Look for:\n  - Existing handling of `Hello`, `Reset`, `Response`.\n  - Places where `token` and `seqNo` are tracked on `AgentHandle`.\n\nAgent implementation (Chunks 4–6):\n\n- Under `internal/sbi/agent`:\n  - `Agent` struct:\n    - Local `pending` schedule map.\n    - `token` field (existing or to be added).\n    - Execution logic for `ScheduledAction`.\n  - CDPI client loop:\n    - How it receives `CreateEntry`, `DeleteEntry`, `FinalizeRequest`, `SetSrPolicy`, `DeleteSrPolicy`.\n  - Any existing `Reset` handling (client-side).\n\nScenarioState and scheduling domain model:\n\n- `internal/simstate` / `sim/state`:\n  - Where `ScheduledAction` and KB update helpers live.\n- Internal scheduling domain types under `internal/sbi/types` or similar.\n\nExisting tests:\n\n- CDPI unit tests under `internal/sbi/controller/...`.\n- Agent tests under `internal/sbi/agent/...`.\n\n## Tasks\n\n### 7.1 – Define / refine per-agent protocol state (controller side)\n\n- Extend `AgentHandle` on the controller (if needed) to track:\n  - `token string` – current `schedule_manipulation_token`.\n  - `seqNo int64` – last used sequence number.\n  - Optional:\n    - `lastReset time.Time`\n    - Counters for debugging (`numCreate`, `numDelete`, etc.).\n\n- Ensure there are helper methods on `CDPIServer` for:\n  - `newTokenForAgent(agentID string) string`\n  - `nextSeqNo(handle *AgentHandle) int64`\n\n- Design notes:\n  - Token generation can be simple for Scope 4 (e.g. random string, UUID, or monotonic counter with prefix).\n  - `seqNo` must be strictly increasing per agent across all scheduling messages.\n\n### 7.2 – Implement Reset semantics (controller and agent)\n\nController:\n\n- In `CDPIServer.handleAgentReset` (or equivalent):\n\n  - On receiving a `ResetRequest` from an agent:\n    - Clear any server-side tracking of pending entries for that agent:\n      - If you maintain per-agent pending maps, reset them.\n      - Otherwise, document that server does not locally track pending entries yet.\n    - Generate a new token:\n      - `handle.token = newTokenForAgent(handle.AgentID)`.\n    - Optionally record `handle.lastReset = now`.\n    - Log the reset (agent ID, node ID, new token).\n\n  - Decide how/when to respond:\n    - If SBI proto defines `ResetResponse`, send an appropriate response back.\n    - Otherwise, treat Reset as one-way (log + internal update).\n\nAgent:\n\n- Provide an explicit `Reset` behaviour on the **agent** side (if not already):\n\n  - When the agent decides to reset (e.g. on startup or on controller instruction in future scopes):\n    - Clear local schedule:\n      - Cancel all scheduled events via `EventScheduler.Cancel`.\n      - Clear `pending` map.\n    - Generate a fresh local token (`agent.token`).\n    - Send a `Reset` message to controller with the new token if required by the proto, or with agent ID.\n\n  - On receiving `ResetResponse` (if present in the proto):\n    - Optionally reconcile token with controller’s notion (for Scope 4, you may just log).\n\nDesign note:\n\n- For Scope 4, it is acceptable that **controller is authoritative** for the token, and agent uses the controller-sent token for incoming schedule messages. The agent’s own `Reset` call primarily informs the controller to clear its state and mint a new token.\n\n### 7.3 – Enforce schedule_manipulation_token and seqno\n\nController:\n\n- In `SendCreateEntry`, `SendDeleteEntry`, `SendFinalize`:\n\n  - Before constructing the proto:\n    - Read `handle.token` (must be non-empty; if empty, generate a default token).\n    - Increment `handle.seqNo` using `nextSeqNo(handle)`.\n\n  - Populate outgoing messages:\n    - `schedule_manipulation_token = handle.token`.\n    - `seqno = handle.seqNo`.\n    - Ensure `request_id` is populated consistently.\n\n- When handling controller restarts (if applicable in this scope):\n  - Document behaviour:\n    - For Scope 4, it is acceptable to generate a new token for all agents on reconnect.\n    - Advanced persistence is out of scope.\n\nAgent:\n\n- In the agent CDPI client loop, on receiving scheduling messages:\n\n  - Extract token and seqno from each received message.\n  - Compare token with agent’s current token:\n    - If token mismatch:\n      - Log a warning (include expected vs received).\n      - For Scope 4:\n        - Either ignore the message completely or accept but mark as suspect.\n      - Decide and document a simple policy:\n        - Recommended: **ignore** mismatched-token messages to reflect SBI semantics.\n  - For seqno:\n    - Track last seen seqno per agent (if needed).\n    - For Scope 4, it is sufficient to:\n      - Log out-of-order seqno, but not necessarily drop messages.\n\nDesign notes:\n\n- Keep enforcement **minimal but explicit**:\n  - Token mismatch → ignore message and log.\n  - Seqno irregularities → log only.\n- This leaves room for stricter behaviour in later scopes.\n\n### 7.4 – Implement FinalizeRequest behaviour\n\nController:\n\n- Ensure `CDPIServer` exposes a helper:\n\n  - `SendFinalize(agentID string, cutoff time.Time) error` already exists from Chunk 5:\n    - Populate `FinalizeRequest` with:\n      - `cutoff_time`.\n      - `schedule_manipulation_token` and `seqno` as per 7.3.\n    - Push onto the agent’s outgoing channel.\n\n- Decide when to call `SendFinalize`:\n  - At the end of a scenario or:\n  - Periodically as a “watermark” (for now, at least ensure it is callable by tests and future chunks).\n\nAgent:\n\n- On receiving `FinalizeRequest`:\n\n  - Interpret `cutoff_time` in sim time.\n  - In the agent’s `pending` schedule map:\n    - Drop any entries with `action.When.Before(cutoff)` (or `< cutoff` depending on convention).\n    - Do NOT cancel events for `When >= cutoff`.\n  - Ensure any corresponding scheduled callbacks in `EventScheduler` are cancelled for the dropped entries.\n  - Log how many entries were removed, for observability.\n\nDesign notes:\n\n- Clearly document the semantics:\n  - Finalize does **not** prevent new future entries from being added.\n  - It is simply a promise that existing schedule entries before cutoff will not be modified by controller.\n\n### 7.5 – Accept and stub SetSrPolicy/DeleteSrPolicy\n\nController:\n\n- Ensure `CDPIServer` helper methods or scheduler (later chunks) can send:\n\n  - `SetSrPolicyRequest`.\n  - `DeleteSrPolicyRequest`.\n\n- For this epic, you only need to guarantee:\n\n  - Messages are constructed correctly and sent with token + seqno.\n  - No panics if these messages are built or passed through.\n\nAgent:\n\n- In the CDPI client loop:\n\n  - On `SetSrPolicy`:\n    - Parse the policy into an internal `SrPolicySpec` (or similar).\n    - Store it in agent or node-level state, e.g.:\n      - `agent.srPolicies[policyId] = SrPolicySpec{...}`.\n    - Log that SrPolicy is **not yet enforced** in forwarding logic.\n\n  - On `DeleteSrPolicy`:\n    - Remove the corresponding policy from memory if present.\n    - Log removal.\n\n- No changes to `ScenarioState` connectivity or routing yet:\n  - SrPolicy remains a **no-op** in terms of actual traffic behaviour for Scope 4.\n\n### 7.6 – Focused protocol unit tests\n\nAdd tests to cover the new semantics, for example:\n\n1. **Reset semantics (controller side)**\n\n   - Setup:\n     - `CDPIServer` with an `AgentHandle` registered.\n     - Pre-populate some per-agent state (e.g. token, pending entries).\n   - Simulate receiving a `ResetRequest`.\n   - Assert:\n     - A new token is generated and stored on the handle.\n     - Any server-side pending state is cleared (if tracked).\n     - A log entry is emitted.\n\n2. **Token + seqno population**\n\n   - Call `SendCreateEntry` twice for the same agent.\n   - Assert:\n     - Outgoing messages have:\n       - Same non-empty token.\n       - `seqno` strictly increasing (e.g. 1 then 2).\n   - Repeat for `SendDeleteEntry`, `SendFinalize`.\n\n3. **Agent token enforcement**\n\n   - Agent with current token `\"token-1\"`.\n   - Send a scheduling message with:\n     - Token `\"token-1\"`:\n       - Assert it is accepted and scheduled.\n     - Token `\"token-2\"`:\n       - Assert it is **ignored** (no new pending action, log warns).\n\n4. **Finalize behaviour**\n\n   - Agent holds three scheduled actions with times `T1 < cutoff < T2 < T3`.\n   - Receive `FinalizeRequest(cutoff)`.\n   - Assert:\n     - Actions at `T1` (and any other `< cutoff`) removed.\n     - Actions at `T2`, `T3` remain.\n\n5. **SrPolicy stubs**\n\n   - Send `SetSrPolicy` to agent:\n     - Assert it is stored in `agent.srPolicies`.\n     - Assert no panic or state changes in `ScenarioState`.\n   - Send corresponding `DeleteSrPolicy`:\n     - Assert the policy is removed.\n     - Again, no panics or connectivity changes.\n\nOptional:\n\n- A small in-process gRPC test to validate:\n  - Agent sends `ResetRequest`.\n  - Controller updates token and subsequently uses the new token in scheduling messages.\n  - Agent enforces the new token.\n\n## Acceptance criteria\n\n- **Controller-side protocol state:**\n  - `AgentHandle` tracks:\n    - `token` (non-empty schedule manipulation token).\n    - `seqNo` (monotonically increasing per agent).\n  - Helpers to generate new tokens and next seqno exist and are used by:\n    - `SendCreateEntry`\n    - `SendDeleteEntry`\n    - `SendFinalize`\n  - Outgoing scheduling messages always carry the current token + seqno.\n\n- **Reset semantics:**\n  - Controller:\n    - On `ResetRequest`:\n      - Clears per-agent schedule-related state.\n      - Generates and stores a new token.\n      - Logs the reset.\n  - Agent:\n    - Exposes a reset behaviour that clears local schedule and pending actions.\n    - Interacts with Reset RPCs according to the SBI protos (one-way or request/response).\n\n- **Token + seqno enforcement (agent side):**\n  - Agent:\n    - Validates `schedule_manipulation_token` on incoming scheduling messages.\n    - On mismatch:\n      - Logs a warning.\n      - Ignores the message (as per documented policy).\n    - Seqno is at least logged; no hard ordering enforcement required yet.\n\n- **Finalize semantics:**\n  - `FinalizeRequest`:\n    - Causes agent to drop any scheduled actions with `When < cutoff_time`.\n    - Keeps future actions intact.\n    - Cancels corresponding `EventScheduler` callbacks.\n  - Behaviour is clearly documented and covered by tests.\n\n- **SrPolicy handling:**\n  - Agent:\n    - Accepts `SetSrPolicy` and `DeleteSrPolicy`.\n    - Stores/removes policy definitions in memory.\n    - Does not change connectivity/routing in Scope 4.\n  - Controller:\n    - Can send these messages without errors.\n  - All SrPolicy logic is clearly marked as **stubbed**.\n\n- **Tests:**\n  - Unit tests cover:\n    - Reset behaviour on controller and agent.\n    - Token + seqno assignment and validation.\n    - Finalize dropping only pre-cutoff actions.\n    - SrPolicy set/delete stubs without side effects.\n  - Optional small gRPC test verifies Reset → new token → token-enforced scheduling.\n\n- **Repository health:**\n  - `go build ./...` passes with all new protocol code.\n  - `go test ./...` passes, including new SBI protocol tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/153",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/153/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/153/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/153/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/153",
    "id": 3710510752,
    "node_id": "I_kwDOQfMfks7dKeag",
    "number": 153,
    "title": "Title: [Scope 4][Chunk 7] Implement schedule_manipulation_token & seqno handling on CDPIServer send path",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139252,
        "node_id": "LA_kwDOQfMfks8AAAACRw-ZdA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:7-sbi-protocol-completeness",
        "name": "chunk:7-sbi-protocol-completeness",
        "color": "1cbd8b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T11:44:56Z",
    "updated_at": "2025-12-09T11:45:03Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nIn **Chunk 5** you introduced the controller-side CDPI server:\n\n- `CDPIServer` under something like `internal/sbi/controller`, embedding:\n  - `scheduling.UnimplementedControlDataPlaneInterfaceServer`.\n- A concurrency-safe registry:\n  - `map[string]*AgentHandle` keyed by `agent_id`.\n- A `ReceiveRequests` implementation that:\n  - Accepts a streaming `ReceiveRequests` call from each agent.\n  - Reads the initial `Hello` message.\n  - Registers an `AgentHandle` with:\n    - `AgentID`, `NodeID`.\n    - `Stream` (server-side stream).\n    - `outgoing` channel for controller→agent messages.\n  - Loops on `stream.Recv()` to process agent→controller messages.\n- Controller-side send helpers:\n  - `SendCreateEntry(agentID string, action *sbi.ScheduledAction) error`.\n  - `SendDeleteEntry(agentID, entryID string) error`.\n  - `SendFinalize(agentID string, cutoff time.Time) error`.\n\nIn **Chunk 7**, the Scope 4 plan calls for implementing SBI **protocol completeness**, in particular:\n\n- **schedule_manipulation_token**:\n  - A per-agent token that:\n    - Is set/rotated on `Reset`.\n    - Must be attached to every `CreateEntryRequest` / `DeleteEntryRequest` / `FinalizeRequest`.\n  - Agents will **ignore** messages with a mismatched token (or at least log them).\n- **seqno**:\n  - A per-agent, monotonically increasing sequence number.\n  - Included on each scheduling message from controller to agent.\n  - Used by agents primarily for observability/debugging.\n\nRight now, your CDPI send helpers most likely:\n\n- Either do not populate `schedule_manipulation_token` and `seqno` at all, or\n- Populate them with stub values.\n\nTo make the controller side Protocol-complete, we need to:\n\n- Centralise token and seqno management on `AgentHandle`.\n- Ensure every outbound scheduling message includes:\n  - The current token.\n  - An incremented seqno.\n- Cover this behaviour with unit tests so it remains stable.\n\n(Full `Reset` semantics and agent-side enforcement are handled in **separate Chunk 7 issues**; this one focuses only on the controller send path.)\n\n## Goal\n\nImplement robust, testable handling of:\n\n- `schedule_manipulation_token` (per-agent):\n  - Stored on `AgentHandle`.\n  - Attached to each outbound scheduling message.\n  - Rotated via a dedicated helper (to be called by Reset-handling code).\n- `seqno` (per-agent):\n  - Monotonically increasing for each agent.\n  - Incremented once per outbound scheduling message.\n  - Included on all `CreateEntry`, `DeleteEntry`, `Finalize` messages.\n\nEnsure:\n\n- `CDPIServer.SendCreateEntry`, `SendDeleteEntry`, and `SendFinalize` use these helpers.\n- Behaviour is covered by unit tests:\n  - Tokens are propagated.\n  - Seqnos start from 1 (or 0, but consistently) and increment by 1 per message.\n  - Unknown agents return clear errors and do not panic.\n\n## Where to look\n\nCDPI server:\n\n- `internal/sbi/controller/cdpi_server.go` (or similar):\n  - `CDPIServer` definition:\n\n        type CDPIServer struct {\n            scheduling.UnimplementedControlDataPlaneInterfaceServer\n\n            State  *simstate.ScenarioState\n            Clock  sbi.EventScheduler\n\n            agentsMu sync.RWMutex\n            agents   map[string]*AgentHandle\n        }\n\n  - `AgentHandle` struct, currently something like:\n\n        type AgentHandle struct {\n            AgentID  string\n            NodeID   string\n            Stream   scheduling.ControlDataPlaneInterface_ReceiveRequestsServer\n            Outgoing chan *scheduling.ReceiveRequestsMessageFromController\n\n            Token string\n            SeqNo int64\n        }\n\n  - CDPI send helpers:\n\n        func (s *CDPIServer) SendCreateEntry(agentID string, action *sbi.ScheduledAction) error\n        func (s *CDPIServer) SendDeleteEntry(agentID, entryID string) error\n        func (s *CDPIServer) SendFinalize(agentID string, cutoff time.Time) error\n\nScheduling protos:\n\n- Generated scheduling package, e.g.:\n\n      internal/genproto/scheduling/v1alpha\n\n- Types to inspect:\n  - `CreateEntryRequest`\n  - `DeleteEntryRequest`\n  - `FinalizeRequest`\n  - Fields:\n    - `schedule_manipulation_token`\n    - `seqno`\n    - `request_id`\n    - `entry_id`\n    - Any timestamps or payload fields.\n\nExisting tests:\n\n- CDPI unit tests under:\n  - `internal/sbi/controller/cdpi_server_test.go` (or similar).\n- Check current coverage for:\n  - Agent registration.\n  - Outgoing channel behaviour.\n  - Basic send helpers.\n\nSearch terms:\n\n- `schedule_manipulation_token`\n- `seqno`\n- `CreateEntryRequest`\n- `DeleteEntryRequest`\n- `FinalizeRequest`\n- `AgentHandle`\n\n## Tasks\n\n### 1. Add helper methods on AgentHandle for token + seqno\n\nOn `AgentHandle`, add a small set of helpers to encapsulate token/seqno logic.\n\nFor example:\n\n- Token management:\n\n      func (h *AgentHandle) CurrentToken() string {\n          return h.Token\n      }\n\n      func (h *AgentHandle) SetToken(token string) {\n          h.Token = token\n      }\n\n  Design note:\n\n  - Token rotation will be triggered by `Reset`-handling code in a separate issue.\n  - For this issue, you only need to ensure the `Token` field is read consistently and attached to messages.\n\n- Seqno management:\n\n      func (h *AgentHandle) NextSeqNo() int64 {\n          h.SeqNo++\n          return h.SeqNo\n      }\n\n  Design note:\n\n  - Decide whether seqno starts at `0` or `1` (either is fine as long as tests match).\n  - Make sure seqno is strictly monotonically increasing per agent.\n\nIf you prefer not to put methods on `AgentHandle`, you can keep them as CDPI server helpers, but methods on `AgentHandle` tend to keep responsibilities more local.\n\n### 2. Implement an internal helper to build controller→agent messages\n\nInside `cdpi_server.go`, add a private helper that encapsulates token + seqno population and basic safety checks.\n\nFor example:\n\n- For create-entry:\n\n      func (s *CDPIServer) buildCreateEntryMessage(\n          h *AgentHandle,\n          action *sbi.ScheduledAction,\n      ) *scheduling.ReceiveRequestsMessageFromController {\n          seq := h.NextSeqNo()\n          token := h.CurrentToken()\n\n          // Map ScheduledAction → CreateEntryRequest payload.\n          // (Assume you already have mapping helpers from previous chunks.)\n          req := &scheduling.CreateEntryRequest{\n              // RequestId: action.RequestID (or generate if empty),\n              // EntryId:   action.EntryID,\n              // When:      ... (timestamp from action.When),\n              // ...\n              ScheduleManipulationToken: token,\n              Seqno:                     seq,\n          }\n\n          return &scheduling.ReceiveRequestsMessageFromController{\n              // Use the correct oneof wrapper from generated code:\n              // Message: &scheduling.ReceiveRequestsMessageFromController_Create{\n              //     Create: req,\n              // },\n          }\n      }\n\n- For delete-entry:\n\n      func (s *CDPIServer) buildDeleteEntryMessage(\n          h *AgentHandle,\n          entryID string,\n      ) *scheduling.ReceiveRequestsMessageFromController {\n          seq := h.NextSeqNo()\n          token := h.CurrentToken()\n\n          req := &scheduling.DeleteEntryRequest{\n              // EntryId: entryID,\n              ScheduleManipulationToken: token,\n              Seqno:                     seq,\n          }\n\n          return &scheduling.ReceiveRequestsMessageFromController{\n              // Message: &scheduling.ReceiveRequestsMessageFromController_Delete{\n              //     Delete: req,\n              // },\n          }\n      }\n\n- For finalize:\n\n      func (s *CDPIServer) buildFinalizeMessage(\n          h *AgentHandle,\n          cutoff time.Time,\n      ) *scheduling.ReceiveRequestsMessageFromController {\n          seq := h.NextSeqNo()\n          token := h.CurrentToken()\n\n          req := &scheduling.FinalizeRequest{\n              // CutoffTime:              timestamppb.New(cutoff),\n              ScheduleManipulationToken: token,\n              Seqno:                     seq,\n          }\n\n          return &scheduling.ReceiveRequestsMessageFromController{\n              // Message: &scheduling.ReceiveRequestsMessageFromController_Finalize{\n              //     Finalize: req,\n              // },\n          }\n      }\n\nNotes:\n\n- Replace field names with the actual generated identifiers from your scheduling protos.\n- Use the correct oneof variant wrappers as per the generated code (e.g. `*_CreateEntry`, `*_DeleteEntry`, `*_Finalize`).\n- If you already have mapping helpers for `ScheduledAction` → `CreateEntryRequest`, reuse them and only inject `token` and `seqno` in this issue.\n\n### 3. Wire helpers into CDPIServer send methods\n\nUpdate:\n\n- `SendCreateEntry`:\n\n      func (s *CDPIServer) SendCreateEntry(agentID string, action *sbi.ScheduledAction) error {\n          s.agentsMu.RLock()\n          handle, ok := s.agents[agentID]\n          s.agentsMu.RUnlock()\n          if !ok {\n              return fmt.Errorf(\"cdpi: agent %q not connected\", agentID)\n          }\n\n          msg := s.buildCreateEntryMessage(handle, action)\n          if msg == nil {\n              return fmt.Errorf(\"cdpi: failed to build create-entry message for agent %q\", agentID)\n          }\n\n          select {\n          case handle.Outgoing <- msg:\n              return nil\n          default:\n              // Channel full – for now, return a bounded error.\n              return fmt.Errorf(\"cdpi: outgoing channel full for agent %q\", agentID)\n          }\n      }\n\n- `SendDeleteEntry`:\n\n      func (s *CDPIServer) SendDeleteEntry(agentID, entryID string) error {\n          s.agentsMu.RLock()\n          handle, ok := s.agents[agentID]\n          s.agentsMu.RUnlock()\n          if !ok {\n              return fmt.Errorf(\"cdpi: agent %q not connected\", agentID)\n          }\n\n          msg := s.buildDeleteEntryMessage(handle, entryID)\n          if msg == nil {\n              return fmt.Errorf(\"cdpi: failed to build delete-entry message for agent %q\", agentID)\n          }\n\n          select {\n          case handle.Outgoing <- msg:\n              return nil\n          default:\n              return fmt.Errorf(\"cdpi: outgoing channel full for agent %q\", agentID)\n          }\n      }\n\n- `SendFinalize`:\n\n      func (s *CDPIServer) SendFinalize(agentID string, cutoff time.Time) error {\n          s.agentsMu.RLock()\n          handle, ok := s.agents[agentID]\n          s.agentsMu.RUnlock()\n          if !ok {\n              return fmt.Errorf(\"cdpi: agent %q not connected\", agentID)\n          }\n\n          msg := s.buildFinalizeMessage(handle, cutoff)\n          if msg == nil {\n              return fmt.Errorf(\"cdpi: failed to build finalize message for agent %q\", agentID)\n          }\n\n          select {\n          case handle.Outgoing <- msg:\n              return nil\n          default:\n              return fmt.Errorf(\"cdpi: outgoing channel full for agent %q\", agentID)\n          }\n      }\n\nDesign notes:\n\n- Token and seqno are **always** injected via `build*Message` helpers.\n- Unknown agent IDs are handled gracefully with a clear error.\n- You can keep the channel-full behaviour simple for now (return an error).\n\n### 4. Minimal token initialisation helper (for Reset integration)\n\nProvide a tiny helper on `CDPIServer` to set/rotate tokens, which a **separate Reset-handling issue** will call:\n\n- For example:\n\n      func (s *CDPIServer) setAgentToken(agentID, token string) error {\n          s.agentsMu.Lock()\n          defer s.agentsMu.Unlock()\n\n          handle, ok := s.agents[agentID]\n          if !ok {\n              return fmt.Errorf(\"cdpi: agent %q not connected\", agentID)\n          }\n\n          handle.SetToken(token)\n          handle.SeqNo = 0 // optionally reset seqno on token rotation\n          return 0\n      }\n\nNotes:\n\n- This issue does **not** define the token generation strategy (could be UUID, random string, counter, etc.).\n- It only provides a mechanism to set it; actual generation/rotation is delegated to a dedicated Reset issue.\n\n### 5. Unit tests for token + seqno behaviour\n\nIn `internal/sbi/controller/cdpi_server_test.go` (or similar):\n\n- Add tests focusing on `SendCreateEntry`, `SendDeleteEntry`, `SendFinalize` and their interaction with the token/seqno fields.\n\nSuggested test cases:\n\n1. CreateEntry attaches token and increments seqno\n\n   - Setup:\n     - Create a `CDPIServer` with a single registered `AgentHandle`:\n       - `AgentID = \"agent-1\"`.\n       - `Token = \"tok-123\"`.\n       - `SeqNo = 0`.\n       - `Outgoing` channel with buffer `1`.\n     - Provide a simple `ScheduledAction` with:\n       - `EntryID = \"entry-1\"`.\n   - Call:\n     - `s.SendCreateEntry(\"agent-1\", action)`.\n   - Assert:\n     - One message is present on `handle.Outgoing`.\n     - The message is a `CreateEntryRequest`.\n     - `ScheduleManipulationToken == \"tok-123\"`.\n     - `Seqno == 1` (assuming initial `SeqNo` was `0`).\n     - `EntryId` / other fields are correctly populated (if mapping is already in place).\n\n2. DeleteEntry reuses token and increments seqno\n\n   - Setup:\n     - Continue from previous test or start fresh with:\n       - `Token = \"tok-123\"`.\n       - `SeqNo = 1` (after first create).\n   - Call:\n     - `s.SendDeleteEntry(\"agent-1\", \"entry-1\")`.\n   - Assert:\n     - A second message appears on `Outgoing`.\n     - It is a `DeleteEntryRequest`.\n     - `ScheduleManipulationToken == \"tok-123\"`.\n     - `Seqno == 2`.\n\n3. FinalizeRequest uses token and increments seqno\n\n   - Setup:\n     - `Token = \"tok-XYZ\"`.\n     - `SeqNo = 10`.\n   - Call:\n     - `s.SendFinalize(\"agent-1\", cutoffTime)`.\n   - Assert:\n     - Message is a `FinalizeRequest`.\n     - `ScheduleManipulationToken == \"tok-XYZ\"`.\n     - `Seqno == 11`.\n     - `CutoffTime` is correctly set.\n\n4. Unknown agent returns error\n\n   - Call:\n     - `s.SendCreateEntry(\"missing-agent\", action)`.\n   - Assert:\n     - Returns a non-nil error.\n     - No panic.\n     - No message is enqueued on any known agent.\n\n5. Optional: channel full returns error\n\n   - Setup:\n     - `Outgoing` channel with buffer `0` or pre-filled to capacity.\n   - Call:\n     - One of the send helpers.\n   - Assert:\n     - Returns an error indicating channel full.\n     - No panic.\n\nThese tests should not attempt to drive the actual gRPC stream; they only validate:\n\n- Correct token + seqno values.\n- Correct mapping of basic payload fields.\n- Error handling paths.\n\n## Acceptance criteria\n\n- `AgentHandle`:\n\n  - Has a clear API for token and seqno:\n\n    - `SetToken(token string)` (or equivalent).\n    - `CurrentToken() string` (or equivalent).\n    - `NextSeqNo() int64` increments and returns the next seqno.\n\n  - `Token` and `SeqNo` fields are the canonical source of truth for schedule messages.\n\n- CDPI send helpers:\n\n  - `SendCreateEntry`, `SendDeleteEntry`, `SendFinalize`:\n\n    - Look up `AgentHandle` in a concurrency-safe way.\n    - Use a shared helper (`buildCreateEntryMessage`, `buildDeleteEntryMessage`, `buildFinalizeMessage`) to:\n      - Read the current token from `AgentHandle`.\n      - Increment `SeqNo` per message and set `seqno` on the request.\n      - Populate `schedule_manipulation_token` and `seqno` on the scheduling request.\n    - Push the resulting `ReceiveRequestsMessageFromController` onto `handle.Outgoing`.\n    - Return a clear error if:\n      - The agent is not connected.\n      - The outgoing channel is full (for now, simple bounded error handling is fine).\n\n- Token initialisation:\n\n  - A small helper exists on `CDPIServer` to set or rotate an agent’s token and (optionally) reset seqno.\n  - This helper is ready to be called by a separate Reset-handling issue.\n\n- Unit tests:\n\n  - Cover at least:\n\n    - A `CreateEntry` path where token and seqno are attached as expected.\n    - A `DeleteEntry` path where seqno increments and token remains stable.\n    - A `FinalizeRequest` path where seqno increments and token is attached.\n    - Unknown-agent behaviour returning an error without panicking.\n    - Optional coverage of the “channel full” error path.\n\n  - All tests pass via `go test ./...`.\n\n- Repository health:\n\n  - `go build ./...` passes with the new token/seqno logic.\n  - `go test ./...` passes, including the updated CDPI tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/153/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/153/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/154",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/154/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/154/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/154/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/154",
    "id": 3710669853,
    "node_id": "I_kwDOQfMfks7dLFQd",
    "number": 154,
    "title": "[Scope 4][Chunk 7] Enforce schedule_manipulation_token and seqno semantics in CDPI + agent Labels: scope:4-sbi, chunk:7-sbi-protocol-completeness, type:feature",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139252,
        "node_id": "LA_kwDOQfMfks8AAAACRw-ZdA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:7-sbi-protocol-completeness",
        "name": "chunk:7-sbi-protocol-completeness",
        "color": "1cbd8b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T12:29:09Z",
    "updated_at": "2025-12-09T12:29:09Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the time you reach **Chunk 7**, the CDPI stream and basic agent/controller plumbing are in place:\n\n- CDPI server (`CDPIServer`) accepts:\n  - Long-lived `ReceiveRequests` streams from agents.\n  - Initial `Hello` messages to register agents.\n  - `Reset` and `Response` messages from agents (currently mostly logged).\n- Controller can send scheduling commands:\n  - `CreateEntryRequest`\n  - `DeleteEntryRequest`\n  - `FinalizeRequest`\n- Agents:\n  - Maintain a local `pending` map of `ScheduledAction`s keyed by `EntryID`.\n  - Use an `EventScheduler` to execute actions at the appropriate sim time.\n  - Send `Response` messages back to the controller after execution.\n\nHowever, **SBI protocol semantics** around **schedule ownership and ordering** are still incomplete:\n\n- There is a `schedule_manipulation_token` in the SBI protos that is intended to:\n  - Tie a set of schedule entries to a specific schedule “era” on the agent.\n  - Ensure that stale controller messages (from an old token) are ignored.\n- There is a per-agent `seqno` field that should:\n  - Increase monotonically per agent for every controller→agent message.\n  - Help debug ordering and act as a simple guardrail against replays.\n\nCurrently, these fields are probably:\n\n- Present in the proto messages, but:\n  - Not enforced consistently.\n  - Not clearly updated on `Reset`.\n  - Not used on the agent to reject stale schedule updates.\n\nThis issue **finishes the mechanical parts** of token and seqno enforcement so that:\n\n- Controller:\n  - Manages a per-agent token and seqno on `AgentHandle`.\n  - Populates them correctly on all outbound scheduling commands.\n- Agent:\n  - Stores the current token and rejects messages with mismatched tokens.\n  - Treats seqno as a monotonic, sanity-checked field for logging / debugging.\n\nFull “policy” (e.g. sophisticated recovery/rehydration) remains out of scope; the goal here is to get the **baseline protocol correctness** in place.\n\n## Goal\n\nImplement **minimal but correct semantics** for:\n\n- `schedule_manipulation_token`:\n  - Controller generates and updates it per agent (especially on `Reset`).\n  - All controller→agent messages carry the current token.\n  - Agent rejects messages whose token doesn’t match its current token.\n- `seqno`:\n  - Controller maintains a monotonically increasing `seqno` per agent.\n  - All controller→agent messages carry the next seqno.\n  - Agent stores the last seen seqno and logs if it receives an out-of-order or stale seqno.\n\nWhile:\n\n- Keeping behaviour tolerant and log-oriented (no hard panics).\n- Preserving existing happy-path scheduling behaviour.\n- Covering both sides (CDPI server + Agent) with targeted unit tests.\n\n## Where to look\n\nCDPI server (controller side):\n\n- Likely under something like:\n\n      internal/sbi/controller/cdpi_server.go\n\n- Types of interest:\n\n      type CDPIServer struct {\n          scheduling.UnimplementedControlDataPlaneInterfaceServer\n\n          State    *simstate.ScenarioState\n          Clock    sbi.EventScheduler\n          agentsMu sync.RWMutex\n          agents   map[string]*AgentHandle\n          // ...\n      }\n\n      type AgentHandle struct {\n          AgentID  string\n          NodeID   string\n          Stream   scheduling.ControlDataPlaneInterface_ReceiveRequestsServer\n          Outgoing chan *scheduling.ReceiveRequestsMessageFromController\n\n          Token string\n          SeqNo int64\n\n          // optional: logger, bookkeeping fields\n      }\n\n- Methods to update:\n\n      func (s *CDPIServer) ReceiveRequests(stream scheduling.ControlDataPlaneInterface_ReceiveRequestsServer) error\n      func (s *CDPIServer) SendCreateEntry(agentID string, action *sbi.ScheduledAction) error\n      func (s *CDPIServer) SendDeleteEntry(agentID, entryID string) error\n      func (s *CDPIServer) SendFinalize(agentID string, cutoff time.Time) error\n\n- Existing `handleAgentMessage`, `handleAgentReset`, `handleAgentResponse` helpers from previous chunks.\n\nAgent (node side):\n\n- Under something like:\n\n      internal/sbi/agent/agent.go\n\n- Types / fields:\n\n      type Agent struct {\n          AgentID   string\n          NodeID    string\n          State     *simstate.ScenarioState\n          Scheduler sbi.EventScheduler\n\n          // CDPI stream/client:\n          Stream scheduling.ControlDataPlaneInterface_ReceiveRequestsClient\n\n          mu      sync.Mutex\n          pending map[string]*sbi.ScheduledAction\n\n          token         string // agent-side current schedule_manipulation_token\n          lastSeqNoSeen int64  // for logging sanity checks\n      }\n\n- Methods where token/seqno should be enforced:\n\n      func (a *Agent) runStreamLoop(ctx context.Context)\n      func (a *Agent) handleControllerMessage(msg *scheduling.ReceiveRequestsMessageFromController)\n      // or similar Create/Delete/Finalize handlers\n\nSBI scheduling protos:\n\n- Generated package, something like:\n\n      internal/genproto/scheduling/v1alpha\n\n- Important messages / fields:\n\n      message CreateEntryRequest {\n          string schedule_manipulation_token = ...;\n          int64 seqno = ...;\n          // ...\n      }\n\n      message DeleteEntryRequest {\n          string schedule_manipulation_token = ...;\n          int64 seqno = ...;\n          // ...\n      }\n\n      message FinalizeRequest {\n          string schedule_manipulation_token = ...;\n          int64 seqno = ...;\n          // ...\n      }\n\n      message ResetRequest {\n          string agent_id = ...;\n          // ...\n      }\n\nCheck exact field names and accessors with your editor’s “go to definition”.\n\nSearch terms:\n\n- `schedule_manipulation_token`\n- `seqno`\n- `AgentHandle.Token`\n- `AgentHandle.SeqNo`\n- `ResetRequest`\n- `CreateEntryRequest`\n- `DeleteEntryRequest`\n- `FinalizeRequest`\n\n## Tasks\n\n### 1. Establish token/seqno lifecycle on the controller\n\n1.1 Generate initial token on agent registration\n\n- In `ReceiveRequests` (after processing initial `Hello` and before registering the `AgentHandle`):\n\n  - Generate an initial token string, e.g.:\n\n        handle.Token = newRandomToken() // e.g. UUID or random hex\n\n  - Initialize seqno:\n\n        handle.SeqNo = 0\n\n  - Add a helper:\n\n        func (s *CDPIServer) newToken() string {\n            // small, deterministic helper for now (e.g. UUID, rand string, or counter-based for tests)\n        }\n\n- Document briefly in comments that tokens are opaque controller-generated identifiers.\n\n1.2 Helper to get next seqno\n\n- Add a small helper on `AgentHandle` or `CDPIServer`:\n\n      func (h *AgentHandle) nextSeqNo() int64 {\n          h.SeqNo++\n          return h.SeqNo\n      }\n\n- Or, if you prefer, keep a `bumpSeqNo` helper on `CDPIServer` that:\n\n  - Looks up the handle.\n  - Atomically increments `SeqNo`.\n  - Returns the new value.\n\n  (Guard with `agentsMu` or the handle’s own mutex, consistent with your existing concurrency pattern.)\n\n### 2. Populate token/seqno in controller→agent messages\n\nUpdate send helpers so that **every** controller→agent scheduling message carries token + seqno:\n\n2.1 `SendCreateEntry`\n\n- After retrieving `AgentHandle`:\n\n  - Compute `seq := handle.nextSeqNo()`.\n  - Build `CreateEntryRequest` with:\n\n        ScheduleManipulationToken = handle.Token\n        Seqno                     = seq\n        // plus the rest of the fields from ScheduledAction\n\n- Attach to `ReceiveRequestsMessageFromController` as usual and push to `handle.Outgoing`.\n\n2.2 `SendDeleteEntry`\n\n- Symmetric to `SendCreateEntry`:\n\n  - Get handle.\n  - `seq := handle.nextSeqNo()`.\n  - Build `DeleteEntryRequest` with:\n\n        ScheduleManipulationToken = handle.Token\n        Seqno                     = seq\n\n  - Push onto `Outgoing`.\n\n2.3 `SendFinalize`\n\n- Same pattern:\n\n  - Get handle.\n  - `seq := handle.nextSeqNo()`.\n  - Build `FinalizeRequest` with:\n\n        ScheduleManipulationToken = handle.Token\n        Seqno                     = seq\n        CutoffTime                = <converted proto timestamp>\n\n  - Push onto `Outgoing`.\n\n2.4 Logging\n\n- Optionally enhance logs for controller→agent sends:\n\n  - Include agent_id, entry_id (if applicable), token, seqno.\n\n### 3. Implement token reset semantics on controller side\n\nExtend `handleAgentReset` in `CDPIServer`:\n\n3.1 Generate a new token on reset\n\n- On handling a `ResetRequest` from an agent:\n\n  - Look up its `AgentHandle`.\n  - Generate a new token with `newToken()` and overwrite `handle.Token`.\n  - Reset `handle.SeqNo = 0` (or leave monotonically increasing; for simplicity, resetting to 0 is fine as long as it’s per-token).\n\n3.2 Clear known server-side schedule state (optional but recommended)\n\n- If `CDPIServer` maintains any map of “known scheduled entries per agent”:\n\n  - Clear that collection for this agent.\n  - Document that rebuilding schedule is the responsibility of higher-level scheduler logic.\n\n3.3 Logging\n\n- Log at INFO/WARN:\n\n  - Old token, new token, agent_id, node_id.\n\n### 4. Enforce token/seqno on the agent\n\n4.1 Store current token and last seqno\n\n- Ensure `Agent` struct has:\n\n      type Agent struct {\n          // existing fields...\n          mu            sync.Mutex\n          token         string\n          lastSeqNoSeen int64\n          // ...\n      }\n\n- Initialize:\n\n  - `token` to empty string before first scheduling message.\n  - `lastSeqNoSeen` to 0.\n\n4.2 Derive or accept token\n\n- For Scope 4, simplest strategy:\n\n  - First valid scheduling message (e.g. first `CreateEntryRequest`) establishes the token:\n\n        if a.token == \"\" {\n            a.token = req.ScheduleManipulationToken\n        }\n\n  - Subsequent messages must match `a.token`.\n\n- Alternatively, if you already propagate token from an initial `Reset`/`Hello` handshake, keep that, but this “lazy capture” works fine mechanically.\n\n4.3 Token enforcement in controller→agent handlers\n\n- In the agent’s message handler (e.g. `handleControllerMessage` or specific per-message helpers):\n\n  - Before applying any `CreateEntry`, `DeleteEntry`, `Finalize`:\n\n        token := req.ScheduleManipulationToken\n        if token == \"\" {\n            // log and ignore\n            a.logWarn(\"cdpi: missing schedule_manipulation_token\", ...)\n            return\n        }\n\n        if a.token == \"\" {\n            a.token = token\n        } else if a.token != token {\n            // stale or wrong token → log and ignore\n            a.logWarn(\"cdpi: token mismatch, ignoring scheduling message\",\n                \"agent_id\", a.AgentID,\n                \"expected_token\", a.token,\n                \"got_token\", token,\n            )\n            return\n        }\n\n- This ensures stale messages from an old token do not change the local schedule.\n\n4.4 Seqno sanity check\n\n- For each scheduling message, after token check:\n\n      seq := req.Seqno\n\n      if seq <= 0 {\n          // non-fatal, but log odd values\n          a.logDebug(\"cdpi: non-positive seqno\", \"seqno\", seq)\n      }\n\n      if a.lastSeqNoSeen != 0 && seq <= a.lastSeqNoSeen {\n          a.logWarn(\"cdpi: non-monotonic seqno (possible replay/out-of-order)\",\n              \"agent_id\", a.AgentID,\n              \"last\", a.lastSeqNoSeen,\n              \"current\", seq,\n          )\n          // still proceed for Scope 4; we only log\n      }\n\n      a.lastSeqNoSeen = seq\n\n- For Scope 4, behaviour is **log-only**; do not drop messages solely due to seqno issues.\n\n### 5. Agent behaviour on Reset\n\nAlthough a separate Chunk 7 issue may focus specifically on Reset RPC, this task should ensure agent-side token is updated consistently:\n\n- When the agent initiates or receives a `Reset` (depending on your design):\n\n  - Clear local schedule:\n\n        a.mu.Lock()\n        a.pending = make(map[string]*sbi.ScheduledAction)\n        a.mu.Unlock()\n\n  - Clear or update token:\n\n        a.mu.Lock()\n        a.token = \"\"      // let next scheduling message establish the new token\n        a.lastSeqNoSeen = 0\n        a.mu.Unlock()\n\n- Make sure any scheduled events for pending actions are cancelled via the `EventScheduler` if you track event IDs.\n\n### 6. Unit tests\n\nAdd / extend tests under something like:\n\n- `internal/sbi/controller/cdpi_token_seqno_test.go`\n- `internal/sbi/agent/agent_token_seqno_test.go`\n\nController tests:\n\n1. **Token and seqno set on first send**\n\n   - Create a `CDPIServer` with a single `AgentHandle` (registered manually for the test).\n   - Call `SendCreateEntry` twice for the same agent.\n   - Assert:\n     - Both messages on `handle.Outgoing` have the same non-empty `ScheduleManipulationToken`.\n     - `seqno` is `1` then `2`.\n\n2. **Token changes on Reset**\n\n   - Simulate an agent sending `ResetRequest`.\n   - Capture old token.\n   - Assert:\n     - New token is non-empty and not equal to old token.\n     - `SeqNo` is reset (or clearly documented if not).\n\n3. **Unknown agent behaviour unchanged**\n\n   - `SendCreateEntry(\"unknown\", ...)` still returns an error and does not panic.\n\nAgent tests:\n\n1. **First message sets token**\n\n   - Create an `Agent` with empty `token`.\n   - Feed a `CreateEntryRequest` with token `\"tok-1\"`.\n   - Assert:\n     - `a.token == \"tok-1\"`.\n     - Message is accepted and scheduled (pending map updated).\n\n2. **Mismatched token is rejected**\n\n   - Agent has `token = \"tok-1\"`.\n   - Feed `CreateEntryRequest` with token `\"tok-2\"`.\n   - Assert:\n     - No new entries are added to `pending`.\n     - Appropriate warning logged (if logger is testable).\n\n3. **Seqno strictly increasing is accepted**\n\n   - Agent with `lastSeqNoSeen = 0`.\n   - Feed messages with seqno 1, 2, 3.\n   - Assert:\n     - `lastSeqNoSeen == 3`.\n     - No warnings about non-monotonic seqno.\n\n4. **Out-of-order seqno only logs**\n\n   - Agent with `lastSeqNoSeen = 5`.\n   - Feed message with seqno 4.\n   - Assert:\n     - Warning logged about non-monotonic seqno.\n     - Message still applied (pending updated).\n\n5. **Reset clears token & seqno**\n\n   - Agent with populated `pending`, `token != \"\"`, `lastSeqNoSeen > 0`.\n   - Invoke agent reset helper (the one you use in response to a Reset RPC).\n   - Assert:\n     - `pending` is empty.\n     - `token == \"\"`.\n     - `lastSeqNoSeen == 0`.\n\n## Acceptance criteria\n\n- **Controller / CDPI server:**\n  - `AgentHandle` maintains:\n    - `Token string`\n    - `SeqNo int64`\n  - On agent registration:\n    - A non-empty `Token` is generated.\n    - `SeqNo` is initialized.\n  - `SendCreateEntry`, `SendDeleteEntry`, and `SendFinalize`:\n    - Populate `schedule_manipulation_token` with the current `AgentHandle.Token`.\n    - Populate `seqno` with `AgentHandle.SeqNo + 1` (monotonically increasing).\n  - `handleAgentReset`:\n    - Generates a new token for that agent.\n    - Resets or clearly re-initialises `SeqNo`.\n    - Optionally clears any server-side schedule tracking for that agent.\n  - Unit tests verify:\n    - Token/seqno are present and behave as expected.\n    - Reset results in a new token.\n\n- **Agent:**\n  - `Agent` struct holds:\n    - `token string`\n    - `lastSeqNoSeen int64`\n  - Token handling:\n    - First valid scheduling message sets `token` if it is empty.\n    - Subsequent messages must match `token` or they are logged and ignored.\n  - Seqno handling:\n    - `lastSeqNoSeen` is updated on each message.\n    - Non-monotonic seqno values cause warnings but do not stop processing.\n  - On agent-side reset:\n    - Local schedule (`pending`) is cleared.\n    - `token` is cleared (or updated according to your design).\n    - `lastSeqNoSeen` is reset.\n  - Unit tests cover:\n    - Token establishment and mismatch behaviour.\n    - Seqno monotonicity logging.\n    - Reset clearing token and seqno.\n\n- **Repository health:**\n  - `go build ./...` passes with the new token/seqno logic.\n  - `go test ./...` passes, including new CDPI + Agent protocol tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/154/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/154/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/155",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/155/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/155/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/155/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/155",
    "id": 3710762912,
    "node_id": "I_kwDOQfMfks7dLb-g",
    "number": 155,
    "title": "[Scope 4][Chunk 7] Stub SetSrPolicy/DeleteSrPolicy handling on agent and controller",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139252,
        "node_id": "LA_kwDOQfMfks8AAAACRw-ZdA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:7-sbi-protocol-completeness",
        "name": "chunk:7-sbi-protocol-completeness",
        "color": "1cbd8b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T12:50:09Z",
    "updated_at": "2025-12-09T12:50:09Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy this point in **Chunk 7** you should already have:\n\n- A **CDPI server** on the controller side (`CDPIServer`) that:\n  - Accepts `ReceiveRequests` streams from agents.\n  - Tracks connected agents via `AgentHandle`.\n  - Can send `CreateEntry`, `DeleteEntry`, `Finalize` messages to agents.\n  - Handles basic `Hello`, `Reset`, and `Response` messages from agents.\n\n- An **Agent** implementation that:\n  - Connects to the controller via `ControlDataPlaneInterface.ReceiveRequests`.\n  - Receives `CreateEntry` / `DeleteEntry` / `Finalize` and schedules/executes `ScheduledAction`s.\n  - Applies beam/route changes to `ScenarioState`.\n  - Sends `Response` messages back to the controller.\n\nChunk 7’s scope is **SBI protocol completeness**, including:\n\n- Proper `Reset` semantics.\n- `schedule_manipulation_token` + `seqno`.\n- `FinalizeRequest` semantics.\n- Basic handling of **SR policies** (segment-routing policy messages).\n\nPer the Scope 4 plan, **SR Policy** behavior can initially be **stubbed**:\n\n- We should accept `SetSrPolicy` and `DeleteSrPolicy` messages on the SBI.\n- We should **store** them in a minimal, inspectable form on the agent/controller.\n- We explicitly **do not** need to:\n  - Enforce them in path computation yet.\n  - Modify routing tables based on SR policies.\n  - Expose SR policy state via NBI.\n\nThis issue focuses purely on making the SBI **protocol-complete** with respect to `SetSrPolicy` / `DeleteSrPolicy`, with no complex semantics.\n\n## Goal\n\n- Extend **CDPI server** and **Agent** to:\n\n  - Recognize and parse `SetSrPolicy` / `DeleteSrPolicy` messages (on the appropriate side).\n  - Maintain a minimal in-memory representation of SR policies (e.g. a map keyed by policy ID).\n  - Log SR policy events for observability.\n\n- Keep all SR policy behavior **no-op** with respect to connectivity/routing in Scope 4:\n  - No changes to `ScenarioState` topology or routing.\n  - No interaction with ServiceRequests yet.\n\n- Add **unit tests** that:\n\n  - Prove `SetSrPolicy` and `DeleteSrPolicy` messages are accepted without panics.\n  - Confirm SR policy state is updated on the agent (and optionally the controller).\n  - Confirm unknown/duplicate operations are handled safely and logged.\n\n## Where to look\n\nSBI scheduling protos (generated in Chunk 1):\n\n- Under something like:\n\n      internal/genproto/scheduling/v1alpha\n\n- Look for:\n  - `SetSrPolicyRequest`, `DeleteSrPolicyRequest`, or similar messages.\n  - Wrappers in the CDPI stream:\n    - For controller→agent messages:\n      - `ReceiveRequestsMessageFromController` one-of:\n        - `*_SetSrPolicy`, `*_DeleteSrPolicy`, etc.\n    - For agent→controller messages (if any SR-related responses exist).\n\nAgent implementation (Chunk 4+7):\n\n- Likely under:\n\n      internal/sbi/agent/agent.go\n      internal/sbi/agent/agent_scheduling.go\n      internal/sbi/agent/agent_telemetry.go\n\n- Where the agent already:\n  - Handles `CreateEntryRequest` / `DeleteEntryRequest` / `FinalizeRequest`.\n  - Converts schedule protos into `ScheduledAction`.\n  - Executes `ScheduledAction` against `ScenarioState`.\n\nCDPI server (controller side):\n\n- Under something like:\n\n      internal/sbi/controller/cdpi_server.go\n      internal/sbi/controller/cdpi_agent_msg.go\n\n- Where you already:\n  - Define `CDPIServer` and `AgentHandle`.\n  - Implement `ReceiveRequests`.\n  - Implement `handleAgentMessage` for:\n    - `Hello`\n    - `Reset`\n    - `Response`\n\nExisting SR policy internal types (if any):\n\n- If you already sketched an internal `SrPolicySpec` or similar in earlier chunks, reuse it.\n- If not, you can define a minimal stub type in a suitable package (e.g. `internal/sbi/types` or `sim/state`).\n\nSearch terms:\n\n- `SetSrPolicy`\n- `DeleteSrPolicy`\n- `SrPolicy`\n- `ReceiveRequestsMessageFromController`\n- `ScheduledActionType` (if you already have SR-related variants defined)\n\n## Tasks\n\n### 1. Define minimal internal SR policy model\n\nIf not already present, define a simple internal SR policy representation, e.g.:\n\n- In a shared SBI types package (`internal/sbi/types` or similar):\n\n      type SrPolicySpec struct {\n          PolicyID string\n          SrcNode  string\n          DstNode  string\n          Hops     []string // node IDs or interface IDs\n          // Optional fields:\n          // Priority, bandwidth hints, etc. – keep as strings for now.\n      }\n\n- This struct is **not** used by connectivity yet; it’s just a container for SBI data.\n\nDesign notes:\n\n- Keep the model intentionally minimal; only include fields that are obviously present in the proto.\n- Document in a comment that:\n  - SrPolicy is **stubbed** in Scope 4.\n  - Future scopes may refine the type or move it closer to the routing/forwarding model.\n\n### 2. Extend Agent struct to track SR policies\n\nIn the Agent type (`internal/sbi/agent/agent.go`), add SR policy fields and locking:\n\n- For example:\n\n      type Agent struct {\n          // existing fields...\n\n          srMu      sync.Mutex\n          srPolicies map[string]*types.SrPolicySpec // key: PolicyID\n      }\n\n- Initialize `srPolicies` in the Agent constructor or `Start`:\n\n      if a.srPolicies == nil {\n          a.srPolicies = make(map[string]*types.SrPolicySpec)\n      }\n\n### 3. Handle SetSrPolicy/DeleteSrPolicy in Agent message dispatch\n\nIn the agent’s CDPI **receive path**, where you dispatch controller→agent messages:\n\n- Locate the place that handles `ReceiveRequestsMessageFromController`:\n\n      func (a *Agent) handleControllerMessage(msg *scheduling.ReceiveRequestsMessageFromController) {\n          switch m := msg.GetMessage().(type) {\n          case *scheduling.ReceiveRequestsMessageFromController_CreateEntry:\n              // existing logic...\n          case *scheduling.ReceiveRequestsMessageFromController_DeleteEntry:\n              // existing logic...\n          case *scheduling.ReceiveRequestsMessageFromController_Finalize:\n              // existing logic...\n          // NEW:\n          case *scheduling.ReceiveRequestsMessageFromController_SetSrPolicy:\n              a.handleSetSrPolicy(m.SetSrPolicy)\n          case *scheduling.ReceiveRequestsMessageFromController_DeleteSrPolicy:\n              a.handleDeleteSrPolicy(m.DeleteSrPolicy)\n          default:\n              // log unknown\n          }\n      }\n\n- Implement `handleSetSrPolicy`:\n\n      func (a *Agent) handleSetSrPolicy(req *scheduling.SetSrPolicyRequest) {\n          if req == nil {\n              return\n          }\n\n          spec := &types.SrPolicySpec{\n              PolicyID: req.GetPolicyId(),\n              SrcNode:  req.GetSrcNodeId(),\n              DstNode:  req.GetDstNodeId(),\n              Hops:     append([]string(nil), req.GetHops()...),\n          }\n\n          a.srMu.Lock()\n          defer a.srMu.Unlock()\n\n          if a.srPolicies == nil {\n              a.srPolicies = make(map[string]*types.SrPolicySpec)\n          }\n          a.srPolicies[spec.PolicyID] = spec\n\n          // Log stubbed behavior.\n          if a.Logger != nil {\n              a.Logger.Info(\"agent: SetSrPolicy stub applied\",\n                  \"agent_id\", a.AgentID,\n                  \"node_id\", a.NodeID,\n                  \"policy_id\", spec.PolicyID)\n          }\n      }\n\n- Implement `handleDeleteSrPolicy`:\n\n      func (a *Agent) handleDeleteSrPolicy(req *scheduling.DeleteSrPolicyRequest) {\n          if req == nil {\n              return\n          }\n\n          policyID := req.GetPolicyId()\n          if policyID == \"\" {\n              return\n          }\n\n          a.srMu.Lock()\n          defer a.srMu.Unlock()\n\n          delete(a.srPolicies, policyID)\n\n          if a.Logger != nil {\n              a.Logger.Info(\"agent: DeleteSrPolicy stub applied\",\n                  \"agent_id\", a.AgentID,\n                  \"node_id\", a.NodeID,\n                  \"policy_id\", policyID)\n          }\n      }\n\nNotes:\n\n- Do **not** alter `ScenarioState` or routing here.\n- Behavior is limited to:\n  - Storing SR policies in memory.\n  - Logging `SetSrPolicy` / `DeleteSrPolicy`.\n\n### 4. Optional: Controller-side SR policy registry\n\nDepending on how much symmetry you want in Scope 4:\n\n- You may also want `CDPIServer` to maintain a simple view of SR policies per agent, for debugging:\n\n      type CDPIServer struct {\n          // existing fields...\n          srMu       sync.Mutex\n          srPolicies map[string]map[string]*types.SrPolicySpec // agentID → policyID → spec\n      }\n\n- Add helper methods:\n\n      func (s *CDPIServer) recordSrPolicy(agentID string, spec *types.SrPolicySpec) {\n          s.srMu.Lock()\n          defer s.srMu.Unlock()\n          if s.srPolicies == nil {\n              s.srPolicies = make(map[string]map[string]*types.SrPolicySpec)\n          }\n          m := s.srPolicies[agentID]\n          if m == nil {\n              m = make(map[string]*types.SrPolicySpec)\n              s.srPolicies[agentID] = m\n          }\n          m[spec.PolicyID] = spec\n      }\n\n      func (s *CDPIServer) deleteSrPolicy(agentID, policyID string) {\n          s.srMu.Lock()\n          defer s.srMu.Unlock()\n          if m := s.srPolicies[agentID]; m != nil {\n              delete(m, policyID)\n          }\n      }\n\n- You can call these from:\n  - Places where the controller **originates** SR policy requests (future scheduler logic).\n  - Or from any SR policy-related responses (if the protos support them).\n\nFor this issue, marking controller-side SR tracking as **optional** is fine. The hard requirement is that the agent side **accepts and stores** policies.\n\n### 5. Logging and debug helpers\n\nEnsure you have useful logs when SR policy messages are processed:\n\n- On the agent:\n\n  - `SetSrPolicy`:\n    - Log `agent_id`, `node_id`, `policy_id`, and perhaps hop count.\n  - `DeleteSrPolicy`:\n    - Log `agent_id`, `node_id`, `policy_id`.\n\n- Optionally add a small debug helper for introspection (for developer use only):\n\n      func (a *Agent) DumpSrPolicies() []*types.SrPolicySpec {\n          a.srMu.Lock()\n          defer a.srMu.Unlock()\n\n          out := make([]*types.SrPolicySpec, 0, len(a.srPolicies))\n          for _, p := range a.srPolicies {\n              // Return shallow copies if you want to avoid external mutation.\n              cp := *p\n              out = append(out, &cp)\n          }\n          return out\n      }\n\nDocument that:\n\n- This is a **debug helper** for tests/CLI tools.\n- It is not exposed via NBI yet.\n\n### 6. Unit tests for SR policy handling\n\nAdd tests under something like:\n\n- `internal/sbi/agent/agent_srpolicy_test.go`\n\nTest cases to cover:\n\n1. **SetSrPolicy stores a policy**\n\n   - Arrange:\n     - Create an `Agent` with initialized `srPolicies` map and a test logger (or nil).\n     - Build a `ReceiveRequestsMessageFromController` with the `SetSrPolicy` variant set, containing:\n       - `PolicyId = \"pol-1\"`.\n       - `SrcNodeId`, `DstNodeId`.\n       - 1–2 hops.\n   - Act:\n     - Call the same handler path as normal agent operation (e.g. `agent.handleControllerMessage(msg)`).\n   - Assert:\n     - `agent.srPolicies[\"pol-1\"]` exists.\n     - Fields match the request.\n\n2. **DeleteSrPolicy removes an existing policy**\n\n   - Arrange:\n     - Pre-populate `agent.srPolicies[\"pol-1\"]`.\n     - Build `DeleteSrPolicyRequest` with `PolicyId = \"pol-1\"`.\n   - Act:\n     - Call `handleControllerMessage` with a `DeleteSrPolicy` wrapper.\n   - Assert:\n     - `agent.srPolicies[\"pol-1\"]` no longer exists.\n\n3. **DeleteSrPolicy is safe for unknown policies**\n\n   - Arrange:\n     - `srPolicies` map does not contain `\"missing\"`.\n   - Act:\n     - Call `handleDeleteSrPolicy` with `PolicyId = \"missing\"`.\n   - Assert:\n     - No panic.\n     - `srPolicies` map remains valid (size unchanged).\n\n4. **Nil / empty requests are ignored safely**\n\n   - Act:\n     - Call `handleSetSrPolicy(nil)` and `handleDeleteSrPolicy(nil)`.\n   - Assert:\n     - No panic.\n     - `srPolicies` remains unchanged.\n\nIf you implement controller-side SR policy tracking:\n\n- Add tests under `internal/sbi/controller/cdpi_srpolicy_test.go` for:\n\n  - `recordSrPolicy` populating `srPolicies[agentID][policyID]`.\n  - `deleteSrPolicy` removing entries safely.\n\n## Acceptance criteria\n\n- Internal SR policy model:\n  - A minimal `SrPolicySpec` type exists (or equivalent) to hold SR policy data from SBI messages.\n  - Clearly documented as a **stub** for Scope 4.\n\n- Agent behavior:\n  - `Agent` struct has fields to store SR policies:\n    - `srPolicies map[string]*SrPolicySpec` (or equivalent), with a mutex.\n  - Agent’s CDPI receive path:\n    - Properly dispatches `SetSrPolicy` and `DeleteSrPolicy` messages via dedicated helpers.\n  - `handleSetSrPolicy`:\n    - Translates `SetSrPolicyRequest` proto → `SrPolicySpec`.\n    - Inserts/updates the policy in `srPolicies`.\n    - Logs that a stubbed SR policy has been applied.\n  - `handleDeleteSrPolicy`:\n    - Removes the policy from `srPolicies` if present.\n    - Is safe if the policy is unknown or `PolicyId` is empty.\n    - Logs that a stubbed SR policy has been deleted.\n\n- Controller behavior (optional but recommended):\n  - `CDPIServer` can track SR policies per agent in a simple map.\n  - Helper methods `recordSrPolicy` / `deleteSrPolicy` exist and are covered by tests.\n\n- No changes to ScenarioState / routing:\n  - SR policies **do not** modify connectivity or routing tables in Scope 4.\n  - No dependency from `SrPolicySpec` into the connectivity engine yet.\n\n- Logging & debug:\n  - SR policy events are logged at INFO/DEBUG level for both `SetSrPolicy` and `DeleteSrPolicy`.\n  - (Optional) `DumpSrPolicies` or equivalent debug helper exists for agents.\n\n- Tests:\n  - Agent SR policy tests:\n    - Verify policies are stored on `SetSrPolicy`.\n    - Verify policies are removed on `DeleteSrPolicy`.\n    - Verify unknown/empty requests are handled safely.\n  - If implemented, controller SR policy tests cover record/delete helpers.\n  - All new tests pass via `go test ./...`.\n\n- Repository health:\n  - `go build ./...` succeeds after all SR policy stubbing changes.\n  - `go test ./...` passes, including new SR policy tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/155/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/155/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/156",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/156/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/156/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/156/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/156",
    "id": 3710859220,
    "node_id": "I_kwDOQfMfks7dLzfU",
    "number": 156,
    "title": "[Scope 4][Chunk 7] Implement FinalizeRequest semantics in CDPI server and Agent",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139252,
        "node_id": "LA_kwDOQfMfks8AAAACRw-ZdA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:7-sbi-protocol-completeness",
        "name": "chunk:7-sbi-protocol-completeness",
        "color": "1cbd8b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T13:11:39Z",
    "updated_at": "2025-12-09T13:11:39Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nIn Scope 4 / Chunk 5–6 you already have:\n\n- A controller-side `CDPIServer` that:\n  - Accepts long-lived `ReceiveRequests` streams from agents.\n  - Maintains an `AgentHandle` per connected agent with:\n    - `AgentID`, `NodeID`.\n    - An outgoing channel for controller→agent messages.\n    - Schedule token + seqno fields.\n- Controller-side helpers such as:\n  - `SendCreateEntry(agentID, action *ScheduledAction)`.\n  - `SendDeleteEntry(agentID, entryID string)`.\n- An `Agent` implementation that:\n  - Receives `CreateEntryRequest` / `DeleteEntryRequest` on the stream.\n  - Converts them into internal `ScheduledAction`s.\n  - Schedules callbacks on `EventScheduler` to execute those actions.\n  - Maintains a local `pending` map (by `EntryID`) of scheduled actions.\n\nThe SBI protocol also defines **FinalizeRequest** semantics:\n\n- Controller can send a `FinalizeRequest` with a `cutoff_time` to an agent.\n- Agent should:\n  - Drop any scheduled entries with `When < cutoff_time`.\n  - Keep events scheduled **after** the cutoff.\n- This allows the controller to say:\n  - “I promise not to modify schedule before `cutoff_time`; you can treat earlier actions as ‘final’ or prune old entries.”\n\nFrom the Scope 4 plan, Chunk 7 wants **protocol completeness**, including:\n\n- Implementing `FinalizeRequest` end-to-end.\n- Ensuring both CDPI server and Agent respect the cutoff time.\n- Keeping behaviour simple (no fancy rescheduling logic yet).\n\n## Goal\n\n- On the **controller side**:\n  - Provide a helper to send `FinalizeRequest` to a specific agent.\n  - Use the existing token + seqno tracking on `AgentHandle`.\n- On the **agent side**:\n  - Handle `FinalizeRequest` messages from the controller.\n  - Drop local scheduled actions with `When < cutoff_time`:\n    - Cancel them in `EventScheduler`.\n    - Remove from the `pending` map.\n- Add unit tests that validate:\n  - Controller constructs and sends a well-formed `FinalizeRequest`.\n  - Agent prunes only the expected entries and keeps future ones.\n\n## Where to look\n\nCDPI server and controller-side SBI code:\n\n- Likely under:\n\n      internal/sbi/controller/cdpi_server.go\n      internal/sbi/controller/cdpi_server_test.go\n\n- Relevant pieces:\n  - `CDPIServer` struct with:\n    - `agentsMu`, `agents map[string]*AgentHandle`.\n  - `AgentHandle`:\n\n        type AgentHandle struct {\n            AgentID  string\n            NodeID   string\n            Stream   scheduling.ControlDataPlaneInterface_ReceiveRequestsServer\n            Outgoing chan *scheduling.ReceiveRequestsMessageFromController\n\n            Token string\n            SeqNo int64\n\n            // possibly: logger / lastReset / counters\n        }\n\n  - Existing methods:\n    - `SendCreateEntry(...)`.\n    - `SendDeleteEntry(...)`.\n    - Possibly a stub `SendFinalize(...)` from earlier chunks.\n\nAgent implementation:\n\n- Under something like:\n\n      internal/sbi/agent/agent.go\n      internal/sbi/agent/agent_scheduling.go\n      internal/sbi/agent/agent_test.go\n\n- Relevant pieces:\n\n      type Agent struct {\n          AgentID   string\n          NodeID    string\n          State     *simstate.ScenarioState\n          Scheduler sbi.EventScheduler\n\n          mu      sync.Mutex\n          pending map[string]*ScheduledAction // EntryID → action\n          // ...\n      }\n\n- Stream handling:\n  - Read loop for `ReceiveRequestsMessageFromController`:\n    - `CreateEntryRequest` → schedule action.\n    - `DeleteEntryRequest` → cancel + delete.\n    - This is where `FinalizeRequest` handling will be added.\n\nScheduling domain types:\n\n- Internal `ScheduledAction` type (from Chunk 2):\n\n      type ScheduledAction struct {\n          EntryID  string\n          When     time.Time\n          Type     ScheduledActionType\n          RequestID string\n          SeqNo     int64\n          Token     string\n          // payloads...\n      }\n\n- `EventScheduler` interface (Chunk 3):\n\n      type EventScheduler interface {\n          Schedule(at time.Time, f func()) (id string)\n          Cancel(id string)\n          Now() time.Time\n      }\n\nSBI scheduling protos:\n\n- Generated under something like:\n\n      internal/genproto/scheduling/v1alpha\n\n- Look for:\n  - `FinalizeRequest` message.\n  - `ReceiveRequestsMessageFromController` one-of that carries it.\n\n## Tasks\n\n### 1. Add controller-side SendFinalize helper\n\nIn `CDPIServer` (controller):\n\n- Add or flesh out a method:\n\n      func (s *CDPIServer) SendFinalize(agentID string, cutoff time.Time) error\n\nImplementation outline:\n\n1. Look up the `AgentHandle`:\n\n       s.agentsMu.RLock()\n       handle, ok := s.agents[agentID]\n       s.agentsMu.RUnlock()\n       if !ok {\n           return fmt.Errorf(\"cdpi: agent %q not connected\", agentID)\n       }\n\n2. Build a `FinalizeRequest` proto:\n\n   - Use `cutoff` → `timestamppb.New(cutoff)` or equivalent.\n   - Attach `schedule_manipulation_token` from `handle.Token` if required by proto.\n   - Increment and assign `seqno` from `handle.SeqNo`.\n\n3. Wrap into `ReceiveRequestsMessageFromController`:\n\n       msg := &scheduling.ReceiveRequestsMessageFromController{\n           // set appropriate one-of field for FinalizeRequest\n       }\n\n4. Push message onto `handle.Outgoing` (non-blocking or bounded-blocking):\n\n       select {\n       case handle.Outgoing <- msg:\n           return nil\n       default:\n           // Option: log and return an error if channel is full\n           return fmt.Errorf(\"cdpi: outgoing channel full for agent %q\", agentID)\n       }\n\n5. Ensure you **do not** block indefinitely.\n\nAlso:\n\n- Add basic logging (optional but nice):\n\n  - Agent ID, cutoff time, seqno.\n\n### 2. Handle FinalizeRequest in Agent stream reader\n\nIn the agent’s CDPI stream loop:\n\n- You likely already have something like:\n\n      func (a *Agent) handleControllerMessage(msg *scheduling.ReceiveRequestsMessageFromController) {\n          switch m := msg.GetMessage().(type) {\n          case *scheduling.ReceiveRequestsMessageFromController_CreateEntry:\n              a.handleCreateEntry(m.CreateEntry)\n          case *scheduling.ReceiveRequestsMessageFromController_DeleteEntry:\n              a.handleDeleteEntry(m.DeleteEntry)\n          // TODO: FinalizeRequest\n          }\n      }\n\nExtend this to handle `FinalizeRequest`:\n\n- Add:\n\n      case *scheduling.ReceiveRequestsMessageFromController_Finalize:\n          a.handleFinalize(m.Finalize)\n\n### 3. Implement agent-side handleFinalize\n\nAdd a method on `Agent`:\n\n      func (a *Agent) handleFinalize(req *scheduling.FinalizeRequest) {\n          if req == nil {\n              return\n          }\n\n          cutoff := req.GetCutoffTime().AsTime() // adjust to actual field\n          a.mu.Lock()\n          defer a.mu.Unlock()\n\n          for entryID, action := range a.pending {\n              if action.When.Before(cutoff) {\n                  // Cancel any scheduled event.\n                  if action.cancelID != \"\" { // depending on how you track scheduled IDs\n                      a.Scheduler.Cancel(action.cancelID)\n                  }\n                  delete(a.pending, entryID)\n              }\n          }\n\n          // No Response is necessary purely for Finalize, unless you want acks.\n      }\n\nDesign notes:\n\n- How do you cancel scheduled events?\n  - If not yet done, you may need `cancelID` on `ScheduledAction`:\n\n        type ScheduledAction struct {\n            EntryID  string\n            When     time.Time\n            // ...\n            CancelID string // scheduler event ID\n        }\n\n  - When scheduling:\n    - `id := a.Scheduler.Schedule(action.When, func() { a.execute(action) })`\n    - Store `action.CancelID = id`.\n- If you don’t have `Cancel` wired yet:\n  - Add it as part of this issue (it’s required for DeleteEntry too).\n\n### 4. Unit tests – Agent Finalize pruning\n\nAdd tests in something like `internal/sbi/agent/agent_finalize_test.go` or extend existing agent tests.\n\nUse:\n\n- A `FakeEventScheduler`:\n  - Records scheduled events and allows `Cancel(id string)` to mark them cancelled.\n- A simple `Agent` with:\n  - In-memory `pending` map.\n  - Attached fake scheduler.\n\nTest case 1: prune past entries, keep future ones\n\n- Setup:\n\n  - `now := time.Unix(1000, 0)`.\n  - Internal `ScheduledAction`s:\n    - `entry1` at `now.Add(-10 * time.Second)` (in the past).\n    - `entry2` at `now.Add(10 * time.Second)` (future).\n  - Both scheduled with fake scheduler, `CancelID` stored.\n\n- Cutoff:\n\n  - `cutoff := now`.\n\n- Build `FinalizeRequest` with `cutoff_time = cutoff`.\n\n- Call `agent.handleFinalize(req)`.\n\n- Assert:\n\n  - `entry1` removed from `pending`.\n  - `entry2` still present.\n  - Fake scheduler’s `Cancel` was called for `entry1`’s event ID only.\n\nTest case 2: cutoff before all entries → no pruning\n\n- All actions scheduled **after** cutoff.\n- After `handleFinalize`, all remain in `pending`.\n- No `Cancel` calls recorded.\n\nTest case 3: cutoff after all entries → all pruned\n\n- All actions scheduled **before** cutoff.\n- After `handleFinalize`, `pending` is empty.\n- `Cancel` called for each scheduled event.\n\n### 5. Unit tests – CDPIServer SendFinalize\n\nIn `internal/sbi/controller/cdpi_server_test.go`:\n\n- Use a fake `AgentHandle` with in-memory `Outgoing` channel (buffered).\n- Register it into `CDPIServer.agents`.\n\nTest case: successfully queue FinalizeRequest\n\n- Setup:\n\n  - `agentID := \"agent-1\"`.\n  - `handle := &AgentHandle{AgentID: agentID, Outgoing: make(chan *scheduling.ReceiveRequestsMessageFromController, 1)}`.\n  - Add handle to `s.agents`.\n\n- Call:\n\n      err := s.SendFinalize(agentID, cutoffTime)\n\n- Assert:\n\n  - `err == nil`.\n  - Exactly one message is enqueued on `Outgoing`.\n  - The message’s one-of is `Finalize`:\n    - `msg.GetFinalize()` (or corresponding accessor) is non-nil.\n  - `FinalizeRequest.cutoff_time` equals the requested cutoff.\n  - Token and seqno fields are set as expected (if you populate them here).\n\nTest case: unknown agent returns error\n\n- Call `SendFinalize(\"missing-agent\", cutoff)`.\n- Assert:\n  - Non-nil error.\n  - Outgoing channel remains unchanged.\n\n### 6. Optional: hook into higher-level scheduler (if trivial)\n\nIf you already have a higher-level controller `Scheduler` (Chunk 8) that:\n\n- Plans scheduled actions over some horizon.\n\nConsider adding a minimal hook (optional in this issue):\n\n- A method that, after planning actions up to `T_end`, calls:\n\n      cdpi.SendFinalize(agentID, T_end)\n\nfor each agent.\n\nThis can be deferred to a later Chunk 8 issue if it complicates the wiring.\n\n## Acceptance criteria\n\n- Controller-side CDPI:\n\n  - `CDPIServer` exposes:\n\n        func (s *CDPIServer) SendFinalize(agentID string, cutoff time.Time) error\n\n  - The method:\n    - Looks up the target `AgentHandle` safely under `agentsMu`.\n    - Builds a `FinalizeRequest` proto with `cutoff_time = cutoff`.\n    - Wraps it in `ReceiveRequestsMessageFromController`.\n    - Enqueues it on the agent’s `Outgoing` channel.\n    - Returns a clear error for unknown agents or a full channel.\n\n- Agent-side handling:\n\n  - Agent’s receive loop dispatches `FinalizeRequest` messages to:\n\n        handleFinalize(req *scheduling.FinalizeRequest)\n\n  - `handleFinalize`:\n    - Parses `cutoff_time` into `time.Time`.\n    - Iterates over `pending` scheduled actions under `mu`.\n    - Cancels and removes actions with `When < cutoff_time`.\n    - Leaves actions with `When >= cutoff_time` untouched.\n\n- Cancellation behaviour:\n\n  - Each `ScheduledAction` has a way to reference its scheduled event in `EventScheduler` (e.g. `CancelID`).\n  - `EventScheduler.Cancel(id)` is called for any pruned action.\n\n- Tests:\n\n  - Agent tests:\n    - Prune-only-past, prune-none, prune-all scenarios covered.\n    - Confirm `Cancel` called only for pruned entries.\n  - CDPIServer tests:\n    - `SendFinalize` enqueues a well-formed message.\n    - Unknown agent ID returns an error and no send occurs.\n\n- Repository health:\n\n  - `go build ./...` passes with new Finalize semantics.\n  - `go test ./...` passes, including the new tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/156/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/156/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/157",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/157/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/157/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/157/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/157",
    "id": 3711831927,
    "node_id": "I_kwDOQfMfks7dPg93",
    "number": 157,
    "title": "[Scope 4][Chunk 7] Stub SetSrPolicy/DeleteSrPolicy handling in controller and agents",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139252,
        "node_id": "LA_kwDOQfMfks8AAAACRw-ZdA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:7-sbi-protocol-completeness",
        "name": "chunk:7-sbi-protocol-completeness",
        "color": "1cbd8b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T17:01:38Z",
    "updated_at": "2025-12-09T17:01:38Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nChunk 7 is about **SBI protocol completeness** for CDPI so that our behavior matches the Requirements/Roadmap expectations, without adding Scope 5–style optimization logic.\n\nBy this point in Chunk 7 you should already have:\n\n- CDPI stream skeleton implemented:\n  - Controller-side `CDPIServer` with:\n    - `ReceiveRequests` streaming RPC.\n    - Per-agent `AgentHandle` tracking streams, tokens, and outgoing messages.\n  - Agent-side model with:\n    - Local schedule queue for CreateEntry/DeleteEntry.\n    - Execution of scheduled actions against `ScenarioState`.\n\n- Protocol semantics partially covered:\n  - **Reset RPC**:\n    - Agent can send `Reset` to controller.\n    - Controller clears per-agent state and issues a fresh `schedule_manipulation_token`.\n  - **schedule_manipulation_token & seqno**:\n    - Controller maintains a token and per-agent seqno.\n    - Agent validates token and at least logs mismatches.\n  - **FinalizeRequest**:\n    - Controller can send `FinalizeRequest` with a cutoff time.\n    - Agent drops scheduled entries with `When < cutoff`.\n\nThe original Scope 4 plan also called for **SetSrPolicy/DeleteSrPolicy support**, but only as **stubs**:\n\n- The system should:\n  - Accept `SetSrPolicy` / `DeleteSrPolicy` messages on the CDPI stream.\n  - Parse/store minimal info about SR policies.\n  - Not yet affect forwarding or connectivity behavior.\n  - Provide enough structure to hook real SR-TE logic in later scopes.\n\nThis issue wires in that **stub behavior** so the SBI protocol surface is complete, while keeping routing behavior unchanged.\n\n## Goal\n\nProvide minimal, well-structured handling of `SetSrPolicy` and `DeleteSrPolicy` in both controller and agent:\n\n- Define an internal `SrPolicySpec` representation capturing the essentials from the SBI proto.\n- Extend controller-side CDPI handling to:\n  - Accept and parse `SetSrPolicy` / `DeleteSrPolicy` messages.\n  - Optionally track policies per agent/node (in a simple in-memory map).\n  - Log events for observability.\n- Extend agent-side handling to:\n  - Receive controller → agent scheduling messages containing SR-policy operations.\n  - Convert to `SrPolicySpec` and store them locally.\n  - Keep behavior **read-only/stubbed**:\n    - No route-table changes.\n    - No data-plane behavior changes.\n- Add unit tests that:\n  - Exercise the encode–decode path for `SetSrPolicy` / `DeleteSrPolicy`.\n  - Verify storage, logging, and no crashes.\n- Keep everything deliberately minimal and **mechanism-only**, ready for future Scope 5/6 work.\n\n## Where to look\n\nCDPI protos and generated stubs:\n\n- SBI scheduling protos under something like:\n  - `internal/genproto/scheduling/v1alpha`\n- Look for:\n  - `SetSrPolicyRequest`, `DeleteSrPolicyRequest`\n  - Any `SrPolicy` / `TrafficEngineeringPolicy` messages (names depend on the exact proto).\n  - Fields representing:\n    - Policy ID / name.\n    - Source / destination.\n    - Path type (candidate path, SID list, etc.).\n    - Priority / preference.\n\nController-side CDPI implementation:\n\n- `internal/sbi/controller` (or similar):\n  - `cdpi_server.go` or equivalent file defining `CDPIServer`:\n    - `ReceiveRequests` streaming RPC implementation.\n    - `AgentHandle` struct and outgoing channel.\n    - Existing handling for:\n      - `Reset`\n      - `CreateEntryRequest`\n      - `DeleteEntryRequest`\n      - `FinalizeRequest`\n\nAgent-side CDPI / scheduling:\n\n- `internal/sbi/agent`:\n  - `Agent` struct:\n    - Existing fields for:\n      - `AgentID`, `NodeID`\n      - `State *simstate.ScenarioState`\n      - `Scheduler EventScheduler`\n      - `Stream scheduling.ControlDataPlaneInterface_ReceiveRequestsClient`\n      - Local `pending` map, token, etc.\n  - Stream read loop that already switches on:\n    - `CreateEntryRequest`\n    - `DeleteEntryRequest`\n    - `FinalizeRequest`\n    - `Reset` (agent → controller side)\n\nSearch terms:\n\n- `SetSrPolicy`\n- `DeleteSrPolicy`\n- `SrPolicy`\n- `ControlDataPlaneInterface`\n- `ReceiveRequestsMessageFromController`\n- `ReceiveRequestsMessageFromAgent`\n\n## Tasks\n\n### 1. Define SrPolicySpec internal model\n\nIntroduce a minimal internal representation of an SR policy in a shared SBI domain package (e.g. `internal/sbi` or `internal/sbi/types`):\n\n- Add:\n\n      type SrPolicySpec struct {\n          PolicyID   string   // unique identifier from proto\n          SrcNodeID  string   // optional; depends on proto\n          DstNodeID  string   // optional; depends on proto\n          SidList    []string // ordered list of SIDs / labels\n          Priority   int32    // preference / priority if present\n          // Optional: additional metadata if cheaply available.\n      }\n\nDesign notes:\n\n- Focus on fields you know you will need later (ID, src/dst, SID list, priority).\n- Keep it **safe to extend** as SR-TE work arrives (add fields, not change semantics).\n- This type lives in a neutral place, usable by both:\n  - Controller scheduler.\n  - Agents.\n\n### 2. Add SrPolicy storage on Agent and/or ScenarioState\n\nThe simplest Scope 4 stub behavior is to store SR policies on the **Agent**, keyed by policy ID:\n\n- Extend `Agent` struct with:\n\n      type Agent struct {\n          // existing fields...\n\n          srPolicyMu sync.RWMutex\n          srPolicies map[string]*SrPolicySpec\n      }\n\nNotes:\n\n- `srPolicies` should be lazily initialized on first use.\n- For now, you can keep policies entirely local to the agent; no need to push into `ScenarioState` unless you want to inspect them elsewhere for debugging.\n\nAlternatively (optional):\n\n- Add a `SetSrPolicy` / `DeleteSrPolicy` helper on `ScenarioState` that:\n  - Stores policies by `NodeID` and `PolicyID`.\n  - Is concurrency-safe.\n- If you do this, update the Agent to call `ScenarioState.SetSrPolicy` instead of keeping local-only state.\n\n### 3. Controller-side handling of SetSrPolicy/DeleteSrPolicy\n\nIn the CDPI server (`CDPIServer.ReceiveRequests`):\n\n- Identify the proto messages representing SR-policy operations in:\n  - `ReceiveRequestsMessageFromAgent`\n  - `ReceiveRequestsMessageFromController`\n\nDepending on the proto shape, controller will normally:\n\n- Receive **agent → controller** messages about SR-policy status (less important for Scope 4).\n- Send **controller → agent** `SetSrPolicyRequest` / `DeleteSrPolicyRequest`.\n\nFor this issue, implement at least:\n\n- A controller method (for future scheduler use):\n\n      func (s *CDPIServer) SendSetSrPolicy(agentID string, spec *SrPolicySpec) error\n\n- Behavior:\n\n  - Look up `AgentHandle` for `agentID`.\n  - Map `SrPolicySpec` → SBI proto `SetSrPolicyRequest`:\n    - Fill `policy_id`, `src/dst node fields`, SID list, and priority as defined in the proto.\n  - Wrap in `ReceiveRequestsMessageFromController` and send on the agent’s `outgoing` channel.\n  - Set `schedule_manipulation_token` and `seqno` appropriately (re-using existing helpers).\n  - Log at INFO/DEBUG level:\n    - Agent ID, `PolicyID`, SID list length, etc.\n\n- Similarly, add:\n\n      func (s *CDPIServer) SendDeleteSrPolicy(agentID, policyID string) error\n\n  - Build `DeleteSrPolicyRequest` proto from `policyID`.\n  - Wrap and send via `AgentHandle.outgoing`.\n  - Log the event.\n\nNotes:\n\n- This issue does **not** require any scheduler to actually call these methods yet.\n- Focus on plumbing and correctness of message construction and logging.\n\n### 4. Agent-side handling of SetSrPolicy/DeleteSrPolicy\n\nIn the Agent stream read loop:\n\n- Extend the switch that dispatches controller → agent messages to handle SR-policy requests.\n\nPseudo-logic:\n\n- On receiving `SetSrPolicyRequest`:\n\n  - Convert proto → `SrPolicySpec`:\n\n        func srPolicyFromProto(p *scheduling.SrPolicy) *SrPolicySpec {\n            // map fields carefully, handling nils and defaults\n        }\n\n  - Acquire `srPolicyMu` and insert/update:\n\n        a.srPolicyMu.Lock()\n        if a.srPolicies == nil {\n            a.srPolicies = make(map[string]*SrPolicySpec)\n        }\n        a.srPolicies[spec.PolicyID] = spec\n        a.srPolicyMu.Unlock()\n\n  - Optionally:\n    - Also store on `ScenarioState` if you introduced KB helpers.\n  - Log:\n\n    - Agent ID, `PolicyID`, SID count, src/dst.\n\n- On receiving `DeleteSrPolicyRequest`:\n\n  - Acquire `srPolicyMu` and delete from `srPolicies` by `policyID`.\n  - Optionally remove from `ScenarioState` if you integrated it there.\n  - Log that the SR policy was removed (or missing).\n\nBehavior constraints for Scope 4:\n\n- Do **not**:\n\n  - Change route tables based on these policies.\n  - Change any connectivity / link-state behavior.\n\n- SR-policy state should be **passively stored only**.\n\n### 5. Simple inspection helper (optional but useful)\n\nAdd a method on Agent (or a debug helper) to inspect current SR policies, to aid debugging and tests:\n\n- For example:\n\n      func (a *Agent) ListSrPolicies() []*SrPolicySpec {\n          a.srPolicyMu.RLock()\n          defer a.srPolicyMu.RUnlock()\n\n          out := make([]*SrPolicySpec, 0, len(a.srPolicies))\n          for _, p := range a.srPolicies {\n              // return copies if you want immutability\n              out = append(out, p)\n          }\n          return out\n      }\n\nThis is particularly helpful for unit tests and any future `DumpAgentState`–style debug output.\n\n### 6. Unit tests for SR-policy stubs\n\nCreate a dedicated test file, e.g.:\n\n- `internal/sbi/agent/agent_srpolicy_test.go`\n- `internal/sbi/controller/cdpi_srpolicy_test.go`\n\nTest scenarios:\n\n1. Agent stores SetSrPolicy requests\n\n   - Setup:\n     - Agent with in-memory stream / fake scheduler.\n     - Inject a `ReceiveRequestsMessageFromController` containing a `SetSrPolicyRequest` for:\n       - `PolicyID = \"srp-1\"`\n       - SID list `[\"sid-a\", \"sid-b\"]`.\n   - Act:\n     - Run the message handler.\n   - Assert:\n     - `agent.srPolicies[\"srp-1\"]` exists.\n     - Fields (`PolicyID`, `SidList`, etc.) match expectations.\n\n2. Agent removes policies on DeleteSrPolicy\n\n   - Pre-populate `agent.srPolicies[\"srp-1\"]`.\n   - Deliver a `DeleteSrPolicyRequest` for `\"srp-1\"`.\n   - Assert:\n     - `srp-1` is no longer present.\n     - No panic if policy was already missing (idempotent behavior is acceptable).\n\n3. Controller encodes SetSrPolicy to outgoing channel\n\n   - Use a fake `AgentHandle` with:\n     - `outgoing` channel buffered by 1.\n   - Call `CDPIServer.SendSetSrPolicy(\"agent-1\", spec)`.\n   - Assert:\n     - One message was sent on `outgoing`.\n     - It contains a `SetSrPolicyRequest` with:\n       - Expected policy ID.\n       - SID list length matches `spec.SidList`.\n       - Token/seqno fields are set and non-zero (if your token/seqno logic enforces that).\n\n4. Controller encodes DeleteSrPolicy to outgoing channel\n\n   - Similar to above, but for `SendDeleteSrPolicy`.\n   - Assert the `DeleteSrPolicyRequest` has the correct `policy_id`.\n\n5. No behavior changes on KB / routes\n\n   - If you wire policies into `ScenarioState`, ensure the tests confirm:\n     - Calling `SetSrPolicy` / `DeleteSrPolicy` does **not** modify:\n       - Route tables.\n       - Link state.\n   - This can be as simple as:\n     - Capture initial `Routes` and link flags.\n     - Run SR-policy operations.\n     - Assert state unchanged.\n\n## Acceptance criteria\n\n- Internal model:\n\n  - `SrPolicySpec` type exists and captures:\n    - Policy ID.\n    - Optional src/dst node IDs.\n    - SID list.\n    - Priority (if present in proto).\n  - Located in a shared SBI domain package usable by both controller and agents.\n\n- Agent-side behavior:\n\n  - `Agent` struct extended with:\n    - `srPolicyMu sync.RWMutex`\n    - `srPolicies map[string]*SrPolicySpec`\n  - Stream read loop:\n    - Handles `SetSrPolicy` messages:\n      - Converts proto → `SrPolicySpec`.\n      - Stores/updates in `srPolicies`.\n      - Logs the event.\n    - Handles `DeleteSrPolicy` messages:\n      - Removes the policy by ID (if present).\n      - Logs the event.\n  - No changes to:\n    - Route tables.\n    - Connectivity / link state.\n    - Telemetry behavior.\n\n- Controller-side behavior:\n\n  - `CDPIServer` exposes:\n    - `SendSetSrPolicy(agentID string, spec *SrPolicySpec) error`\n    - `SendDeleteSrPolicy(agentID, policyID string) error`\n  - Both methods:\n    - Lookup `AgentHandle` safely.\n    - Encode SR-policy requests into SBI protos.\n    - Set `schedule_manipulation_token` and `seqno` using existing helpers.\n    - Push messages onto the agent’s `outgoing` channel.\n    - Log success/failure.\n\n- Tests:\n\n  - Agent tests:\n    - Confirm that `SetSrPolicy` messages populate `srPolicies`.\n    - Confirm that `DeleteSrPolicy` removes entries.\n    - Confirm no panics or unexpected behavior on missing policies.\n  - Controller tests:\n    - Confirm `SendSetSrPolicy` and `SendDeleteSrPolicy` enqueue the right proto messages.\n    - Confirm token/seqno fields are set (according to your existing semantics).\n  - Optional integration-style test:\n    - Use an in-memory CDPI server + test agent to verify a full round trip for `SetSrPolicy` / `DeleteSrPolicy` is accepted and stored.\n\n- Repository health:\n\n  - `go build ./...` passes with the new SR-policy types and handlers.\n  - `go test ./...` passes, including new SR-policy stub tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/157/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/157/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/158",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/158/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/158/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/158/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/158",
    "id": 3711861497,
    "node_id": "I_kwDOQfMfks7dPoL5",
    "number": 158,
    "title": "[Scope 4][Chunk 7] Implement SetSrPolicy/DeleteSrPolicy stubs in CDPI and Agent",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139252,
        "node_id": "LA_kwDOQfMfks8AAAACRw-ZdA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:7-sbi-protocol-completeness",
        "name": "chunk:7-sbi-protocol-completeness",
        "color": "1cbd8b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T17:09:26Z",
    "updated_at": "2025-12-09T17:09:26Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/152",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nIn **Scope 4 / Chunk 7**, you’ve already covered most of the SBI protocol semantics:\n\n- **Reset RPC semantics**:\n  - Agent issues `Reset(agent_id)` to controller.\n  - Controller clears any server-side pending state and rotates the schedule token.\n  - Agent clears its local schedule and pending actions.\n\n- **`schedule_manipulation_token` & `seqno`**:\n  - Controller:\n    - Attaches the current token to each `CreateEntryRequest` / `DeleteEntryRequest`.\n    - Maintains a monotonically increasing `seqno` per agent.\n  - Agent:\n    - Verifies token; logs/ignores mismatches.\n    - Uses `seqno` only for logging/debugging.\n\n- **Finalize semantics**:\n  - Controller can send `FinalizeRequest(cutoff_time)`.\n  - Agent drops any scheduled entries with `When < cutoff_time`, retaining future entries.\n\nWhat’s **missing** from Chunk 7 is handling of **SrPolicy** messages in CDPI:\n\n- `SetSrPolicy` and `DeleteSrPolicy` requests from controller to agent.\n- For **Scope 4**, these are **explicitly stubbed**:\n  - They must be **accepted**, decoded, and tracked.\n  - They must **not** yet affect actual forwarding, route tables, or scheduling outcomes.\n  - They should be logged and stored in a way that later scopes (Scope 5+) can use.\n\nRequirements / implementation plan text for Chunk 7 says:\n\n- Controller may send `SetSrPolicy` / `DeleteSrPolicy` as part of SBI protocol.\n- Agent should:\n  - Parse them.\n  - Store them in a local structure (e.g. `[]SrPolicySpec` or map keyed by policy ID).\n  - Not change behavior yet, but make it clear in logs that they are **not active**.\n\nThis issue fills that gap by implementing **stub semantics** for SR policy messages on both controller and agent.\n\n## Goal\n\n- Add a minimal internal representation of **SR policies** (`SrPolicySpec` or similar).\n- Extend **Agent** and, if appropriate, **ScenarioState** / controller structures to:\n  - Store a set of known SR policies per agent / per node.\n  - Add helper methods to add/remove SR policies by ID.\n- On the **agent side**:\n  - Handle `SetSrPolicy` and `DeleteSrPolicy` messages received on the CDPI stream.\n  - Parse proto → internal `SrPolicySpec`.\n  - Store/remove policies in a local map or slice.\n  - Log actions clearly, including that policies are **currently not applied to forwarding**.\n- On the **controller side**:\n  - Ensure there are convenience methods to send `SetSrPolicy` / `DeleteSrPolicy` via `CDPIServer` (simple wrappers over outgoing CDPI stream).\n- Add **unit tests** that prove:\n  - `SetSrPolicy` populates local SR policy store.\n  - `DeleteSrPolicy` removes policies.\n  - Reset clears SR policies as well.\n  - No route/beam changes happen as a side-effect (i.e. this is truly a stub).\n\n## Where to look\n\n- **CDPI controller implementation** (Chunk 5):\n\n  - Something like:\n    - `internal/sbi/controller/cdpi_server.go`\n  - Types:\n    - `CDPIServer`\n    - `AgentHandle`\n  - Methods:\n    - `ReceiveRequests(...)`\n    - `SendCreateEntry(...)`\n    - `SendDeleteEntry(...)`\n    - `SendFinalize(...)`\n\n- **Agent implementation** (Chunk 4 and 7 issues):\n\n  - Likely under:\n    - `internal/sbi/agent/agent.go`\n  - Existing fields (approx):\n\n        type Agent struct {\n            AgentID   string\n            NodeID    string\n            State     *simstate.ScenarioState\n            Scheduler sbi.EventScheduler\n\n            // CDPI stream, telemetry, tokens, etc.\n            token   string\n            pending map[string]*ScheduledAction\n\n            // Telemetry fields from Chunk 6\n            // ...\n        }\n\n  - Stream handling:\n    - Read loop over `ControlDataPlaneInterface.ReceiveRequestsClient` or server-side stream.\n    - Already handles:\n      - `CreateEntryRequest`\n      - `DeleteEntryRequest`\n      - `FinalizeRequest`\n      - `Reset` (agent side RPC)\n    - Now needs to add:\n      - `SetSrPolicyRequest`\n      - `DeleteSrPolicyRequest`\n\n- **SBI scheduling protos**:\n\n  - Generated under something like:\n    - `internal/genproto/scheduling/v1alpha`\n  - Look for:\n    - `SetSrPolicyRequest`\n    - `DeleteSrPolicyRequest`\n    - `SrPolicy` / `SrPolicySpec` / similar policy types.\n\n- **Existing Chunk 7 issues** (for reference / consistency):\n\n  - Reset semantics issue.\n  - Token/seqno semantics issue.\n  - Finalize semantics issue.\n\n## Tasks\n\n### 1. Define internal SrPolicySpec model\n\nAdd a small internal struct to represent an SR policy. Put this either in:\n\n- `internal/sbi` (shared SBI domain types), or\n- `internal/sbi/agent` (if you want it agent-local for now), or\n- `internal/sim/state` / `sim/state` (if you plan to eventually persist to ScenarioState).\n\nA minimal example:\n\n- File (example): `internal/sbi/srpolicy.go`\n\n      type SrPolicySpec struct {\n          PolicyID     string   // stable identifier from proto\n          SrcNodeID    string   // optional – where policy originates\n          DstNodeID    string   // optional – target node / endpoint\n          CandidateIDs []string // candidate path identifiers, if needed\n\n          // Optional: raw proto for debugging / future use.\n          RawProto interface{}\n      }\n\nDesign notes:\n\n- For Scope 4, you do **not** need a full SR policy model.\n- Keep it intentionally minimal:\n  - Policy ID.\n  - References to nodes and candidate path IDs.\n  - An optional `RawProto` or `[]byte` if you want a “just store whatever” approach.\n\n### 2. Extend Agent to store SR policies\n\nIn the `Agent` struct, add a simple store for policies:\n\n- Add fields (e.g. in `internal/sbi/agent/agent.go`):\n\n      type Agent struct {\n          // existing fields...\n\n          srPolicyMu sync.Mutex\n          srPolicies map[string]*SrPolicySpec // keyed by PolicyID\n      }\n\nNotes:\n\n- Initialize `srPolicies` on agent construction or lazily when first used.\n- Protect access with `srPolicyMu` to keep concurrency simple.\n\nAdd helper methods on `Agent`:\n\n- `addOrUpdateSrPolicyFromProto(p *scheduling.SetSrPolicyRequest) error`\n- `deleteSrPolicyFromProto(p *scheduling.DeleteSrPolicyRequest) error`\n- Or generic:\n\n      func (a *Agent) addOrUpdateSrPolicy(spec *SrPolicySpec)\n      func (a *Agent) deleteSrPolicy(policyID string)\n      func (a *Agent) listSrPolicies() []*SrPolicySpec // useful for debug/observability\n\nImplementation sketch:\n\n- `addOrUpdateSrPolicy(spec *SrPolicySpec)`:\n\n      func (a *Agent) addOrUpdateSrPolicy(spec *SrPolicySpec) {\n          if spec == nil || spec.PolicyID == \"\" {\n              return\n          }\n          a.srPolicyMu.Lock()\n          defer a.srPolicyMu.Unlock()\n          if a.srPolicies == nil {\n              a.srPolicies = make(map[string]*SrPolicySpec)\n          }\n          a.srPolicies[spec.PolicyID] = spec\n      }\n\n- `deleteSrPolicy(policyID string)`:\n\n      func (a *Agent) deleteSrPolicy(policyID string) {\n          if policyID == \"\" {\n              return\n          }\n          a.srPolicyMu.Lock()\n          defer a.srPolicyMu.Unlock()\n          if a.srPolicies == nil {\n              return\n          }\n          delete(a.srPolicies, policyID)\n      }\n\nNo changes to `ScenarioState` are required yet (pure stubs).\n\n### 3. Parse SetSrPolicy / DeleteSrPolicy in Agent CDPI loop\n\nFind the agent CDPI stream read loop (something like):\n\n- In `agent.Start` or a helper:\n\n      for {\n          msg, err := stream.Recv()\n          if err != nil {\n              // handle EOF / errors\n              break\n          }\n\n          switch x := msg.Message.(type) {\n          case *scheduling.ReceiveRequestsMessageFromController_CreateEntry:\n              // existing CreateEntry handling\n          case *scheduling.ReceiveRequestsMessageFromController_DeleteEntry:\n              // existing DeleteEntry handling\n          case *scheduling.ReceiveRequestsMessageFromController_Finalize:\n              // existing Finalize handling\n          // add new cases here\n          }\n      }\n\nAdd cases for SR policy messages, based on the concrete proto types:\n\n- Example (names may differ depending on actual generated code):\n\n      case *scheduling.ReceiveRequestsMessageFromController_SetSrPolicy:\n          a.handleSetSrPolicy(x.SetSrPolicy)\n\n      case *scheduling.ReceiveRequestsMessageFromController_DeleteSrPolicy:\n          a.handleDeleteSrPolicy(x.DeleteSrPolicy)\n\nThen implement handlers:\n\n- `handleSetSrPolicy`:\n\n      func (a *Agent) handleSetSrPolicy(req *scheduling.SetSrPolicyRequest) {\n          if req == nil || req.Policy == nil {\n              // optionally log and return\n              return\n          }\n\n          // Map proto → SrPolicySpec (minimal).\n          spec := &SrPolicySpec{\n              PolicyID:  req.Policy.GetPolicyId(), // adjust to real field name\n              SrcNodeID: req.Policy.GetSrcNodeId(), // optional\n              DstNodeID: req.Policy.GetDstNodeId(), // optional\n              // CandidateIDs, RawProto, etc.\n          }\n\n          a.addOrUpdateSrPolicy(spec)\n\n          if a.Logger != nil {\n              a.Logger.Info(\"agent: SetSrPolicy stub stored\",\n                  \"agent_id\", a.AgentID,\n                  \"policy_id\", spec.PolicyID)\n          }\n\n          // IMPORTANT: no change to routes / beams yet (Scope 4 stub).\n      }\n\n- `handleDeleteSrPolicy`:\n\n      func (a *Agent) handleDeleteSrPolicy(req *scheduling.DeleteSrPolicyRequest) {\n          if req == nil {\n              return\n          }\n          policyID := req.GetPolicyId() // adjust to actual field\n          if policyID == \"\" {\n              return\n          }\n\n          a.deleteSrPolicy(policyID)\n\n          if a.Logger != nil {\n              a.Logger.Info(\"agent: DeleteSrPolicy stub removed policy\",\n                  \"agent_id\", a.AgentID,\n                  \"policy_id\", policyID)\n          }\n      }\n\nDesign notes:\n\n- Do **not** trigger `ScenarioState` changes in these handlers.\n- For Scope 4, they are purely a “registry” of known SR policies on the agent.\n\n### 4. Wire SR policies into Reset behavior (agent side)\n\nWhen the agent performs a **Reset** (either because it called `Reset()` to the controller or received a reset-style instruction), it should also clear SR policies:\n\n- In your `Agent.Reset` or equivalent:\n\n      func (a *Agent) resetStateAfterResetRPC() {\n          // existing: clear pending schedule, token, etc.\n\n          // Clear SR policies as well\n          a.srPolicyMu.Lock()\n          a.srPolicies = make(map[string]*SrPolicySpec)\n          a.srPolicyMu.Unlock()\n      }\n\nThis keeps behavior consistent: a fresh Reset means a clean SR policy slate.\n\n### 5. Controller helpers to send SetSrPolicy / DeleteSrPolicy\n\nOn the controller side (`CDPIServer`), add small helper methods similar to `SendCreateEntry`:\n\n- In `internal/sbi/controller/cdpi_server.go`:\n\n      func (s *CDPIServer) SendSetSrPolicy(agentID string, policyProto *scheduling.SrPolicy) error {\n          // Look up AgentHandle, build ReceiveRequestsMessageFromController with SetSrPolicy,\n          // attach current token/seqno if the proto requires it, send on outgoing chan.\n      }\n\n      func (s *CDPIServer) SendDeleteSrPolicy(agentID, policyID string) error {\n          // Build DeleteSrPolicyRequest, wrap in message-from-controller, send.\n      }\n\nImplementation details:\n\n- Look up the `AgentHandle` in `s.agents`.\n- Build the correct `ReceiveRequestsMessageFromController` union type.\n- Push onto `handle.outgoing` channel.\n- For Scope 4, these helpers may only be used in tests or simple experiments; that’s fine.\n\n### 6. Unit tests\n\nAdd tests to cover behavior.\n\n#### 6.1 Agent SR policy handling tests\n\nNew file (or extend existing):\n\n- `internal/sbi/agent/agent_srpolicy_test.go`\n\nTest scenarios:\n\n1. **SetSrPolicy stores policy**\n\n   - Create an `Agent` with empty `srPolicies`.\n   - Build a `SetSrPolicyRequest` proto with:\n     - A `Policy` containing `policy_id = \"p1\"`, `src_node_id`, `dst_node_id`.\n   - Call `agent.handleSetSrPolicy(req)`.\n   - Assert:\n     - `agent.srPolicies[\"p1\"]` exists.\n     - Fields are mapped as expected.\n\n2. **DeleteSrPolicy removes policy**\n\n   - Pre-populate `agent.srPolicies[\"p1\"]`.\n   - Build a `DeleteSrPolicyRequest` for `\"p1\"`.\n   - Call `agent.handleDeleteSrPolicy(req)`.\n   - Assert:\n     - `\"p1\"` is no longer in map.\n\n3. **Reset clears policies**\n\n   - Pre-populate `agent.srPolicies` with a couple of policies.\n   - Call `agent.resetStateAfterResetRPC()` (or the function you use on reset).\n   - Assert:\n     - `len(agent.srPolicies) == 0`.\n\n4. **No side-effects on ScenarioState**\n\n   - Setup a fake `ScenarioState` with methods that panic if called for SR policy changes.\n   - Call `handleSetSrPolicy` / `handleDeleteSrPolicy`.\n   - Assert:\n     - No `ScenarioState` methods are invoked.\n   - This ensures stub semantics (no accidental route/beam modifications).\n\n#### 6.2 Controller helper tests (optional but nice)\n\n- File: `internal/sbi/controller/cdpi_srpolicy_test.go`\n\nTests:\n\n- With a fake `AgentHandle` and outgoing channel:\n\n  - `SendSetSrPolicy`:\n    - Asserts a `ReceiveRequestsMessageFromController` arrives in the channel with:\n      - Correct `SetSrPolicy` payload.\n  - `SendDeleteSrPolicy`:\n    - Asserts a `ReceiveRequestsMessageFromController` arrives with `DeleteSrPolicy` payload.\n\nThese can be very small tests, mainly checking message wiring.\n\n## Acceptance criteria\n\n- **Internal SR Policy model**:\n\n  - A minimal `SrPolicySpec` (or similarly named struct) exists with:\n    - `PolicyID` plus a small set of useful fields (`SrcNodeID`, `DstNodeID`, candidate IDs, etc.).\n  - Its location is clearly documented (e.g. in a short comment) as temporary Scope 4 stub plumbing.\n\n- **Agent SR policy storage**:\n\n  - `Agent` struct includes:\n    - `srPolicies map[string]*SrPolicySpec`.\n    - `srPolicyMu sync.Mutex`.\n  - Helper methods exist to:\n    - Add/update a policy from proto.\n    - Delete a policy by ID.\n    - Clear policies on Reset.\n\n- **CDPI stream handling**:\n\n  - Agent CDPI loop handles:\n    - `SetSrPolicy` messages by:\n      - Parsing proto.\n      - Storing/updating `SrPolicySpec` in `srPolicies`.\n      - Logging the action.\n    - `DeleteSrPolicy` messages by:\n      - Removing the relevant entry from `srPolicies`.\n      - Logging the action.\n  - No actual change to routes/links/forwarding occurs as a result of these messages in Scope 4.\n\n- **Reset behavior**:\n\n  - Agent Reset clears:\n    - Local schedule (pending actions).\n    - `srPolicies` map (no stale policies remain).\n\n- **Controller helpers**:\n\n  - `CDPIServer` exposes helper methods:\n    - `SendSetSrPolicy(agentID string, policy *scheduling.SrPolicy) error`.\n    - `SendDeleteSrPolicy(agentID, policyID string) error`.\n  - These helpers correctly construct and enqueue the appropriate CDPI messages.\n\n- **Tests**:\n\n  - Agent tests cover:\n    - Storing SR policies via `SetSrPolicy`.\n    - Deleting SR policies via `DeleteSrPolicy`.\n    - Reset clearing SR policies.\n    - No `ScenarioState` mutations from SR policy handlers (stub semantics).\n  - Optional controller tests validate the outgoing message construction.\n  - All new tests pass via `go test ./...`.\n\n- **Repository health**:\n\n  - `go build ./...` passes with SR policy stubs in place.\n  - `go test ./...` passes, including new SR policy–related tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/158/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/158/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  }
]
