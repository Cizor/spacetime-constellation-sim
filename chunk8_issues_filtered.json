[
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/159",
    "id": 3711942964,
    "node_id": "I_kwDOQfMfks7dP8E0",
    "number": 159,
    "title": "[Scope 4][Chunk 8] Epic – Basic scheduling engine and controller logic",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9738572054,
        "node_id": "LA_kwDOQfMfks8AAAACRHbRFg",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:tracking",
        "name": "type:tracking",
        "color": "4eaa16",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139839,
        "node_id": "LA_kwDOQfMfks8AAAACRw-bvw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:8-sbi-controller-logic",
        "name": "chunk:8-sbi-controller-logic",
        "color": "de618e",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T17:28:39Z",
    "updated_at": "2025-12-09T17:28:45Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 2,
      "completed": 0,
      "percent_completed": 0
    },
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the time you reach **Chunk 8**, you have:\n\n- A working **CDPI server** (controller side) that:\n  - Accepts agent `Hello`, `Reset`, and `Response` messages.\n  - Can send `CreateEntryRequest`, `DeleteEntryRequest`, and `FinalizeRequest` to agents.\n- A **simulated Agent** per node that:\n  - Maintains a local schedule of `ScheduledAction`s.\n  - Executes beam and route actions at the right **simulation time** using `EventScheduler`.\n  - Updates `ScenarioState` via helpers like:\n    - `ApplyBeamUpdate(...)`\n    - `ApplyBeamDelete(...)`\n    - `InstallRoute(...)`\n    - `RemoveRoute(...)`\n- A **simulation clock + EventScheduler** abstraction that:\n  - Runs on sim time (Scope 1/2 time controller).\n  - Supports scheduling callbacks at a `time.Time`.\n- A **Telemetry path** (Chunk 6) that:\n  - Lets agents periodically push `InterfaceMetrics` via `TelemetryService.ExportMetrics`.\n  - Stores metrics in `TelemetryState` on the controller.\n\nWhat you **do not** have yet is the *controller-side scheduling engine* that:\n\n- Decides *what* to tell agents to do and *when*, based on:\n  - Link visibility / potential links from Scope 2.\n  - Static routing needs.\n  - (Optionally) `ServiceRequest`s from Scope 3.\n- Emits `ScheduledAction`s and converts them into CDPI `CreateEntryRequest`/`DeleteEntryRequest`.\n- Tracks enough context to later reason about schedule decisions.\n\nFor **Scope 4**, the goal is not optimization, but **mechanism**:\n\n- A simple, deterministic scheduling engine that:\n  - Uses existing connectivity information to schedule **beam on/off**.\n  - Installs and removes **static routes** for single-hop connectivity.\n  - Optionally reacts to `ServiceRequest`s in a minimal way.\n- This forms the backbone for more sophisticated scheduling in future scopes.\n\nThis epic covers that **basic scheduling engine** and its integration with CDPI and `ScenarioState`.\n\n---\n\n## Goal\n\nDeliver a first-cut **controller-side scheduling engine** that:\n\n- Knows how to:\n  - Inspect `ScenarioState` and link visibility / potential links.\n  - Plan simple `ScheduledAction`s over a simulation horizon:\n    - `UpdateBeam` / `DeleteBeam`.\n    - `SetRoute` / `DeleteRoute`.\n- Emits these actions through the existing CDPI server:\n  - Uses `SendCreateEntry` / `SendDeleteEntry` / `SendFinalize` helpers.\n  - Targets per-agent schedules (per-node).\n- Is **simple and deterministic**:\n  - No complex optimization or load-balancing.\n  - Single path, single-hop routing is enough.\n- Has unit tests to validate its behavior in isolation:\n  - Using fake `ScenarioState`, fake clock, and fake CDPI.\n\n---\n\n## Where to look\n\nCore state and connectivity:\n\n- `sim/state` or `internal/simstate`:\n  - `ScenarioState`:\n    - Nodes and interfaces.\n    - Links and their geometric / RF feasibility.\n    - Active vs potential links (from Scope 4 Chunk 0).\n  - Any helpers that surface:\n    - “Potential links” or “links in view”.\n    - Time-intervals for link visibility.\n\nSBI controller side:\n\n- `internal/sbi/controller`:\n  - CDPI server implementation (Chunk 5), e.g.:\n\n        type CDPIServer struct {\n            scheduling.UnimplementedControlDataPlaneInterfaceServer\n\n            State    *simstate.ScenarioState\n            Clock    sbi.EventScheduler\n            // agent handles, outgoing channels, etc.\n        }\n\n  - Methods to send scheduling commands:\n\n        func (s *CDPIServer) SendCreateEntry(agentID string, action *ScheduledAction) error\n        func (s *CDPIServer) SendDeleteEntry(agentID, entryID string) error\n        func (s *CDPIServer) SendFinalize(agentID string, cutoff time.Time) error\n\nScheduling domain model:\n\n- `internal/sbi` or equivalent, where you previously defined:\n\n      type ScheduledActionType int\n\n      const (\n          ScheduledUpdateBeam ScheduledActionType = iota\n          ScheduledDeleteBeam\n          ScheduledSetRoute\n          ScheduledDeleteRoute\n          ScheduledSetSrPolicy\n          ScheduledDeleteSrPolicy\n      )\n\n      type ScheduledAction struct {\n          EntryID   string\n          When      time.Time\n          Type      ScheduledActionType\n          RequestID string\n          SeqNo     int64\n          Token     string\n          Beam      *BeamSpec\n          Route     *RouteEntry\n          SrPolicy  *SrPolicySpec\n      }\n\nService requests (optional minimal integration):\n\n- NBI / core model for `ServiceRequest`:\n  - Source node ID, destination node ID.\n  - Possibly QoS hints (but can be ignored in Scope 4).\n- Any helper that enumerates active `ServiceRequest`s.\n\nSearch terms:\n\n- `ScenarioState`\n- `PotentialLink`, `LinkInView`, `LinkIntervals`\n- `CDPIServer`\n- `ScheduledAction`\n- `ServiceRequest`\n\n---\n\n## Tasks\n\n### 8.1 – Introduce Scheduler component\n\nCreate a controller-side scheduler struct under `internal/sbi/controller`, for example:\n\n- File:\n\n      internal/sbi/controller/scheduler.go\n\n- Type:\n\n      type Scheduler struct {\n          State *simstate.ScenarioState\n          Clock sbi.EventScheduler\n          CDPI  *CDPIServer\n\n          // Optional:\n          Horizon         time.Duration   // how far ahead to schedule\n          BeamLeadTime    time.Duration   // how early to turn beams on\n          Logger          Logger          // optional logging interface\n      }\n\nKey responsibilities:\n\n- Periodically or on-demand:\n  - Inspect `ScenarioState` for potential links.\n  - Decide when to schedule **beam on/off** and **static routes**.\n  - Call `CDPIServer.SendCreateEntry(...)` / `SendDeleteEntry(...)` to push entries to agents.\n\nMethods (initial sketch):\n\n- A main entry point for one-shot scheduling:\n\n      func (s *Scheduler) PlanInitialSchedule(ctx context.Context) error\n\n- Optionally, a periodic rescheduler:\n\n      func (s *Scheduler) Start(ctx context.Context) error\n      func (s *Scheduler) Stop()\n\nFor Scope 4, it’s acceptable if you only implement a **one-shot** planner that:\n\n- Runs once at scenario start.\n- Pre-populates the schedule for the whole horizon.\n\n### 8.2 – Link-driven beam scheduling\n\nImplement link-driven **beam scheduling** logic:\n\n- For each potential link in `ScenarioState`:\n  - Determine its periods of visibility `[T_on, T_off]`.\n  - Choose which **node/agent** is responsible for controlling that link (e.g. satellite side).\n  - Plan:\n\n    - `UpdateBeam` at `T_on - BeamLeadTime` (clamped to `>= Clock.Now()`).\n    - `DeleteBeam` at `T_off`.\n\nDesign notes (keep simple for Scope 4):\n\n- Use existing connectivity / visibility outputs from Scope 2:\n  - If you already have a function like `GetLinkVisibility(linkID)` returning intervals, use that.\n  - Otherwise, add a minimal helper that:\n    - For each link, computes a small set of intervals where it’s “in view”.\n- Assume:\n  - Controller won’t schedule impossible beams (visibility + geometry checked by Scope 2).\n  - No contention between beams for now (e.g. no multi-beam power budget modeling).\n\nImplementation sketch (conceptual):\n\n- Inside `PlanInitialSchedule`:\n\n      now := s.Clock.Now()\n      horizonEnd := now.Add(s.Horizon)\n\n      for each potentialLink in State.PotentialLinks():\n          intervals := State.GetLinkVisibilityIntervals(potentialLink.ID, now, horizonEnd)\n          agentID := s.agentForLink(potentialLink)\n\n          for each interval [T_on, T_off] in intervals:\n              onTime  := max(T_on.Add(-s.BeamLeadTime), now)\n              offTime := T_off\n\n              // Create UpdateBeam action\n              actionOn := &ScheduledAction{\n                  EntryID:   s.newEntryID(),\n                  When:      onTime,\n                  Type:      ScheduledUpdateBeam,\n                  Beam:      s.buildBeamSpec(potentialLink),\n              }\n\n              // Create DeleteBeam action\n              actionOff := &ScheduledAction{\n                  EntryID:   s.newEntryID(),\n                  When:      offTime,\n                  Type:      ScheduledDeleteBeam,\n                  Beam:      s.buildBeamSpec(potentialLink),\n              }\n\n              _ = s.CDPI.SendCreateEntry(agentID, actionOn)\n              _ = s.CDPI.SendCreateEntry(agentID, actionOff)\n\nNotes:\n\n- `newEntryID()` can be a simple monotonic counter or UUID-like helper.\n- `buildBeamSpec` translates link/antenna info into `BeamSpec` used by agents.\n- Error handling can be simple:\n  - Log and continue for failed `SendCreateEntry`.\n\n### 8.3 – Static routes for single-hop paths\n\nAdd **static routing** support for single-hop connectivity:\n\n- For each scheduled link interval `[T_on, T_off]` between nodes A and B:\n  - At `T_on`:\n    - Schedule `SetRoute` on A pointing to B.\n    - Schedule `SetRoute` on B pointing to A (bidirectional).\n  - At `T_off`:\n    - Schedule `DeleteRoute` on both nodes.\n\nRoute representation (already defined from earlier chunks, but summarized):\n\n- Internal type:\n\n      type RouteEntry struct {\n          DestinationCIDR string\n          NextHopNodeID   string\n          OutInterfaceID  string\n      }\n\nDecisions for Scope 4:\n\n- Destination:\n  - For simple single-hop, you can use:\n    - `DestinationCIDR` = “/32” host route for the neighbor node’s address space, or\n    - A synthetic per-node prefix if you already model node-level prefixes.\n- Outgoing interface:\n  - Derived from the link endpoint facing the neighbor.\n\nImplementation sketch:\n\n- For each link interval `[T_on, T_off]` with endpoints `(nodeA, ifaceA)` and `(nodeB, ifaceB)`:\n\n      // At T_on: install routes on both nodes.\n      routeA := &RouteEntry{\n          DestinationCIDR: s.destForNode(nodeB),\n          NextHopNodeID:   nodeB,\n          OutInterfaceID:  ifaceA,\n      }\n\n      routeB := &RouteEntry{\n          DestinationCIDR: s.destForNode(nodeA),\n          NextHopNodeID:   nodeA,\n          OutInterfaceID:  ifaceB,\n      }\n\n      // Scheduled actions (SetRoute)\n      setRouteA := &ScheduledAction{\n          EntryID: s.newEntryID(),\n          When:    T_on,\n          Type:    ScheduledSetRoute,\n          Route:   routeA,\n      }\n\n      setRouteB := &ScheduledAction{\n          EntryID: s.newEntryID(),\n          When:    T_on,\n          Type:    ScheduledSetRoute,\n          Route:   routeB,\n      }\n\n      // At T_off: delete routes\n      delRouteA := &ScheduledAction{\n          EntryID: s.newEntryID(),\n          When:    T_off,\n          Type:    ScheduledDeleteRoute,\n          Route:   routeA,\n      }\n\n      delRouteB := &ScheduledAction{\n          EntryID: s.newEntryID(),\n          When:    T_off,\n          Type:    ScheduledDeleteRoute,\n          Route:   routeB,\n      }\n\n      // Choose agentID for each node (e.g. agent per node)\n      agentA := s.agentForNode(nodeA)\n      agentB := s.agentForNode(nodeB)\n\n      _ = s.CDPI.SendCreateEntry(agentA, setRouteA)\n      _ = s.CDPI.SendCreateEntry(agentB, setRouteB)\n      _ = s.CDPI.SendCreateEntry(agentA, delRouteA)\n      _ = s.CDPI.SendCreateEntry(agentB, delRouteB)\n\nKeep it simple:\n\n- No multi-hop routing or path search yet.\n- No SR policies here; SR remains stubbed.\n\n### 8.4 – Minimal ServiceRequest-aware scheduling (optional but recommended)\n\nIntroduce a **minimal** use of `ServiceRequest`s:\n\n- For each active `ServiceRequest` (src → dst):\n  - Try to find *any* path through currently **potential** links.\n  - If a path exists “now”:\n    - Ensure the first-hop link’s beams and routes are scheduled.\n    - Optionally bias scheduling decisions to keep that path active.\n\nDesign constraints for Scope 4:\n\n- Path-finding can be primitive:\n  - Simple BFS over a graph where edges represent potential links.\n  - Ignore capacity, QoS, or interference constraints.\n- You can:\n  - Re-use link visibility intervals from 8.2.\n  - For the epic, it’s enough to:\n    - Document that minimal `ServiceRequest` use is present.\n    - Provide a single simple test that a `ServiceRequest` can trigger some scheduled actions.\n\nImplementation concept:\n\n- Add a helper on `Scheduler`:\n\n      func (s *Scheduler) computePathForServiceRequest(sr *model.ServiceRequest) []*Link {\n          // BFS over potential links; return 0 or more links as a path.\n      }\n\n- When planning schedule:\n  - For each `ServiceRequest`:\n    - Call `computePathForServiceRequest`.\n    - If non-empty path:\n      - Ensure that for each link in the path, you schedule:\n        - `UpdateBeam` / `DeleteBeam` as in 8.2.\n        - `SetRoute` / `DeleteRoute` as in 8.3.\n\nFor the epic, you can keep this very limited and refine later in non-epic issues.\n\n---\n\n## Acceptance criteria\n\n- **Scheduler component:**\n  - A `Scheduler` struct exists in `internal/sbi/controller` with:\n    - References to `ScenarioState`, `EventScheduler`, and `CDPIServer`.\n    - Configurable horizon and beam lead time (or sensible defaults).\n  - Provides at least:\n    - `PlanInitialSchedule(ctx)` that:\n      - Walks potential links.\n      - Emits scheduled actions via CDPI.\n\n- **Beam scheduling:**\n  - For each potential link with visibility intervals `[T_on, T_off]`:\n    - `ScheduledUpdateBeam` actions are created at `T_on - BeamLeadTime` (clamped).\n    - `ScheduledDeleteBeam` actions are created at `T_off`.\n    - Actions are sent to the correct agent via `CDPIServer`.\n  - Errors from CDPI sends are logged but do not crash the scheduler.\n\n- **Static route scheduling (single-hop):**\n  - For each link interval `[T_on, T_off]`, routes are:\n    - Installed at `T_on` on both endpoints via `ScheduledSetRoute`.\n    - Removed at `T_off` via `ScheduledDeleteRoute`.\n  - Routes include:\n    - `DestinationCIDR` that identifies the peer node.\n    - `NextHopNodeID` set to the peer node.\n    - `OutInterfaceID` set to the interface pointing at the peer.\n\n- **ServiceRequest integration (minimal):**\n  - Scheduler is aware of `ServiceRequest`s:\n    - Either uses them to bias scheduling, or\n    - At minimum, has a code path that can:\n      - Discover a path for a `ServiceRequest`.\n      - Schedule some beams/routes when a path exists.\n  - One or more unit tests demonstrate that:\n    - Adding a `ServiceRequest` can lead to scheduled actions.\n\n- **Tests:**\n  - Unit tests for the scheduler in `internal/sbi/controller/scheduler_test.go` (or similar):\n    - Use fake `ScenarioState` to define:\n      - A small set of nodes, interfaces, and potential links.\n      - Known visibility intervals `[T_on, T_off]`.\n    - Use a fake `CDPIServer` / stub that records calls to:\n      - `SendCreateEntry`.\n    - Verify:\n      - Correct number and types of `ScheduledAction`s are emitted.\n      - `When` times match expected `T_on`, `T_off`, and `BeamLeadTime` behavior.\n      - Routes are installed/removed as expected.\n    - At least one test covers `ServiceRequest`-driven scheduling (even if minimal).\n\n- **Repository health:**\n  - `go build ./...` passes with the new scheduler code.\n  - `go test ./...` passes, including new scheduler tests.\n  - No changes required to NBI/Scope 3 public API; this is internal SBI/controller logic only.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/160",
    "id": 3711945645,
    "node_id": "I_kwDOQfMfks7dP8ut",
    "number": 160,
    "title": "[Scope 4][Chunk 8] Implement link-driven beam scheduling in controller Scheduler",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139839,
        "node_id": "LA_kwDOQfMfks8AAAACRw-bvw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:8-sbi-controller-logic",
        "name": "chunk:8-sbi-controller-logic",
        "color": "de618e",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T17:29:23Z",
    "updated_at": "2025-12-09T17:38:38Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy this point in **Chunk 8** you should have:\n\n- A **Scheduler** skeleton on the controller side (from the previous Chunk 8 issue), e.g.:\n\n    type Scheduler struct {\n        State *simstate.ScenarioState\n        Clock sbi.EventScheduler\n        CDPI  *CDPIServer\n    }\n\n- A working **CDPIServer** (from Chunk 5) that can:\n  - Track connected agents (`AgentHandle` per agent).\n  - Send `CreateEntryRequest` / `DeleteEntryRequest` / `FinalizeRequest` via:\n    - `SendCreateEntry(agentID string, action *ScheduledAction) error`\n    - `SendDeleteEntry(agentID, entryID string) error`\n    - etc.\n- An internal **ScheduledAction** model from Chunk 2:\n\n    type ScheduledActionType int\n\n    const (\n        ScheduledUpdateBeam ScheduledActionType = iota\n        ScheduledDeleteBeam\n        // ...\n    )\n\n    type ScheduledAction struct {\n        EntryID  string\n        When     time.Time\n        Type     ScheduledActionType\n        RequestID string\n        SeqNo     int64\n        Token     string\n\n        Beam   *BeamSpec\n        Route  *RouteEntry\n        // ...\n    }\n\n- Scenario / connectivity state (Scope 2 + ScenarioState) that knows:\n  - Which links are **potential** (geometrically / RF feasible).\n  - For each potential link, when it is **“in view”** over the simulation horizon (or at least can answer “in view at time T?”).\n\nFrom the Scope 4 plan, **link-driven beam scheduling** is the first “real” scheduling behaviour:\n\n- For each potential link:\n  - Determine its **visibility intervals** `[T_on, T_off]`.\n  - Schedule:\n    - A `ScheduledUpdateBeam` at `T_on` (possibly with a small lead time).\n    - A `ScheduledDeleteBeam` at `T_off`.\n- Attach these actions to the correct **agent** (typically the satellite / node that owns the transmitting interface).\n\nThis issue fills in that logic inside the Scheduler, leaving routes and ServiceRequest-aware scheduling to later issues.\n\n## Goal\n\nImplement a first-pass, **link-driven beam scheduling** strategy:\n\n- For each potential link in `ScenarioState`:\n  - Discover one or more **in-view intervals** `[T_on, T_off]` over the scenario time window.\n  - For each interval, create:\n    - A `ScheduledUpdateBeam` action at `T_on` (or `T_on - leadTime`, clamped to ≥ now).\n    - A `ScheduledDeleteBeam` action at `T_off`.\n- For each action:\n  - Populate an internal `ScheduledAction` with a `BeamSpec` that:\n    - Identifies the **source node** and **source interface**.\n    - Identifies the **target node/interface** or other target representation consistent with your model.\n  - Send the action to the correct agent via `CDPIServer.SendCreateEntry`.\n- Ensure:\n  - Scheduling is **idempotent** (avoid duplicating actions on repeated runs).\n  - Only links with a clear agent/endpoint mapping are scheduled.\n- Add **unit tests** that:\n  - Use a small in-memory `ScenarioState` with one or two links and known visibility windows.\n  - Verify the expected `ScheduledUpdateBeam` / `ScheduledDeleteBeam` calls are emitted with the right times and endpoints.\n\n## Where to look\n\nKey places in the codebase:\n\n- Scheduler (previous Chunk 8 issue):\n\n    internal/sbi/controller/scheduler.go\n\n  Expect something like:\n\n    type Scheduler struct {\n        State *simstate.ScenarioState\n        Clock sbi.EventScheduler\n        CDPI  *CDPIServer\n        // possibly: logger, config, etc.\n    }\n\n    func (s *Scheduler) RunInitialSchedule(ctx context.Context) error {\n        // currently stubbed / partial\n    }\n\n- Scenario / connectivity model:\n\n  - The types that represent links and their state, e.g.:\n\n        type NetworkLink struct {\n            LinkID     string\n            SrcNodeID  string\n            SrcIfID    string\n            DstNodeID  string\n            DstIfID    string\n            // fields for geometry / visibility / bandwidth / etc.\n        }\n\n  - The APIs that can answer either:\n    - “List all potential links”, and/or:\n    - “Give me visibility windows for this link”.\n\n  Search terms:\n\n  - `NetworkLink`\n  - `PotentialLinks`, `AllLinks`, `GetLinks`\n  - `Visibility`, `InView`, `TimeWindow`, `LinkWindow`\n  - Anything under `sim/state` or `internal/simstate` that looks like “link windows”.\n\n- Agent / SBI mapping:\n\n  - How you map **nodes → agents**:\n    - e.g. Node config that carries an `AgentID`.\n    - CDPIServer’s `agents` map keyed by `AgentID`.\n  - You may need a helper to find the agent for a given node ID.\n\n## Tasks\n\n### 1. Decide scheduler entrypoint and time horizon\n\n- In `Scheduler`, define an entrypoint for link-driven scheduling, e.g.:\n\n      func (s *Scheduler) ScheduleLinkBeams(ctx context.Context) error\n\n- Decide **time horizon** for planning:\n  - For now, a simple approach:\n    - Use the current sim time `now := s.Clock.Now()`.\n    - Use a fixed horizon duration (e.g. `horizon := now.Add(1 * time.Hour)`), or\n    - Use scenario metadata (start/end time) if available.\n- This method will:\n  - Enumerate potential links.\n  - Compute visibility windows `[T_on, T_off]` within `[now, horizon]`.\n  - Emit `ScheduledAction`s via CDPI.\n\nDesign note: Later you can decide whether this runs once at scenario start, or periodically. For now, keep it **single-shot** and idempotent.\n\n### 2. Enumerate potential links and visibility windows\n\n- Add / use a helper on `ScenarioState` to iterate links:\n\n      func (s *ScenarioState) AllPotentialLinks() []NetworkLink\n\n  or similar. If you already have a function, reuse it; otherwise:\n\n  - Implement a simple enumerator that:\n    - Returns all links that are “potential” (i.e. geometrically possible).\n    - Ignores purely logical / disabled links.\n\n- For each link, derive visibility intervals within `[now, horizon]`. Options:\n\n  - If you already have a “link windows” API (ideal):\n\n        func (s *ScenarioState) LinkWindows(linkID string, start, end time.Time) []LinkWindow\n\n        type LinkWindow struct {\n            Start time.Time\n            End   time.Time\n        }\n\n  - If you only have an “is in view at time T?” function:\n    - For this chunk, you can:\n      - Sample the horizon at a coarse step (e.g. every 10–30 seconds).\n      - Detect transitions in `inView` (false→true = `T_on`, true→false = `T_off`).\n    - Keep this simple and document it; you can refine later.\n\n- For this issue, assume **at least one** reasonable path to derive `[T_on, T_off]` per link, and prefer a simple helper that can be reused by tests.\n\n### 3. Map links to agents and construct BeamSpec\n\n- Define / reuse an internal `BeamSpec` type, e.g.:\n\n      type BeamSpec struct {\n          LinkID      string\n          SrcNodeID   string\n          SrcIfID     string\n          DstNodeID   string\n          DstIfID     string\n          // Optional RF params: frequency, EIRP, etc.\n      }\n\n- Add a helper to construct a `BeamSpec` from a `NetworkLink`:\n\n      func BeamSpecFromLink(l *NetworkLink) *BeamSpec\n\n- Decide **which side owns the beam** (which agent to schedule):\n\n  - For now, pick a simple rule:\n    - e.g. beam is controlled by the satellite / LEO node; or\n    - always by `SrcNodeID` if that’s how you model it.\n\n- Implement a small mapping helper:\n\n      func (s *Scheduler) agentIDForNode(nodeID string) (string, bool)\n\n  That looks up the controller’s `CDPI` server’s `agents` map or some registry to map `nodeID → agentID`.\n\n  - If no agent can be found:\n    - Log and **skip** scheduling for that link.\n\n### 4. Create and send ScheduledActions via CDPI\n\n- For each visibility interval `[T_on, T_off]` and resolved `agentID`:\n\n  - Define a small **lead time** constant (optional), e.g.:\n\n        const defaultBeamLeadTime = 0\n\n    (You can start with zero lead, then later change to a small positive duration if needed.)\n\n  - Compute:\n\n        now := s.Clock.Now()\n        onTime  := T_on.Add(-defaultBeamLeadTime)\n        if onTime.Before(now) {\n            onTime = now\n        }\n\n  - Create two `ScheduledAction`s:\n\n    - `ScheduledUpdateBeam` at `onTime`.\n    - `ScheduledDeleteBeam` at `T_off`.\n\n  - Fill fields:\n\n        actionOn := &ScheduledAction{\n            EntryID:   fmt.Sprintf(\"link:%s:on:%d\", link.LinkID, T_on.UnixNano()),\n            When:      onTime,\n            Type:      ScheduledUpdateBeam,\n            Beam:      BeamSpecFromLink(&link),\n            // RequestID / SeqNo / Token can be filled in CDPI or here,\n            // depending on how you structured responsibilities.\n        }\n\n        actionOff := &ScheduledAction{\n            EntryID:   fmt.Sprintf(\"link:%s:off:%d\", link.LinkID, T_off.UnixNano()),\n            When:      T_off,\n            Type:      ScheduledDeleteBeam,\n            Beam:      BeamSpecFromLink(&link),\n        }\n\n  - Call:\n\n        if err := s.CDPI.SendCreateEntry(agentID, actionOn); err != nil {\n            // log and continue\n        }\n\n        if err := s.CDPI.SendCreateEntry(agentID, actionOff); err != nil {\n            // log and continue\n        }\n\nDesign notes:\n\n- **Idempotency**:\n  - Option 1 (simple): assume `ScheduleLinkBeams` is only called once.\n  - Option 2 (better): keep a set of `EntryID`s you’ve already scheduled and skip duplicates.\n- **Token / seqno**:\n  - If CDPI handles tokens/seqno, you can let `SendCreateEntry` fill these.\n  - If not, add a simple per-agent seqno generator on the Scheduler/CDPI side.\n\n### 5. Wire link scheduling into Scheduler lifecycle\n\n- Update your Scheduler entrypoint (from previous issue), e.g.:\n\n      func (s *Scheduler) RunInitialSchedule(ctx context.Context) error {\n          // 1. Link-driven beam schedule\n          if err := s.ScheduleLinkBeams(ctx); err != nil {\n              return err\n          }\n\n          // 2. (Later) route and ServiceRequest-aware scheduling, in subsequent issues.\n          return nil\n      }\n\n- Make sure your **scenario startup flow** (Chunk 9 later) calls `RunInitialSchedule` after:\n\n  - `ScenarioState` is constructed.\n  - `CDPIServer` is created.\n  - Agents are connected and have sent `Hello`, so `agents` map is populated.\n\nFor this issue, you only need to ensure the Scheduler exposes the right method; full wiring is covered in Chunk 9.\n\n### 6. Unit tests for link-driven scheduling\n\nCreate `internal/sbi/controller/scheduler_links_test.go` (or similar).\n\nTest setup:\n\n- Use a small **fake / in-memory** `ScenarioState`:\n\n  - Contains:\n    - Two nodes: `node-A`, `node-B`.\n    - One potential link:\n\n          linkID = \"link-ab\"\n          SrcNodeID = \"node-A\"\n          SrcIfID   = \"if-A\"\n          DstNodeID = \"node-B\"\n          DstIfID   = \"if-B\"\n\n  - Visibility windows:\n\n    - For simplicity, a single window `[T_on, T_off]`, e.g.:\n\n          T0 := time.Unix(1000, 0)\n          T_on  := T0.Add(10 * time.Second)\n          T_off := T0.Add(20 * time.Second)\n\n- Fake `EventScheduler`:\n\n  - Implements `Now()` returning `T0`.\n  - `Schedule` / `Cancel` may be unused in this specific test, but you can provide no-ops.\n\n- Fake `CDPIServer`:\n\n  - Replace `SendCreateEntry` with a test stub that records:\n    - `agentID`\n    - `ScheduledAction`\n\n- Provide a simple mapping `nodeID → agentID` inside Scheduler/CDPI so that:\n  - `node-A` maps to `agent-1`.\n\nTest cases:\n\n1. Single link, single window → two actions\n\n   - Call `scheduler.ScheduleLinkBeams(ctx)`.\n   - Assert:\n     - `SendCreateEntry` was called exactly **twice**:\n       - Once with `Type == ScheduledUpdateBeam`, `When == onTime (T_on or clamped)`.\n       - Once with `Type == ScheduledDeleteBeam`, `When == T_off`.\n     - `Beam` fields:\n       - `LinkID == \"link-ab\"`.\n       - `SrcNodeID == \"node-A\"`, `SrcIfID == \"if-A\"`.\n       - `DstNodeID == \"node-B\"`, `DstIfID == \"if-B\"`.\n\n2. Window partially in the past → onTime clamped\n\n   - Set `Now()` to `T_on + 5s`.\n   - Expect:\n     - `ScheduledUpdateBeam.When == Now()` (clamped).\n     - `ScheduledDeleteBeam.When == T_off` (unchanged).\n\n3. Multiple windows or links\n\n   - Add:\n     - A second window for the same link, or\n     - Another link.\n   - Assert:\n     - Each window produces a pair of actions.\n     - Total count and basic fields match expectations.\n\n4. No agent mapping → link skipped\n\n   - Remove agent mapping for `node-A`.\n   - Call `ScheduleLinkBeams`.\n   - Assert:\n     - `SendCreateEntry` is never called.\n     - No panics.\n\n5. Idempotency (if implemented)\n\n   - Call `ScheduleLinkBeams` twice with the same state.\n   - If you implemented an “already scheduled” guard:\n     - Assert each expected action is only sent once.\n\n## Acceptance criteria\n\n- Scheduler:\n\n  - Exposes a method like `ScheduleLinkBeams(ctx context.Context) error`.\n  - Uses `ScenarioState` + connectivity info to:\n    - Enumerate potential links.\n    - Derive visibility intervals `[T_on, T_off]` within a planning horizon.\n\n- Link-driven beam scheduling:\n\n  - For each visibility interval:\n    - Creates a `ScheduledUpdateBeam` at `max(T_on - leadTime, now)`.\n    - Creates a `ScheduledDeleteBeam` at `T_off`.\n  - Constructs `BeamSpec` from the underlying `NetworkLink`.\n  - Resolves the owning agent (node → agent mapping).\n  - For each action, calls `CDPIServer.SendCreateEntry(agentID, action)`.\n\n- Behavioural guarantees:\n\n  - Links without a valid agent mapping are safely skipped (no panics).\n  - Times are computed in **sim time** using `EventScheduler.Now()`.\n  - Any lead-time clamping logic is documented and unit-tested.\n\n- Tests:\n\n  - `scheduler_links_test.go` (or equivalent) includes tests that:\n    - Verify **two actions per window** (on/off) with expected fields.\n    - Verify clamping of `onTime` when `T_on` is in the past.\n    - Verify behaviour with multiple links/windows.\n    - Verify safe behaviour when agent mapping is missing.\n    - (Optional) Verify idempotency if you chose to implement it.\n  - All new tests pass with `go test ./...`.\n\n- Repository health:\n\n  - `go build ./...` passes with the new Scheduler link-scheduling code.\n  - `go test ./...` passes, including new link-driven scheduling tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/162",
    "id": 3712045376,
    "node_id": "I_kwDOQfMfks7dQVFA",
    "number": 162,
    "title": "[Scope 4][Chunk 8] Add static single-hop routes based on link availability in Scheduler",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139839,
        "node_id": "LA_kwDOQfMfks8AAAACRw-bvw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:8-sbi-controller-logic",
        "name": "chunk:8-sbi-controller-logic",
        "color": "de618e",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T17:58:27Z",
    "updated_at": "2025-12-09T17:58:27Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the time you reach this issue in **Chunk 8**, you should already have:\n\n- A controller-side **Scheduler** type (non-gRPC) under something like `internal/sbi/controller`:\n  - Holds a reference to `ScenarioState`.\n  - Has access to an `EventScheduler` / sim clock.\n  - Knows how to talk to `CDPIServer` via helpers like `SendCreateEntry` / `SendDeleteEntry`.\n- A basic **link-driven beam scheduling** implementation:\n  - For each potential link with known \"in view\" intervals `[T_on, T_off]`, the scheduler:\n    - Schedules an `UpdateBeam` `CreateEntry` near `T_on` for the satellite-side agent.\n    - Schedules a `DeleteBeam` `CreateEntry` at `T_off`.\n\nWhat’s still missing is the **static routing side** described in the Scope 4 plan:\n\n- When a single-hop link is \"on\", both endpoints should have simple **static routes** installed pointing at each other.\n- When the link goes \"off\", those routes should be removed.\n- This is still **mechanism only** (no multi-hop pathfinding yet) but gives basic reachability for later scopes.\n\nThis issue teaches the Scheduler to generate **SetRoute/DeleteRoute** scheduled actions in sync with link on/off intervals, using the existing per-node routing table support from Scope 4 Chunk 0 / 2.\n\n## Goal\n\nExtend the controller Scheduler so that for each single-hop link interval `[T_on, T_off]`:\n\n- At (or just before) `T_on`:\n  - Schedule `SetRoute` actions on **both endpoints**:\n    - Node A: add route `dest=B` via interface to B.\n    - Node B: add route `dest=A` via interface to A.\n- At `T_off`:\n  - Schedule `DeleteRoute` for the corresponding `dest=B` / `dest=A` entries.\n\nKey properties:\n\n- Uses the existing route table model (e.g. `RouteEntry`) and ScenarioState helpers `InstallRoute` / `RemoveRoute`.\n- Uses `ScheduledAction.Type` values like `ScheduledSetRoute` / `ScheduledDeleteRoute`.\n- Uses the same **per-agent CDPI flow** as beam scheduling (`CreateEntryRequest` containing SetRoute/DeleteRoute payloads).\n- Keeps logic simple and deterministic; it does **not** attempt multi-hop routing yet (that comes with ServiceRequests in a later issue).\n\n## Where to look\n\nScheduler implementation (Chunk 8 base):\n\n- Likely under:\n\n      internal/sbi/controller/scheduler.go\n\n- Expected types:\n\n      type Scheduler struct {\n          State *simstate.ScenarioState\n          Clock sbi.EventScheduler\n          CDPI  *CDPIServer\n          // maybe other fields (config, logger, etc.)\n      }\n\n- Existing methods (from prior Chunk 8 issue):\n\n      func (s *Scheduler) ScheduleBeamsForLinks(...) { ... }\n      func (s *Scheduler) RunOnce(...) error\n      // or similar entrypoints\n\nScheduledAction model (Chunk 2 definitions):\n\n- Somewhere under `internal/sbi` or `internal/sbi/types`:\n\n      type ScheduledActionType int\n\n      const (\n          ScheduledUpdateBeam ScheduledActionType = iota\n          ScheduledDeleteBeam\n          ScheduledSetRoute\n          ScheduledDeleteRoute\n          ScheduledSetSrPolicy\n          ScheduledDeleteSrPolicy\n      )\n\n      type ScheduledAction struct {\n          EntryID   string\n          When      time.Time\n          Type      ScheduledActionType\n          RequestID string\n          SeqNo     int64\n          Token     string\n          Beam      *BeamSpec\n          Route     *RouteEntry\n          SrPolicy  *SrPolicySpec\n      }\n\nRoute model and ScenarioState helpers (Chunks 0 / 2):\n\n- Per-node routing fields, e.g. in `model.NetworkNode` or similar:\n\n      type RouteEntry struct {\n          DestinationCIDR string\n          NextHopNodeID   string\n          OutInterfaceID  string\n      }\n\n- ScenarioState routing helpers:\n\n      func (s *ScenarioState) InstallRoute(nodeID string, route RouteEntry) error\n      func (s *ScenarioState) RemoveRoute(nodeID, destCIDR string) error\n\nLink model / connectivity info:\n\n- Types that represent links and their endpoints, something like:\n\n      type NetworkLink struct {\n          LinkID      string\n          NodeAID     string\n          InterfaceA  string\n          NodeBID     string\n          InterfaceB  string\n          // maybe capacity, in-view intervals, etc.\n      }\n\n- Helper(s) to get **in-view intervals** or potential links:\n\n      func (s *ScenarioState) ListPotentialLinks() []NetworkLink\n      func (s *ScenarioState) GetLinkVisibility(linkID string) []VisibilityInterval\n\n      type VisibilityInterval struct {\n          Start time.Time\n          End   time.Time\n      }\n\nCDPI helpers (from Chunk 5):\n\n- On `CDPIServer` (or a helper wrapping it):\n\n      func (s *CDPIServer) SendCreateEntry(agentID string, action *ScheduledAction) error\n      func (s *CDPIServer) SendDeleteEntry(agentID, entryID string) error\n\nYou’ll reuse these to push route-related `CreateEntryRequest`s to agents.\n\nSearch terms:\n\n- `Scheduler struct`\n- `ScheduledAction`\n- `ScheduledSetRoute`\n- `RouteEntry`\n- `InstallRoute`\n- `NetworkLink`\n- `VisibilityInterval`\n\n## Tasks\n\n### 1. Decide how to derive route destinations for single-hop links\n\nYou need a consistent rule for what **destination** each static route should represent.\n\nA simple scheme:\n\n- For each link between nodes A and B:\n  - On node A, install a route `dest=B` with a `DestinationCIDR` that represents \"node B\".\n  - On node B, install a route `dest=A`.\n\nDepending on your model, this might be:\n\n- Just a synthetic `/32` or `/128` per node:\n\n      route := RouteEntry{\n          DestinationCIDR: fmt.Sprintf(\"%s/32\", destNodeIP), // or some node ID → CIDR mapping\n          NextHopNodeID:   destNodeID,\n          OutInterfaceID:  ifaceID,\n      }\n\n- Or, if you don’t have real IP addresses yet:\n\n  - Use a placeholder `DestinationCIDR` that your routing layer understands (e.g. `\"node:B\"`), but be consistent.\n\n**Design note:** For Scope 4, it’s acceptable to:\n\n- Treat `DestinationCIDR` as an opaque key like `\"node:<ID>\"`.\n- Document that more realistic IP/route semantics come in later scopes.\n\n### 2. Extend Scheduler to compute route actions per link interval\n\nIn your Scheduler (e.g. `scheduler.go`), add logic alongside beam scheduling:\n\n- For each potential link with visibility intervals `[T_on, T_off]`:\n  - Determine:\n    - `nodeA`, `ifaceA` and `nodeB`, `ifaceB`.\n    - Agent IDs for those nodes (you may have a mapping `nodeID → agentID`).\n\nThen:\n\n- At `T_on`:\n  - Construct two `ScheduledAction`s:\n    - `ScheduledSetRoute` for node A (agent for A) with a `RouteEntry` to B.\n    - `ScheduledSetRoute` for node B (agent for B) with a `RouteEntry` to A.\n- At `T_off`:\n  - Construct two `ScheduledDeleteRoute` actions mirroring those entries.\n\nPseudo-structure:\n\n- You might add a helper:\n\n      func (s *Scheduler) scheduleRoutesForLink(link NetworkLink, intervals []VisibilityInterval) error\n\nwhich:\n\n- Iterates intervals.\n- For each interval, calls lower-level helpers:\n\n      s.scheduleSetRouteAt(T_on, nodeA, nodeB, ifaceA)\n      s.scheduleSetRouteAt(T_on, nodeB, nodeA, ifaceB)\n      s.scheduleDeleteRouteAt(T_off, nodeA, nodeB)\n      s.scheduleDeleteRouteAt(T_off, nodeB, nodeA)\n\n### 3. Build ScheduledAction payloads for SetRoute/DeleteRoute\n\nImplement small helpers on Scheduler (or a separate builder) to construct route actions:\n\n- For SetRoute:\n\n      func (s *Scheduler) newSetRouteAction(\n          when time.Time,\n          nodeID string,\n          destNodeID string,\n          outInterfaceID string,\n      ) *ScheduledAction\n\nInternals:\n\n- Build a `RouteEntry`:\n\n      route := &RouteEntry{\n          DestinationCIDR: s.destCIDRForNode(destNodeID), // helper from Task 1\n          NextHopNodeID:   destNodeID,\n          OutInterfaceID:  outInterfaceID,\n      }\n\n- Create a `ScheduledAction`:\n\n      &ScheduledAction{\n          EntryID:   s.nextEntryID(), // helper to generate unique IDs\n          When:      when,\n          Type:      ScheduledSetRoute,\n          RequestID: s.nextRequestID(nodeID),\n          SeqNo:     s.nextSeqNo(nodeID),\n          Token:     s.currentTokenForNode(nodeID),\n          Route:     route,\n      }\n\n- For DeleteRoute:\n\n      func (s *Scheduler) newDeleteRouteAction(\n          when time.Time,\n          nodeID string,\n          destNodeID string,\n      ) *ScheduledAction\n\nInternals:\n\n- You can either:\n  - Repeat the same `RouteEntry` fields (for completeness), or\n  - Only send the destination in the proto and let the agent look up and delete it.\n\nFor Scope 4, a simple approach is:\n\n- Have `ScheduledAction.Route` filled with the same `DestinationCIDR` you used for SetRoute, and ignore `NextHopNodeID`/`OutInterfaceID` on delete.\n\n### 4. Wire route actions into CDPI and agents\n\nEnsure that:\n\n- Controller-side:\n\n  - `Scheduler` uses `CDPIServer.SendCreateEntry(agentID, action)` to push:\n    - `ScheduledSetRoute` / `ScheduledDeleteRoute` actions to the right agent.\n  - If you don’t yet have a clean `nodeID → agentID` mapping helper, introduce one in the controller layer.\n\n- Agent-side (from earlier chunks):\n\n  - `Agent.execute(action *ScheduledAction)` must already have branches:\n\n        case ScheduledSetRoute:\n            // call ScenarioState.InstallRoute(nodeID, *action.Route)\n        case ScheduledDeleteRoute:\n            // call ScenarioState.RemoveRoute(nodeID, action.Route.DestinationCIDR)\n\n  - If these branches don’t exist yet, add them now (but keep behavior simple).\n\n### 5. Optional: small unit tests for route scheduling\n\nWhile **Chunk 10** will have broader test coverage, add at least a minimal test for this behavior now (to avoid regressions):\n\n- In `internal/sbi/controller/scheduler_routes_test.go` or similar:\n\n  - Use an in-memory `ScenarioState` with:\n    - Two nodes (A, B).\n    - One link with endpoints (A:ifA, B:ifB).\n    - One visibility interval `[T_on, T_off]`.\n  - Use a fake `CDPIServer` that records `SendCreateEntry` calls.\n  - Run a single scheduling pass (e.g. `Scheduler.RunOnce()` or a specific `ScheduleRoutesForLinks()`).\n\n- Assert:\n\n  - Exactly **four** route actions are created:\n    - 2 × `ScheduledSetRoute` (one per node at/on T_on).\n    - 2 × `ScheduledDeleteRoute` (one per node at T_off).\n  - Each `SetRoute` action:\n    - Has `Route.NextHopNodeID` set to the peer node.\n    - Has `Route.OutInterfaceID` set to the correct interface.\n  - Each `DeleteRoute` action:\n    - Targets the same destination CIDR as the corresponding `SetRoute`.\n\n## Acceptance criteria\n\n- Scheduler behavior:\n\n  - For each potential link with visibility interval `[T_on, T_off]`:\n    - Scheduler generates **two** `ScheduledSetRoute` actions at/on `T_on` (one per endpoint).\n    - Scheduler generates **two** `ScheduledDeleteRoute` actions at `T_off` (one per endpoint).\n  - Route actions are sent via CDPI to the appropriate agents.\n\n- Route modeling:\n\n  - A consistent `DestinationCIDR` scheme is defined for \"node-to-node\" routes.\n  - `RouteEntry.NextHopNodeID` and `RouteEntry.OutInterfaceID` are filled correctly for single-hop routes.\n  - ScenarioState’s `InstallRoute` / `RemoveRoute` helpers are used for all route mutations.\n\n- Agent integration:\n\n  - Agent `execute` logic handles:\n    - `ScheduledSetRoute` by calling `InstallRoute` on ScenarioState.\n    - `ScheduledDeleteRoute` by calling `RemoveRoute` with the correct destination key.\n  - No panics or inconsistent state when route actions are executed multiple times or out of order (idempotent enough for Scope 4).\n\n- Tests (at least minimal):\n\n  - A Scheduler-focused test (or tests) verifies:\n    - That for a simple topology with one link and one visibility interval, the expected `ScheduledSetRoute` / `ScheduledDeleteRoute` actions are produced.\n    - That actions contain correct `nodeID`, `destination`, and `outInterfaceID` for both endpoints.\n\n- Repository health:\n\n  - `go build ./...` passes after adding route scheduling code.\n  - `go test ./...` passes, including the new route scheduling tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/163",
    "id": 3712061147,
    "node_id": "I_kwDOQfMfks7dQY7b",
    "number": 163,
    "title": "[Scope 4][Chunk 8] Implement minimal ServiceRequest-aware scheduling in controller Scheduler",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737889453,
        "node_id": "LA_kwDOQfMfks8AAAACRGxmrQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:3-nbi",
        "name": "scope:3-nbi",
        "color": "913db1",
        "default": false,
        "description": ""
      },
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139839,
        "node_id": "LA_kwDOQfMfks8AAAACRw-bvw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:8-sbi-controller-logic",
        "name": "chunk:8-sbi-controller-logic",
        "color": "de618e",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T18:03:48Z",
    "updated_at": "2025-12-09T18:03:48Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the time this issue is picked up, the Scope 4 controller-side scheduling work in Chunk 8 should have:\n\n- A `Scheduler` component under something like `internal/sbi/controller` that:\n  - Has access to `ScenarioState` and an `EventScheduler`-style clock.\n  - Can emit `ScheduledAction`s via `CDPIServer.SendCreateEntry(...)`.\n- Link-driven scheduling (or at least the structure for it), where:\n  - Potential links from Scope 2 can be turned into `ScheduledUpdateBeam` / `ScheduledDeleteBeam` actions over a simple [T_on, T_off] interval.\n- Basic beam/route application helpers on `ScenarioState` (from earlier chunks):\n  - `ApplyBeamUpdate(...)`, `ApplyBeamDelete(...)`.\n  - `InstallRoute(...)`, `RemoveRoute(...)`.\n- A Scope 3 `ServiceRequest` model (from Chunk 6) integrated into `ScenarioState`, e.g.:\n  - Ability to list active service requests.\n  - Access to each request’s src/dst node IDs and simple QoS hints.\n\nWhat the scheduler **still** does not do is use ServiceRequests as a driver for what to schedule:\n\n- There is no logic that says “if an SR between `src` and `dst` exists and there is connectivity, schedule beams/routes along a path”.\n- Link-driven scheduling may already bring links up/down over time, but:\n  - No simple path search is performed based on the “connectivity graph”.\n  - No static routes (`SetRoute`/`DeleteRoute`) are installed specifically to satisfy ServiceRequests.\n\nThis issue adds a **minimal ServiceRequest-aware scheduling layer** on top of the existing scheduler logic:\n\n- No optimization.\n- No fairness or multi-request conflict resolution.\n- Just: “if there is an available path **now**, issue `UpdateBeam` and `SetRoute` actions along it”.\n\n## Goal\n\nIntroduce minimal ServiceRequest-aware behavior in the controller `Scheduler`:\n\n- For each active ServiceRequest:\n  - Periodically look for **any** available path between `SrcNodeID` and `DstNodeID` over currently potential/active links.\n  - If a path is found:\n    - Schedule `ScheduledUpdateBeam` actions (if not already present) along the first-hop / relevant links.\n    - Schedule `ScheduledSetRoute` actions along the path so src/dst have static routes installed.\n- Keep the behavior intentionally naive:\n  - Single-path, first-found BFS (or similar) is enough.\n  - No attempt to compute multiple candidate paths or optimize QoS.\n- Add shape/structure in the scheduler so that later, more sophisticated policies can replace this logic without refactoring the entire controller.\n\n## Where to look\n\nServiceRequest model and storage:\n\n- NBI / model types from Scope 3 + Chunk 6, for example:\n  - `internal/nbi/types` for mapping, and:\n  - `internal/sim/state` / `sim/state` for how ServiceRequests are stored:\n    - Listing service requests (e.g. `ListServiceRequests()` or equivalent).\n    - Accessing `SrcNodeID`, `DstNodeID`, priority, etc.\n\nScheduler and CDPI integration (Chunk 8):\n\n- Scheduler type under something like:\n\n      internal/sbi/controller/scheduler.go\n\n  - Look for a struct similar to:\n\n      type Scheduler struct {\n          State *simstate.ScenarioState\n          Clock EventScheduler\n          CDPI  *CDPIServer\n          // ... any existing fields (loggers, config, etc.)\n      }\n\n- Any existing `RunOnce` / `Tick` / `Recompute` methods where link-driven actions are computed.\n\nScenarioState / connectivity graph:\n\n- Functions/helpers that expose:\n  - Nodes and interfaces.\n  - Links and their end-points.\n  - Whether links are currently potential/usable (even if not yet “active”).\n- Look for:\n  - `GetAllLinks()`, `GetPotentialLinks()`, `GetNode(id)`, `GetInterfacesForNode(id)` or similar.\n  - Any existing graph-style helpers from Scope 2/3 you can reuse.\n\nSearch terms:\n\n- `ServiceRequest`\n- `Scheduler struct`\n- `ScheduledAction`\n- `InstallRoute`, `ApplyBeamUpdate`\n- `CDPIServer.SendCreateEntry`\n\n## Tasks\n\n### 1. Expose a minimal ServiceRequest listing API on ScenarioState (if missing)\n\n- If not already present, add a read-only helper on `ScenarioState` such as:\n\n      func (s *ScenarioState) ListServiceRequests() []*model.ServiceRequest\n\n  or an equivalent method returning a slice/map of current SRs.\n\n- The helper should be:\n  - Concurrency-safe, following existing `ScenarioState` locking patterns.\n  - Returning a copy/snapshot (or clearly documented if returning internal pointers).\n\n- Ensure each `ServiceRequest` exposes at least:\n  - `SrcNodeID string`\n  - `DstNodeID string`\n  - Optionally, `Priority`, `FlowRequirements`, etc. (for future tuning, but not required for this minimal pass).\n\n### 2. Build a simple connectivity graph helper\n\nImplement a small helper (either as methods on Scheduler or a dedicated package) to derive a graph of currently usable links:\n\n- A straightforward in-memory representation is enough, e.g.:\n\n      type Graph struct {\n          Adj map[string][]string // NodeID -> neighbor NodeIDs\n      }\n\n- Populate adjacency using potential or active links from `ScenarioState`:\n\n      // Pseudocode:\n      links := state.ListPotentialLinks() // adjust to actual API\n      for _, link := range links {\n          // Each link has endpoints A and B.\n          graph.AddUndirectedEdge(link.NodeAID, link.NodeBID)\n      }\n\n- Decisions for this minimal pass:\n  - It’s OK to treat “potential” links as edges; future work can constrain this using “in view” windows or active flags.\n  - For single-hop SRs, the path will just be one edge; for multi-hop, BFS will naturally find a chain.\n\n### 3. Implement a tiny path search: BFS over the node graph\n\nAdd a helper on Scheduler (or Graph) to compute a single path between two nodes:\n\n- Example signature:\n\n      func (s *Scheduler) findAnyPath(srcNodeID, dstNodeID string) []string\n\n  where the result is a list of node IDs `[src, ..., dst]`.\n\n- Implementation details:\n\n  - Use BFS:\n\n        - Start from `srcNodeID`.\n        - Use a queue, `visited` map, and `prev` map.\n        - Stop when `dstNodeID` is reached.\n        - Reconstruct path by walking `prev` backwards.\n\n  - Return `nil` if no path is found.\n\n- Keep the logic simple and well-isolated so it can be swapped later for more sophisticated routing.\n\n### 4. Map paths to scheduled actions (beams + routes)\n\nOnce you can compute a `[node0, node1, ..., nodeN]` path:\n\n1. **Decide which agent “owns” each hop**:\n   - For a minimal implementation, treat the first node in each hop `(node[i], node[i+1])` as the agent that will execute `UpdateBeam` / `SetRoute`.\n   - This is consistent with the rest of Scope 4 where “satellite-side node” or one endpoint is chosen as the controlling agent.\n\n2. **Resolve link/interface IDs**:\n   - Use ScenarioState helpers to find the link + interface connecting `node[i]` → `node[i+1]`:\n     - e.g. `state.FindLinkBetween(nodeA, nodeB)` or manual scan if not present.\n   - Extract:\n     - The interface ID on `node[i]`.\n     - Any link metadata (e.g. `LinkID`, capacity) needed to populate `BeamSpec` or `RouteEntry`.\n\n3. **Build `ScheduledAction`s**:\n   - For each hop:\n     - A `ScheduledUpdateBeam` using a `BeamSpec` targeted from `node[i]` to `node[i+1]`.\n     - A `ScheduledSetRoute` on `node[i]` such that:\n       - `DestinationCIDR` represents traffic destined to `node[i+1]` (or the final `dst`), as per your existing `RouteEntry` assumptions.\n       - `NextHopNodeID` = `node[i+1]`.\n       - `OutInterfaceID` = interface to `node[i+1]`.\n\n4. **Determine scheduling time**:\n   - For this minimal version, assume “schedule at **now**”:\n     - `When = Clock.Now()` (or at most a small lead time).\n   - Rely on idempotent state helpers so re-sending the same `UpdateBeam` / `SetRoute` is safe if the scheduler runs repeatedly.\n\n### 5. Integrate ServiceRequest scanning into Scheduler’s main loop\n\n- Extend your Scheduler’s main loop (`Run`, `Tick`, or equivalent) to:\n\n  1. Fetch the current set of ServiceRequests.\n  2. For each SR:\n     - Call `findAnyPath(SrcNodeID, DstNodeID)`.\n     - If path exists:\n       - For each hop, build `ScheduledAction`s as described above.\n       - Use `CDPIServer.SendCreateEntry(agentID, action)` to push them to the appropriate agents.\n\n- Basic deduplication policy (minimal but sufficient):\n\n  - Option A (simplest):\n    - Trust ScenarioState helpers to be idempotent:\n      - Re-schedule `UpdateBeam` / `SetRoute` at “now” each time the loop runs.\n      - Beam updates / route installs that are already present should not cause harmful duplicates.\n  - Option B (slightly more careful, still simple):\n    - Track a small in-memory map inside Scheduler:\n      - Keyed by `(ServiceRequestID, hopIdx)` or `(SrcNodeID, DstNodeID, hopNodes)`.\n      - Skip re-scheduling if an identical action is already “known”.\n    - This map can be reset on scenario restart; no persistence needed.\n\n- Ensure this logic is **guarded** by a configuration flag if you already have one for experimental features; otherwise, keep it always-on for now.\n\n### 6. Add focused unit tests for ServiceRequest-aware scheduling\n\nUnder something like `internal/sbi/controller/scheduler_servicerequest_test.go`:\n\n- Use an in-memory `ScenarioState` with a very small topology:\n\n  - Example:\n    - Nodes: A, B, C.\n    - Links: A–B, B–C (or just A–B for single hop).\n    - One ServiceRequest: `Src = A`, `Dst = C` (multi-hop) or `Src = A`, `Dst = B` (single hop).\n\n- Provide a fake `CDPIServer` handle:\n\n  - Implements `SendCreateEntry` by:\n    - Recording `(agentID, ScheduledAction)` calls into a slice for assertions.\n\n- Test cases:\n\n  1. **Path exists → actions emitted**:\n     - Given a linear topology A–B–C and SR A→C:\n       - Run one scheduler tick.\n       - Assert:\n         - `findAnyPath` produces `[A, B, C]`.\n         - `SendCreateEntry` was called at least for hops:\n           - A→B (`ScheduledUpdateBeam` + `ScheduledSetRoute`).\n           - B→C (`ScheduledUpdateBeam` + `ScheduledSetRoute`).\n\n  2. **No path → no actions**:\n     - SR between nodes that are not connected in the graph.\n     - Assert that no actions are emitted.\n\n  3. **Idempotence across multiple ticks**:\n     - Run the scheduler tick twice with the same SR and topology.\n     - Assert either:\n       - ScenarioState’s route/install helpers prevent duplicate routes (if you can inspect state), or\n       - The number and structure of `ScheduledAction`s across ticks is consistent with your deduplication approach (e.g. same actions, but they are idempotent).\n\n- These tests can be lightweight; deeper end-to-end validation is covered in Chunk 10/11.\n\n## Acceptance criteria\n\n- ServiceRequest listing:\n  - `ScenarioState` (or equivalent) exposes a method to list current ServiceRequests, used by the scheduler.\n  - Listing is concurrency-safe and returns enough data to reason about src/dst nodes.\n\n- Connectivity graph and path search:\n  - A simple graph abstraction exists that:\n    - Is built from potential/usable links in `ScenarioState`.\n    - Supports BFS-style path search between two nodes.\n  - `findAnyPath(src, dst)` (or equivalent) returns:\n    - A non-nil node path when connectivity exists.\n    - `nil` when no path exists.\n\n- Path → actions mapping:\n  - For each hop on a chosen path, the scheduler can:\n    - Resolve link/interface information from `ScenarioState`.\n    - Construct `ScheduledUpdateBeam` and `ScheduledSetRoute` actions targeting the appropriate agent/node.\n  - Actions are scheduled at `Clock.Now()` (or a simple lead time) and emitted via `CDPIServer.SendCreateEntry`.\n\n- Scheduler integration:\n  - Scheduler’s main loop:\n    - Iterates over active ServiceRequests.\n    - Attempts to find a path between src/dst for each.\n    - Emits appropriate scheduled actions when a path exists.\n  - Behavior is intentionally naive:\n    - First-found path only.\n    - No advanced QoS or optimization.\n    - Accepts mild duplication as long as state changes are idempotent.\n\n- Tests:\n  - Unit tests cover at least:\n    - SR with a valid path → `SendCreateEntry` is called with plausible actions.\n    - SR with no path → no actions are emitted.\n    - Multiple scheduler ticks with a stable SR/topology behave consistently (no pathological explosion of actions).\n  - `go test ./...` passes, including new tests.\n\n- Repository health:\n  - `go build ./...` passes with all new scheduler code.\n  - The new ServiceRequest-aware scheduling logic compiles cleanly and does not introduce import cycles or layering violations.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  }
]
