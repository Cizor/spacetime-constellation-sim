[
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/159",
    "id": 3711942964,
    "node_id": "I_kwDOQfMfks7dP8E0",
    "number": 159,
    "title": "[Scope 4][Chunk 8] Epic – Basic scheduling engine and controller logic",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9738572054,
        "node_id": "LA_kwDOQfMfks8AAAACRHbRFg",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:tracking",
        "name": "type:tracking",
        "color": "4eaa16",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139839,
        "node_id": "LA_kwDOQfMfks8AAAACRw-bvw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:8-sbi-controller-logic",
        "name": "chunk:8-sbi-controller-logic",
        "color": "de618e",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T17:28:39Z",
    "updated_at": "2025-12-09T17:28:45Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 2,
      "completed": 0,
      "percent_completed": 0
    },
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the time you reach **Chunk 8**, you have:\n\n- A working **CDPI server** (controller side) that:\n  - Accepts agent `Hello`, `Reset`, and `Response` messages.\n  - Can send `CreateEntryRequest`, `DeleteEntryRequest`, and `FinalizeRequest` to agents.\n- A **simulated Agent** per node that:\n  - Maintains a local schedule of `ScheduledAction`s.\n  - Executes beam and route actions at the right **simulation time** using `EventScheduler`.\n  - Updates `ScenarioState` via helpers like:\n    - `ApplyBeamUpdate(...)`\n    - `ApplyBeamDelete(...)`\n    - `InstallRoute(...)`\n    - `RemoveRoute(...)`\n- A **simulation clock + EventScheduler** abstraction that:\n  - Runs on sim time (Scope 1/2 time controller).\n  - Supports scheduling callbacks at a `time.Time`.\n- A **Telemetry path** (Chunk 6) that:\n  - Lets agents periodically push `InterfaceMetrics` via `TelemetryService.ExportMetrics`.\n  - Stores metrics in `TelemetryState` on the controller.\n\nWhat you **do not** have yet is the *controller-side scheduling engine* that:\n\n- Decides *what* to tell agents to do and *when*, based on:\n  - Link visibility / potential links from Scope 2.\n  - Static routing needs.\n  - (Optionally) `ServiceRequest`s from Scope 3.\n- Emits `ScheduledAction`s and converts them into CDPI `CreateEntryRequest`/`DeleteEntryRequest`.\n- Tracks enough context to later reason about schedule decisions.\n\nFor **Scope 4**, the goal is not optimization, but **mechanism**:\n\n- A simple, deterministic scheduling engine that:\n  - Uses existing connectivity information to schedule **beam on/off**.\n  - Installs and removes **static routes** for single-hop connectivity.\n  - Optionally reacts to `ServiceRequest`s in a minimal way.\n- This forms the backbone for more sophisticated scheduling in future scopes.\n\nThis epic covers that **basic scheduling engine** and its integration with CDPI and `ScenarioState`.\n\n---\n\n## Goal\n\nDeliver a first-cut **controller-side scheduling engine** that:\n\n- Knows how to:\n  - Inspect `ScenarioState` and link visibility / potential links.\n  - Plan simple `ScheduledAction`s over a simulation horizon:\n    - `UpdateBeam` / `DeleteBeam`.\n    - `SetRoute` / `DeleteRoute`.\n- Emits these actions through the existing CDPI server:\n  - Uses `SendCreateEntry` / `SendDeleteEntry` / `SendFinalize` helpers.\n  - Targets per-agent schedules (per-node).\n- Is **simple and deterministic**:\n  - No complex optimization or load-balancing.\n  - Single path, single-hop routing is enough.\n- Has unit tests to validate its behavior in isolation:\n  - Using fake `ScenarioState`, fake clock, and fake CDPI.\n\n---\n\n## Where to look\n\nCore state and connectivity:\n\n- `sim/state` or `internal/simstate`:\n  - `ScenarioState`:\n    - Nodes and interfaces.\n    - Links and their geometric / RF feasibility.\n    - Active vs potential links (from Scope 4 Chunk 0).\n  - Any helpers that surface:\n    - “Potential links” or “links in view”.\n    - Time-intervals for link visibility.\n\nSBI controller side:\n\n- `internal/sbi/controller`:\n  - CDPI server implementation (Chunk 5), e.g.:\n\n        type CDPIServer struct {\n            scheduling.UnimplementedControlDataPlaneInterfaceServer\n\n            State    *simstate.ScenarioState\n            Clock    sbi.EventScheduler\n            // agent handles, outgoing channels, etc.\n        }\n\n  - Methods to send scheduling commands:\n\n        func (s *CDPIServer) SendCreateEntry(agentID string, action *ScheduledAction) error\n        func (s *CDPIServer) SendDeleteEntry(agentID, entryID string) error\n        func (s *CDPIServer) SendFinalize(agentID string, cutoff time.Time) error\n\nScheduling domain model:\n\n- `internal/sbi` or equivalent, where you previously defined:\n\n      type ScheduledActionType int\n\n      const (\n          ScheduledUpdateBeam ScheduledActionType = iota\n          ScheduledDeleteBeam\n          ScheduledSetRoute\n          ScheduledDeleteRoute\n          ScheduledSetSrPolicy\n          ScheduledDeleteSrPolicy\n      )\n\n      type ScheduledAction struct {\n          EntryID   string\n          When      time.Time\n          Type      ScheduledActionType\n          RequestID string\n          SeqNo     int64\n          Token     string\n          Beam      *BeamSpec\n          Route     *RouteEntry\n          SrPolicy  *SrPolicySpec\n      }\n\nService requests (optional minimal integration):\n\n- NBI / core model for `ServiceRequest`:\n  - Source node ID, destination node ID.\n  - Possibly QoS hints (but can be ignored in Scope 4).\n- Any helper that enumerates active `ServiceRequest`s.\n\nSearch terms:\n\n- `ScenarioState`\n- `PotentialLink`, `LinkInView`, `LinkIntervals`\n- `CDPIServer`\n- `ScheduledAction`\n- `ServiceRequest`\n\n---\n\n## Tasks\n\n### 8.1 – Introduce Scheduler component\n\nCreate a controller-side scheduler struct under `internal/sbi/controller`, for example:\n\n- File:\n\n      internal/sbi/controller/scheduler.go\n\n- Type:\n\n      type Scheduler struct {\n          State *simstate.ScenarioState\n          Clock sbi.EventScheduler\n          CDPI  *CDPIServer\n\n          // Optional:\n          Horizon         time.Duration   // how far ahead to schedule\n          BeamLeadTime    time.Duration   // how early to turn beams on\n          Logger          Logger          // optional logging interface\n      }\n\nKey responsibilities:\n\n- Periodically or on-demand:\n  - Inspect `ScenarioState` for potential links.\n  - Decide when to schedule **beam on/off** and **static routes**.\n  - Call `CDPIServer.SendCreateEntry(...)` / `SendDeleteEntry(...)` to push entries to agents.\n\nMethods (initial sketch):\n\n- A main entry point for one-shot scheduling:\n\n      func (s *Scheduler) PlanInitialSchedule(ctx context.Context) error\n\n- Optionally, a periodic rescheduler:\n\n      func (s *Scheduler) Start(ctx context.Context) error\n      func (s *Scheduler) Stop()\n\nFor Scope 4, it’s acceptable if you only implement a **one-shot** planner that:\n\n- Runs once at scenario start.\n- Pre-populates the schedule for the whole horizon.\n\n### 8.2 – Link-driven beam scheduling\n\nImplement link-driven **beam scheduling** logic:\n\n- For each potential link in `ScenarioState`:\n  - Determine its periods of visibility `[T_on, T_off]`.\n  - Choose which **node/agent** is responsible for controlling that link (e.g. satellite side).\n  - Plan:\n\n    - `UpdateBeam` at `T_on - BeamLeadTime` (clamped to `>= Clock.Now()`).\n    - `DeleteBeam` at `T_off`.\n\nDesign notes (keep simple for Scope 4):\n\n- Use existing connectivity / visibility outputs from Scope 2:\n  - If you already have a function like `GetLinkVisibility(linkID)` returning intervals, use that.\n  - Otherwise, add a minimal helper that:\n    - For each link, computes a small set of intervals where it’s “in view”.\n- Assume:\n  - Controller won’t schedule impossible beams (visibility + geometry checked by Scope 2).\n  - No contention between beams for now (e.g. no multi-beam power budget modeling).\n\nImplementation sketch (conceptual):\n\n- Inside `PlanInitialSchedule`:\n\n      now := s.Clock.Now()\n      horizonEnd := now.Add(s.Horizon)\n\n      for each potentialLink in State.PotentialLinks():\n          intervals := State.GetLinkVisibilityIntervals(potentialLink.ID, now, horizonEnd)\n          agentID := s.agentForLink(potentialLink)\n\n          for each interval [T_on, T_off] in intervals:\n              onTime  := max(T_on.Add(-s.BeamLeadTime), now)\n              offTime := T_off\n\n              // Create UpdateBeam action\n              actionOn := &ScheduledAction{\n                  EntryID:   s.newEntryID(),\n                  When:      onTime,\n                  Type:      ScheduledUpdateBeam,\n                  Beam:      s.buildBeamSpec(potentialLink),\n              }\n\n              // Create DeleteBeam action\n              actionOff := &ScheduledAction{\n                  EntryID:   s.newEntryID(),\n                  When:      offTime,\n                  Type:      ScheduledDeleteBeam,\n                  Beam:      s.buildBeamSpec(potentialLink),\n              }\n\n              _ = s.CDPI.SendCreateEntry(agentID, actionOn)\n              _ = s.CDPI.SendCreateEntry(agentID, actionOff)\n\nNotes:\n\n- `newEntryID()` can be a simple monotonic counter or UUID-like helper.\n- `buildBeamSpec` translates link/antenna info into `BeamSpec` used by agents.\n- Error handling can be simple:\n  - Log and continue for failed `SendCreateEntry`.\n\n### 8.3 – Static routes for single-hop paths\n\nAdd **static routing** support for single-hop connectivity:\n\n- For each scheduled link interval `[T_on, T_off]` between nodes A and B:\n  - At `T_on`:\n    - Schedule `SetRoute` on A pointing to B.\n    - Schedule `SetRoute` on B pointing to A (bidirectional).\n  - At `T_off`:\n    - Schedule `DeleteRoute` on both nodes.\n\nRoute representation (already defined from earlier chunks, but summarized):\n\n- Internal type:\n\n      type RouteEntry struct {\n          DestinationCIDR string\n          NextHopNodeID   string\n          OutInterfaceID  string\n      }\n\nDecisions for Scope 4:\n\n- Destination:\n  - For simple single-hop, you can use:\n    - `DestinationCIDR` = “/32” host route for the neighbor node’s address space, or\n    - A synthetic per-node prefix if you already model node-level prefixes.\n- Outgoing interface:\n  - Derived from the link endpoint facing the neighbor.\n\nImplementation sketch:\n\n- For each link interval `[T_on, T_off]` with endpoints `(nodeA, ifaceA)` and `(nodeB, ifaceB)`:\n\n      // At T_on: install routes on both nodes.\n      routeA := &RouteEntry{\n          DestinationCIDR: s.destForNode(nodeB),\n          NextHopNodeID:   nodeB,\n          OutInterfaceID:  ifaceA,\n      }\n\n      routeB := &RouteEntry{\n          DestinationCIDR: s.destForNode(nodeA),\n          NextHopNodeID:   nodeA,\n          OutInterfaceID:  ifaceB,\n      }\n\n      // Scheduled actions (SetRoute)\n      setRouteA := &ScheduledAction{\n          EntryID: s.newEntryID(),\n          When:    T_on,\n          Type:    ScheduledSetRoute,\n          Route:   routeA,\n      }\n\n      setRouteB := &ScheduledAction{\n          EntryID: s.newEntryID(),\n          When:    T_on,\n          Type:    ScheduledSetRoute,\n          Route:   routeB,\n      }\n\n      // At T_off: delete routes\n      delRouteA := &ScheduledAction{\n          EntryID: s.newEntryID(),\n          When:    T_off,\n          Type:    ScheduledDeleteRoute,\n          Route:   routeA,\n      }\n\n      delRouteB := &ScheduledAction{\n          EntryID: s.newEntryID(),\n          When:    T_off,\n          Type:    ScheduledDeleteRoute,\n          Route:   routeB,\n      }\n\n      // Choose agentID for each node (e.g. agent per node)\n      agentA := s.agentForNode(nodeA)\n      agentB := s.agentForNode(nodeB)\n\n      _ = s.CDPI.SendCreateEntry(agentA, setRouteA)\n      _ = s.CDPI.SendCreateEntry(agentB, setRouteB)\n      _ = s.CDPI.SendCreateEntry(agentA, delRouteA)\n      _ = s.CDPI.SendCreateEntry(agentB, delRouteB)\n\nKeep it simple:\n\n- No multi-hop routing or path search yet.\n- No SR policies here; SR remains stubbed.\n\n### 8.4 – Minimal ServiceRequest-aware scheduling (optional but recommended)\n\nIntroduce a **minimal** use of `ServiceRequest`s:\n\n- For each active `ServiceRequest` (src → dst):\n  - Try to find *any* path through currently **potential** links.\n  - If a path exists “now”:\n    - Ensure the first-hop link’s beams and routes are scheduled.\n    - Optionally bias scheduling decisions to keep that path active.\n\nDesign constraints for Scope 4:\n\n- Path-finding can be primitive:\n  - Simple BFS over a graph where edges represent potential links.\n  - Ignore capacity, QoS, or interference constraints.\n- You can:\n  - Re-use link visibility intervals from 8.2.\n  - For the epic, it’s enough to:\n    - Document that minimal `ServiceRequest` use is present.\n    - Provide a single simple test that a `ServiceRequest` can trigger some scheduled actions.\n\nImplementation concept:\n\n- Add a helper on `Scheduler`:\n\n      func (s *Scheduler) computePathForServiceRequest(sr *model.ServiceRequest) []*Link {\n          // BFS over potential links; return 0 or more links as a path.\n      }\n\n- When planning schedule:\n  - For each `ServiceRequest`:\n    - Call `computePathForServiceRequest`.\n    - If non-empty path:\n      - Ensure that for each link in the path, you schedule:\n        - `UpdateBeam` / `DeleteBeam` as in 8.2.\n        - `SetRoute` / `DeleteRoute` as in 8.3.\n\nFor the epic, you can keep this very limited and refine later in non-epic issues.\n\n---\n\n## Acceptance criteria\n\n- **Scheduler component:**\n  - A `Scheduler` struct exists in `internal/sbi/controller` with:\n    - References to `ScenarioState`, `EventScheduler`, and `CDPIServer`.\n    - Configurable horizon and beam lead time (or sensible defaults).\n  - Provides at least:\n    - `PlanInitialSchedule(ctx)` that:\n      - Walks potential links.\n      - Emits scheduled actions via CDPI.\n\n- **Beam scheduling:**\n  - For each potential link with visibility intervals `[T_on, T_off]`:\n    - `ScheduledUpdateBeam` actions are created at `T_on - BeamLeadTime` (clamped).\n    - `ScheduledDeleteBeam` actions are created at `T_off`.\n    - Actions are sent to the correct agent via `CDPIServer`.\n  - Errors from CDPI sends are logged but do not crash the scheduler.\n\n- **Static route scheduling (single-hop):**\n  - For each link interval `[T_on, T_off]`, routes are:\n    - Installed at `T_on` on both endpoints via `ScheduledSetRoute`.\n    - Removed at `T_off` via `ScheduledDeleteRoute`.\n  - Routes include:\n    - `DestinationCIDR` that identifies the peer node.\n    - `NextHopNodeID` set to the peer node.\n    - `OutInterfaceID` set to the interface pointing at the peer.\n\n- **ServiceRequest integration (minimal):**\n  - Scheduler is aware of `ServiceRequest`s:\n    - Either uses them to bias scheduling, or\n    - At minimum, has a code path that can:\n      - Discover a path for a `ServiceRequest`.\n      - Schedule some beams/routes when a path exists.\n  - One or more unit tests demonstrate that:\n    - Adding a `ServiceRequest` can lead to scheduled actions.\n\n- **Tests:**\n  - Unit tests for the scheduler in `internal/sbi/controller/scheduler_test.go` (or similar):\n    - Use fake `ScenarioState` to define:\n      - A small set of nodes, interfaces, and potential links.\n      - Known visibility intervals `[T_on, T_off]`.\n    - Use a fake `CDPIServer` / stub that records calls to:\n      - `SendCreateEntry`.\n    - Verify:\n      - Correct number and types of `ScheduledAction`s are emitted.\n      - `When` times match expected `T_on`, `T_off`, and `BeamLeadTime` behavior.\n      - Routes are installed/removed as expected.\n    - At least one test covers `ServiceRequest`-driven scheduling (even if minimal).\n\n- **Repository health:**\n  - `go build ./...` passes with the new scheduler code.\n  - `go test ./...` passes, including new scheduler tests.\n  - No changes required to NBI/Scope 3 public API; this is internal SBI/controller logic only.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/160",
    "id": 3711945645,
    "node_id": "I_kwDOQfMfks7dP8ut",
    "number": 160,
    "title": "[Scope 4][Chunk 8] Implement link-driven beam scheduling in controller Scheduler",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139839,
        "node_id": "LA_kwDOQfMfks8AAAACRw-bvw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:8-sbi-controller-logic",
        "name": "chunk:8-sbi-controller-logic",
        "color": "de618e",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T17:29:23Z",
    "updated_at": "2025-12-09T17:38:38Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy this point in **Chunk 8** you should have:\n\n- A **Scheduler** skeleton on the controller side (from the previous Chunk 8 issue), e.g.:\n\n    type Scheduler struct {\n        State *simstate.ScenarioState\n        Clock sbi.EventScheduler\n        CDPI  *CDPIServer\n    }\n\n- A working **CDPIServer** (from Chunk 5) that can:\n  - Track connected agents (`AgentHandle` per agent).\n  - Send `CreateEntryRequest` / `DeleteEntryRequest` / `FinalizeRequest` via:\n    - `SendCreateEntry(agentID string, action *ScheduledAction) error`\n    - `SendDeleteEntry(agentID, entryID string) error`\n    - etc.\n- An internal **ScheduledAction** model from Chunk 2:\n\n    type ScheduledActionType int\n\n    const (\n        ScheduledUpdateBeam ScheduledActionType = iota\n        ScheduledDeleteBeam\n        // ...\n    )\n\n    type ScheduledAction struct {\n        EntryID  string\n        When     time.Time\n        Type     ScheduledActionType\n        RequestID string\n        SeqNo     int64\n        Token     string\n\n        Beam   *BeamSpec\n        Route  *RouteEntry\n        // ...\n    }\n\n- Scenario / connectivity state (Scope 2 + ScenarioState) that knows:\n  - Which links are **potential** (geometrically / RF feasible).\n  - For each potential link, when it is **“in view”** over the simulation horizon (or at least can answer “in view at time T?”).\n\nFrom the Scope 4 plan, **link-driven beam scheduling** is the first “real” scheduling behaviour:\n\n- For each potential link:\n  - Determine its **visibility intervals** `[T_on, T_off]`.\n  - Schedule:\n    - A `ScheduledUpdateBeam` at `T_on` (possibly with a small lead time).\n    - A `ScheduledDeleteBeam` at `T_off`.\n- Attach these actions to the correct **agent** (typically the satellite / node that owns the transmitting interface).\n\nThis issue fills in that logic inside the Scheduler, leaving routes and ServiceRequest-aware scheduling to later issues.\n\n## Goal\n\nImplement a first-pass, **link-driven beam scheduling** strategy:\n\n- For each potential link in `ScenarioState`:\n  - Discover one or more **in-view intervals** `[T_on, T_off]` over the scenario time window.\n  - For each interval, create:\n    - A `ScheduledUpdateBeam` action at `T_on` (or `T_on - leadTime`, clamped to ≥ now).\n    - A `ScheduledDeleteBeam` action at `T_off`.\n- For each action:\n  - Populate an internal `ScheduledAction` with a `BeamSpec` that:\n    - Identifies the **source node** and **source interface**.\n    - Identifies the **target node/interface** or other target representation consistent with your model.\n  - Send the action to the correct agent via `CDPIServer.SendCreateEntry`.\n- Ensure:\n  - Scheduling is **idempotent** (avoid duplicating actions on repeated runs).\n  - Only links with a clear agent/endpoint mapping are scheduled.\n- Add **unit tests** that:\n  - Use a small in-memory `ScenarioState` with one or two links and known visibility windows.\n  - Verify the expected `ScheduledUpdateBeam` / `ScheduledDeleteBeam` calls are emitted with the right times and endpoints.\n\n## Where to look\n\nKey places in the codebase:\n\n- Scheduler (previous Chunk 8 issue):\n\n    internal/sbi/controller/scheduler.go\n\n  Expect something like:\n\n    type Scheduler struct {\n        State *simstate.ScenarioState\n        Clock sbi.EventScheduler\n        CDPI  *CDPIServer\n        // possibly: logger, config, etc.\n    }\n\n    func (s *Scheduler) RunInitialSchedule(ctx context.Context) error {\n        // currently stubbed / partial\n    }\n\n- Scenario / connectivity model:\n\n  - The types that represent links and their state, e.g.:\n\n        type NetworkLink struct {\n            LinkID     string\n            SrcNodeID  string\n            SrcIfID    string\n            DstNodeID  string\n            DstIfID    string\n            // fields for geometry / visibility / bandwidth / etc.\n        }\n\n  - The APIs that can answer either:\n    - “List all potential links”, and/or:\n    - “Give me visibility windows for this link”.\n\n  Search terms:\n\n  - `NetworkLink`\n  - `PotentialLinks`, `AllLinks`, `GetLinks`\n  - `Visibility`, `InView`, `TimeWindow`, `LinkWindow`\n  - Anything under `sim/state` or `internal/simstate` that looks like “link windows”.\n\n- Agent / SBI mapping:\n\n  - How you map **nodes → agents**:\n    - e.g. Node config that carries an `AgentID`.\n    - CDPIServer’s `agents` map keyed by `AgentID`.\n  - You may need a helper to find the agent for a given node ID.\n\n## Tasks\n\n### 1. Decide scheduler entrypoint and time horizon\n\n- In `Scheduler`, define an entrypoint for link-driven scheduling, e.g.:\n\n      func (s *Scheduler) ScheduleLinkBeams(ctx context.Context) error\n\n- Decide **time horizon** for planning:\n  - For now, a simple approach:\n    - Use the current sim time `now := s.Clock.Now()`.\n    - Use a fixed horizon duration (e.g. `horizon := now.Add(1 * time.Hour)`), or\n    - Use scenario metadata (start/end time) if available.\n- This method will:\n  - Enumerate potential links.\n  - Compute visibility windows `[T_on, T_off]` within `[now, horizon]`.\n  - Emit `ScheduledAction`s via CDPI.\n\nDesign note: Later you can decide whether this runs once at scenario start, or periodically. For now, keep it **single-shot** and idempotent.\n\n### 2. Enumerate potential links and visibility windows\n\n- Add / use a helper on `ScenarioState` to iterate links:\n\n      func (s *ScenarioState) AllPotentialLinks() []NetworkLink\n\n  or similar. If you already have a function, reuse it; otherwise:\n\n  - Implement a simple enumerator that:\n    - Returns all links that are “potential” (i.e. geometrically possible).\n    - Ignores purely logical / disabled links.\n\n- For each link, derive visibility intervals within `[now, horizon]`. Options:\n\n  - If you already have a “link windows” API (ideal):\n\n        func (s *ScenarioState) LinkWindows(linkID string, start, end time.Time) []LinkWindow\n\n        type LinkWindow struct {\n            Start time.Time\n            End   time.Time\n        }\n\n  - If you only have an “is in view at time T?” function:\n    - For this chunk, you can:\n      - Sample the horizon at a coarse step (e.g. every 10–30 seconds).\n      - Detect transitions in `inView` (false→true = `T_on`, true→false = `T_off`).\n    - Keep this simple and document it; you can refine later.\n\n- For this issue, assume **at least one** reasonable path to derive `[T_on, T_off]` per link, and prefer a simple helper that can be reused by tests.\n\n### 3. Map links to agents and construct BeamSpec\n\n- Define / reuse an internal `BeamSpec` type, e.g.:\n\n      type BeamSpec struct {\n          LinkID      string\n          SrcNodeID   string\n          SrcIfID     string\n          DstNodeID   string\n          DstIfID     string\n          // Optional RF params: frequency, EIRP, etc.\n      }\n\n- Add a helper to construct a `BeamSpec` from a `NetworkLink`:\n\n      func BeamSpecFromLink(l *NetworkLink) *BeamSpec\n\n- Decide **which side owns the beam** (which agent to schedule):\n\n  - For now, pick a simple rule:\n    - e.g. beam is controlled by the satellite / LEO node; or\n    - always by `SrcNodeID` if that’s how you model it.\n\n- Implement a small mapping helper:\n\n      func (s *Scheduler) agentIDForNode(nodeID string) (string, bool)\n\n  That looks up the controller’s `CDPI` server’s `agents` map or some registry to map `nodeID → agentID`.\n\n  - If no agent can be found:\n    - Log and **skip** scheduling for that link.\n\n### 4. Create and send ScheduledActions via CDPI\n\n- For each visibility interval `[T_on, T_off]` and resolved `agentID`:\n\n  - Define a small **lead time** constant (optional), e.g.:\n\n        const defaultBeamLeadTime = 0\n\n    (You can start with zero lead, then later change to a small positive duration if needed.)\n\n  - Compute:\n\n        now := s.Clock.Now()\n        onTime  := T_on.Add(-defaultBeamLeadTime)\n        if onTime.Before(now) {\n            onTime = now\n        }\n\n  - Create two `ScheduledAction`s:\n\n    - `ScheduledUpdateBeam` at `onTime`.\n    - `ScheduledDeleteBeam` at `T_off`.\n\n  - Fill fields:\n\n        actionOn := &ScheduledAction{\n            EntryID:   fmt.Sprintf(\"link:%s:on:%d\", link.LinkID, T_on.UnixNano()),\n            When:      onTime,\n            Type:      ScheduledUpdateBeam,\n            Beam:      BeamSpecFromLink(&link),\n            // RequestID / SeqNo / Token can be filled in CDPI or here,\n            // depending on how you structured responsibilities.\n        }\n\n        actionOff := &ScheduledAction{\n            EntryID:   fmt.Sprintf(\"link:%s:off:%d\", link.LinkID, T_off.UnixNano()),\n            When:      T_off,\n            Type:      ScheduledDeleteBeam,\n            Beam:      BeamSpecFromLink(&link),\n        }\n\n  - Call:\n\n        if err := s.CDPI.SendCreateEntry(agentID, actionOn); err != nil {\n            // log and continue\n        }\n\n        if err := s.CDPI.SendCreateEntry(agentID, actionOff); err != nil {\n            // log and continue\n        }\n\nDesign notes:\n\n- **Idempotency**:\n  - Option 1 (simple): assume `ScheduleLinkBeams` is only called once.\n  - Option 2 (better): keep a set of `EntryID`s you’ve already scheduled and skip duplicates.\n- **Token / seqno**:\n  - If CDPI handles tokens/seqno, you can let `SendCreateEntry` fill these.\n  - If not, add a simple per-agent seqno generator on the Scheduler/CDPI side.\n\n### 5. Wire link scheduling into Scheduler lifecycle\n\n- Update your Scheduler entrypoint (from previous issue), e.g.:\n\n      func (s *Scheduler) RunInitialSchedule(ctx context.Context) error {\n          // 1. Link-driven beam schedule\n          if err := s.ScheduleLinkBeams(ctx); err != nil {\n              return err\n          }\n\n          // 2. (Later) route and ServiceRequest-aware scheduling, in subsequent issues.\n          return nil\n      }\n\n- Make sure your **scenario startup flow** (Chunk 9 later) calls `RunInitialSchedule` after:\n\n  - `ScenarioState` is constructed.\n  - `CDPIServer` is created.\n  - Agents are connected and have sent `Hello`, so `agents` map is populated.\n\nFor this issue, you only need to ensure the Scheduler exposes the right method; full wiring is covered in Chunk 9.\n\n### 6. Unit tests for link-driven scheduling\n\nCreate `internal/sbi/controller/scheduler_links_test.go` (or similar).\n\nTest setup:\n\n- Use a small **fake / in-memory** `ScenarioState`:\n\n  - Contains:\n    - Two nodes: `node-A`, `node-B`.\n    - One potential link:\n\n          linkID = \"link-ab\"\n          SrcNodeID = \"node-A\"\n          SrcIfID   = \"if-A\"\n          DstNodeID = \"node-B\"\n          DstIfID   = \"if-B\"\n\n  - Visibility windows:\n\n    - For simplicity, a single window `[T_on, T_off]`, e.g.:\n\n          T0 := time.Unix(1000, 0)\n          T_on  := T0.Add(10 * time.Second)\n          T_off := T0.Add(20 * time.Second)\n\n- Fake `EventScheduler`:\n\n  - Implements `Now()` returning `T0`.\n  - `Schedule` / `Cancel` may be unused in this specific test, but you can provide no-ops.\n\n- Fake `CDPIServer`:\n\n  - Replace `SendCreateEntry` with a test stub that records:\n    - `agentID`\n    - `ScheduledAction`\n\n- Provide a simple mapping `nodeID → agentID` inside Scheduler/CDPI so that:\n  - `node-A` maps to `agent-1`.\n\nTest cases:\n\n1. Single link, single window → two actions\n\n   - Call `scheduler.ScheduleLinkBeams(ctx)`.\n   - Assert:\n     - `SendCreateEntry` was called exactly **twice**:\n       - Once with `Type == ScheduledUpdateBeam`, `When == onTime (T_on or clamped)`.\n       - Once with `Type == ScheduledDeleteBeam`, `When == T_off`.\n     - `Beam` fields:\n       - `LinkID == \"link-ab\"`.\n       - `SrcNodeID == \"node-A\"`, `SrcIfID == \"if-A\"`.\n       - `DstNodeID == \"node-B\"`, `DstIfID == \"if-B\"`.\n\n2. Window partially in the past → onTime clamped\n\n   - Set `Now()` to `T_on + 5s`.\n   - Expect:\n     - `ScheduledUpdateBeam.When == Now()` (clamped).\n     - `ScheduledDeleteBeam.When == T_off` (unchanged).\n\n3. Multiple windows or links\n\n   - Add:\n     - A second window for the same link, or\n     - Another link.\n   - Assert:\n     - Each window produces a pair of actions.\n     - Total count and basic fields match expectations.\n\n4. No agent mapping → link skipped\n\n   - Remove agent mapping for `node-A`.\n   - Call `ScheduleLinkBeams`.\n   - Assert:\n     - `SendCreateEntry` is never called.\n     - No panics.\n\n5. Idempotency (if implemented)\n\n   - Call `ScheduleLinkBeams` twice with the same state.\n   - If you implemented an “already scheduled” guard:\n     - Assert each expected action is only sent once.\n\n## Acceptance criteria\n\n- Scheduler:\n\n  - Exposes a method like `ScheduleLinkBeams(ctx context.Context) error`.\n  - Uses `ScenarioState` + connectivity info to:\n    - Enumerate potential links.\n    - Derive visibility intervals `[T_on, T_off]` within a planning horizon.\n\n- Link-driven beam scheduling:\n\n  - For each visibility interval:\n    - Creates a `ScheduledUpdateBeam` at `max(T_on - leadTime, now)`.\n    - Creates a `ScheduledDeleteBeam` at `T_off`.\n  - Constructs `BeamSpec` from the underlying `NetworkLink`.\n  - Resolves the owning agent (node → agent mapping).\n  - For each action, calls `CDPIServer.SendCreateEntry(agentID, action)`.\n\n- Behavioural guarantees:\n\n  - Links without a valid agent mapping are safely skipped (no panics).\n  - Times are computed in **sim time** using `EventScheduler.Now()`.\n  - Any lead-time clamping logic is documented and unit-tested.\n\n- Tests:\n\n  - `scheduler_links_test.go` (or equivalent) includes tests that:\n    - Verify **two actions per window** (on/off) with expected fields.\n    - Verify clamping of `onTime` when `T_on` is in the past.\n    - Verify behaviour with multiple links/windows.\n    - Verify safe behaviour when agent mapping is missing.\n    - (Optional) Verify idempotency if you chose to implement it.\n  - All new tests pass with `go test ./...`.\n\n- Repository health:\n\n  - `go build ./...` passes with the new Scheduler link-scheduling code.\n  - `go test ./...` passes, including new link-driven scheduling tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/160/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/162",
    "id": 3712045376,
    "node_id": "I_kwDOQfMfks7dQVFA",
    "number": 162,
    "title": "[Scope 4][Chunk 8] Add static single-hop routes based on link availability in Scheduler",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139839,
        "node_id": "LA_kwDOQfMfks8AAAACRw-bvw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:8-sbi-controller-logic",
        "name": "chunk:8-sbi-controller-logic",
        "color": "de618e",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T17:58:27Z",
    "updated_at": "2025-12-09T17:58:27Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/159",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the time you reach this issue in **Chunk 8**, you should already have:\n\n- A controller-side **Scheduler** type (non-gRPC) under something like `internal/sbi/controller`:\n  - Holds a reference to `ScenarioState`.\n  - Has access to an `EventScheduler` / sim clock.\n  - Knows how to talk to `CDPIServer` via helpers like `SendCreateEntry` / `SendDeleteEntry`.\n- A basic **link-driven beam scheduling** implementation:\n  - For each potential link with known \"in view\" intervals `[T_on, T_off]`, the scheduler:\n    - Schedules an `UpdateBeam` `CreateEntry` near `T_on` for the satellite-side agent.\n    - Schedules a `DeleteBeam` `CreateEntry` at `T_off`.\n\nWhat’s still missing is the **static routing side** described in the Scope 4 plan:\n\n- When a single-hop link is \"on\", both endpoints should have simple **static routes** installed pointing at each other.\n- When the link goes \"off\", those routes should be removed.\n- This is still **mechanism only** (no multi-hop pathfinding yet) but gives basic reachability for later scopes.\n\nThis issue teaches the Scheduler to generate **SetRoute/DeleteRoute** scheduled actions in sync with link on/off intervals, using the existing per-node routing table support from Scope 4 Chunk 0 / 2.\n\n## Goal\n\nExtend the controller Scheduler so that for each single-hop link interval `[T_on, T_off]`:\n\n- At (or just before) `T_on`:\n  - Schedule `SetRoute` actions on **both endpoints**:\n    - Node A: add route `dest=B` via interface to B.\n    - Node B: add route `dest=A` via interface to A.\n- At `T_off`:\n  - Schedule `DeleteRoute` for the corresponding `dest=B` / `dest=A` entries.\n\nKey properties:\n\n- Uses the existing route table model (e.g. `RouteEntry`) and ScenarioState helpers `InstallRoute` / `RemoveRoute`.\n- Uses `ScheduledAction.Type` values like `ScheduledSetRoute` / `ScheduledDeleteRoute`.\n- Uses the same **per-agent CDPI flow** as beam scheduling (`CreateEntryRequest` containing SetRoute/DeleteRoute payloads).\n- Keeps logic simple and deterministic; it does **not** attempt multi-hop routing yet (that comes with ServiceRequests in a later issue).\n\n## Where to look\n\nScheduler implementation (Chunk 8 base):\n\n- Likely under:\n\n      internal/sbi/controller/scheduler.go\n\n- Expected types:\n\n      type Scheduler struct {\n          State *simstate.ScenarioState\n          Clock sbi.EventScheduler\n          CDPI  *CDPIServer\n          // maybe other fields (config, logger, etc.)\n      }\n\n- Existing methods (from prior Chunk 8 issue):\n\n      func (s *Scheduler) ScheduleBeamsForLinks(...) { ... }\n      func (s *Scheduler) RunOnce(...) error\n      // or similar entrypoints\n\nScheduledAction model (Chunk 2 definitions):\n\n- Somewhere under `internal/sbi` or `internal/sbi/types`:\n\n      type ScheduledActionType int\n\n      const (\n          ScheduledUpdateBeam ScheduledActionType = iota\n          ScheduledDeleteBeam\n          ScheduledSetRoute\n          ScheduledDeleteRoute\n          ScheduledSetSrPolicy\n          ScheduledDeleteSrPolicy\n      )\n\n      type ScheduledAction struct {\n          EntryID   string\n          When      time.Time\n          Type      ScheduledActionType\n          RequestID string\n          SeqNo     int64\n          Token     string\n          Beam      *BeamSpec\n          Route     *RouteEntry\n          SrPolicy  *SrPolicySpec\n      }\n\nRoute model and ScenarioState helpers (Chunks 0 / 2):\n\n- Per-node routing fields, e.g. in `model.NetworkNode` or similar:\n\n      type RouteEntry struct {\n          DestinationCIDR string\n          NextHopNodeID   string\n          OutInterfaceID  string\n      }\n\n- ScenarioState routing helpers:\n\n      func (s *ScenarioState) InstallRoute(nodeID string, route RouteEntry) error\n      func (s *ScenarioState) RemoveRoute(nodeID, destCIDR string) error\n\nLink model / connectivity info:\n\n- Types that represent links and their endpoints, something like:\n\n      type NetworkLink struct {\n          LinkID      string\n          NodeAID     string\n          InterfaceA  string\n          NodeBID     string\n          InterfaceB  string\n          // maybe capacity, in-view intervals, etc.\n      }\n\n- Helper(s) to get **in-view intervals** or potential links:\n\n      func (s *ScenarioState) ListPotentialLinks() []NetworkLink\n      func (s *ScenarioState) GetLinkVisibility(linkID string) []VisibilityInterval\n\n      type VisibilityInterval struct {\n          Start time.Time\n          End   time.Time\n      }\n\nCDPI helpers (from Chunk 5):\n\n- On `CDPIServer` (or a helper wrapping it):\n\n      func (s *CDPIServer) SendCreateEntry(agentID string, action *ScheduledAction) error\n      func (s *CDPIServer) SendDeleteEntry(agentID, entryID string) error\n\nYou’ll reuse these to push route-related `CreateEntryRequest`s to agents.\n\nSearch terms:\n\n- `Scheduler struct`\n- `ScheduledAction`\n- `ScheduledSetRoute`\n- `RouteEntry`\n- `InstallRoute`\n- `NetworkLink`\n- `VisibilityInterval`\n\n## Tasks\n\n### 1. Decide how to derive route destinations for single-hop links\n\nYou need a consistent rule for what **destination** each static route should represent.\n\nA simple scheme:\n\n- For each link between nodes A and B:\n  - On node A, install a route `dest=B` with a `DestinationCIDR` that represents \"node B\".\n  - On node B, install a route `dest=A`.\n\nDepending on your model, this might be:\n\n- Just a synthetic `/32` or `/128` per node:\n\n      route := RouteEntry{\n          DestinationCIDR: fmt.Sprintf(\"%s/32\", destNodeIP), // or some node ID → CIDR mapping\n          NextHopNodeID:   destNodeID,\n          OutInterfaceID:  ifaceID,\n      }\n\n- Or, if you don’t have real IP addresses yet:\n\n  - Use a placeholder `DestinationCIDR` that your routing layer understands (e.g. `\"node:B\"`), but be consistent.\n\n**Design note:** For Scope 4, it’s acceptable to:\n\n- Treat `DestinationCIDR` as an opaque key like `\"node:<ID>\"`.\n- Document that more realistic IP/route semantics come in later scopes.\n\n### 2. Extend Scheduler to compute route actions per link interval\n\nIn your Scheduler (e.g. `scheduler.go`), add logic alongside beam scheduling:\n\n- For each potential link with visibility intervals `[T_on, T_off]`:\n  - Determine:\n    - `nodeA`, `ifaceA` and `nodeB`, `ifaceB`.\n    - Agent IDs for those nodes (you may have a mapping `nodeID → agentID`).\n\nThen:\n\n- At `T_on`:\n  - Construct two `ScheduledAction`s:\n    - `ScheduledSetRoute` for node A (agent for A) with a `RouteEntry` to B.\n    - `ScheduledSetRoute` for node B (agent for B) with a `RouteEntry` to A.\n- At `T_off`:\n  - Construct two `ScheduledDeleteRoute` actions mirroring those entries.\n\nPseudo-structure:\n\n- You might add a helper:\n\n      func (s *Scheduler) scheduleRoutesForLink(link NetworkLink, intervals []VisibilityInterval) error\n\nwhich:\n\n- Iterates intervals.\n- For each interval, calls lower-level helpers:\n\n      s.scheduleSetRouteAt(T_on, nodeA, nodeB, ifaceA)\n      s.scheduleSetRouteAt(T_on, nodeB, nodeA, ifaceB)\n      s.scheduleDeleteRouteAt(T_off, nodeA, nodeB)\n      s.scheduleDeleteRouteAt(T_off, nodeB, nodeA)\n\n### 3. Build ScheduledAction payloads for SetRoute/DeleteRoute\n\nImplement small helpers on Scheduler (or a separate builder) to construct route actions:\n\n- For SetRoute:\n\n      func (s *Scheduler) newSetRouteAction(\n          when time.Time,\n          nodeID string,\n          destNodeID string,\n          outInterfaceID string,\n      ) *ScheduledAction\n\nInternals:\n\n- Build a `RouteEntry`:\n\n      route := &RouteEntry{\n          DestinationCIDR: s.destCIDRForNode(destNodeID), // helper from Task 1\n          NextHopNodeID:   destNodeID,\n          OutInterfaceID:  outInterfaceID,\n      }\n\n- Create a `ScheduledAction`:\n\n      &ScheduledAction{\n          EntryID:   s.nextEntryID(), // helper to generate unique IDs\n          When:      when,\n          Type:      ScheduledSetRoute,\n          RequestID: s.nextRequestID(nodeID),\n          SeqNo:     s.nextSeqNo(nodeID),\n          Token:     s.currentTokenForNode(nodeID),\n          Route:     route,\n      }\n\n- For DeleteRoute:\n\n      func (s *Scheduler) newDeleteRouteAction(\n          when time.Time,\n          nodeID string,\n          destNodeID string,\n      ) *ScheduledAction\n\nInternals:\n\n- You can either:\n  - Repeat the same `RouteEntry` fields (for completeness), or\n  - Only send the destination in the proto and let the agent look up and delete it.\n\nFor Scope 4, a simple approach is:\n\n- Have `ScheduledAction.Route` filled with the same `DestinationCIDR` you used for SetRoute, and ignore `NextHopNodeID`/`OutInterfaceID` on delete.\n\n### 4. Wire route actions into CDPI and agents\n\nEnsure that:\n\n- Controller-side:\n\n  - `Scheduler` uses `CDPIServer.SendCreateEntry(agentID, action)` to push:\n    - `ScheduledSetRoute` / `ScheduledDeleteRoute` actions to the right agent.\n  - If you don’t yet have a clean `nodeID → agentID` mapping helper, introduce one in the controller layer.\n\n- Agent-side (from earlier chunks):\n\n  - `Agent.execute(action *ScheduledAction)` must already have branches:\n\n        case ScheduledSetRoute:\n            // call ScenarioState.InstallRoute(nodeID, *action.Route)\n        case ScheduledDeleteRoute:\n            // call ScenarioState.RemoveRoute(nodeID, action.Route.DestinationCIDR)\n\n  - If these branches don’t exist yet, add them now (but keep behavior simple).\n\n### 5. Optional: small unit tests for route scheduling\n\nWhile **Chunk 10** will have broader test coverage, add at least a minimal test for this behavior now (to avoid regressions):\n\n- In `internal/sbi/controller/scheduler_routes_test.go` or similar:\n\n  - Use an in-memory `ScenarioState` with:\n    - Two nodes (A, B).\n    - One link with endpoints (A:ifA, B:ifB).\n    - One visibility interval `[T_on, T_off]`.\n  - Use a fake `CDPIServer` that records `SendCreateEntry` calls.\n  - Run a single scheduling pass (e.g. `Scheduler.RunOnce()` or a specific `ScheduleRoutesForLinks()`).\n\n- Assert:\n\n  - Exactly **four** route actions are created:\n    - 2 × `ScheduledSetRoute` (one per node at/on T_on).\n    - 2 × `ScheduledDeleteRoute` (one per node at T_off).\n  - Each `SetRoute` action:\n    - Has `Route.NextHopNodeID` set to the peer node.\n    - Has `Route.OutInterfaceID` set to the correct interface.\n  - Each `DeleteRoute` action:\n    - Targets the same destination CIDR as the corresponding `SetRoute`.\n\n## Acceptance criteria\n\n- Scheduler behavior:\n\n  - For each potential link with visibility interval `[T_on, T_off]`:\n    - Scheduler generates **two** `ScheduledSetRoute` actions at/on `T_on` (one per endpoint).\n    - Scheduler generates **two** `ScheduledDeleteRoute` actions at `T_off` (one per endpoint).\n  - Route actions are sent via CDPI to the appropriate agents.\n\n- Route modeling:\n\n  - A consistent `DestinationCIDR` scheme is defined for \"node-to-node\" routes.\n  - `RouteEntry.NextHopNodeID` and `RouteEntry.OutInterfaceID` are filled correctly for single-hop routes.\n  - ScenarioState’s `InstallRoute` / `RemoveRoute` helpers are used for all route mutations.\n\n- Agent integration:\n\n  - Agent `execute` logic handles:\n    - `ScheduledSetRoute` by calling `InstallRoute` on ScenarioState.\n    - `ScheduledDeleteRoute` by calling `RemoveRoute` with the correct destination key.\n  - No panics or inconsistent state when route actions are executed multiple times or out of order (idempotent enough for Scope 4).\n\n- Tests (at least minimal):\n\n  - A Scheduler-focused test (or tests) verifies:\n    - That for a simple topology with one link and one visibility interval, the expected `ScheduledSetRoute` / `ScheduledDeleteRoute` actions are produced.\n    - That actions contain correct `nodeID`, `destination`, and `outInterfaceID` for both endpoints.\n\n- Repository health:\n\n  - `go build ./...` passes after adding route scheduling code.\n  - `go test ./...` passes, including the new route scheduling tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/162/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/163",
    "id": 3712061147,
    "node_id": "I_kwDOQfMfks7dQY7b",
    "number": 163,
    "title": "[Scope 4][Chunk 8] Implement minimal ServiceRequest-aware scheduling in controller Scheduler",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737889453,
        "node_id": "LA_kwDOQfMfks8AAAACRGxmrQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:3-nbi",
        "name": "scope:3-nbi",
        "color": "913db1",
        "default": false,
        "description": ""
      },
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139839,
        "node_id": "LA_kwDOQfMfks8AAAACRw-bvw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:8-sbi-controller-logic",
        "name": "chunk:8-sbi-controller-logic",
        "color": "de618e",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T18:03:48Z",
    "updated_at": "2025-12-09T18:03:48Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the time this issue is picked up, the Scope 4 controller-side scheduling work in Chunk 8 should have:\n\n- A `Scheduler` component under something like `internal/sbi/controller` that:\n  - Has access to `ScenarioState` and an `EventScheduler`-style clock.\n  - Can emit `ScheduledAction`s via `CDPIServer.SendCreateEntry(...)`.\n- Link-driven scheduling (or at least the structure for it), where:\n  - Potential links from Scope 2 can be turned into `ScheduledUpdateBeam` / `ScheduledDeleteBeam` actions over a simple [T_on, T_off] interval.\n- Basic beam/route application helpers on `ScenarioState` (from earlier chunks):\n  - `ApplyBeamUpdate(...)`, `ApplyBeamDelete(...)`.\n  - `InstallRoute(...)`, `RemoveRoute(...)`.\n- A Scope 3 `ServiceRequest` model (from Chunk 6) integrated into `ScenarioState`, e.g.:\n  - Ability to list active service requests.\n  - Access to each request’s src/dst node IDs and simple QoS hints.\n\nWhat the scheduler **still** does not do is use ServiceRequests as a driver for what to schedule:\n\n- There is no logic that says “if an SR between `src` and `dst` exists and there is connectivity, schedule beams/routes along a path”.\n- Link-driven scheduling may already bring links up/down over time, but:\n  - No simple path search is performed based on the “connectivity graph”.\n  - No static routes (`SetRoute`/`DeleteRoute`) are installed specifically to satisfy ServiceRequests.\n\nThis issue adds a **minimal ServiceRequest-aware scheduling layer** on top of the existing scheduler logic:\n\n- No optimization.\n- No fairness or multi-request conflict resolution.\n- Just: “if there is an available path **now**, issue `UpdateBeam` and `SetRoute` actions along it”.\n\n## Goal\n\nIntroduce minimal ServiceRequest-aware behavior in the controller `Scheduler`:\n\n- For each active ServiceRequest:\n  - Periodically look for **any** available path between `SrcNodeID` and `DstNodeID` over currently potential/active links.\n  - If a path is found:\n    - Schedule `ScheduledUpdateBeam` actions (if not already present) along the first-hop / relevant links.\n    - Schedule `ScheduledSetRoute` actions along the path so src/dst have static routes installed.\n- Keep the behavior intentionally naive:\n  - Single-path, first-found BFS (or similar) is enough.\n  - No attempt to compute multiple candidate paths or optimize QoS.\n- Add shape/structure in the scheduler so that later, more sophisticated policies can replace this logic without refactoring the entire controller.\n\n## Where to look\n\nServiceRequest model and storage:\n\n- NBI / model types from Scope 3 + Chunk 6, for example:\n  - `internal/nbi/types` for mapping, and:\n  - `internal/sim/state` / `sim/state` for how ServiceRequests are stored:\n    - Listing service requests (e.g. `ListServiceRequests()` or equivalent).\n    - Accessing `SrcNodeID`, `DstNodeID`, priority, etc.\n\nScheduler and CDPI integration (Chunk 8):\n\n- Scheduler type under something like:\n\n      internal/sbi/controller/scheduler.go\n\n  - Look for a struct similar to:\n\n      type Scheduler struct {\n          State *simstate.ScenarioState\n          Clock EventScheduler\n          CDPI  *CDPIServer\n          // ... any existing fields (loggers, config, etc.)\n      }\n\n- Any existing `RunOnce` / `Tick` / `Recompute` methods where link-driven actions are computed.\n\nScenarioState / connectivity graph:\n\n- Functions/helpers that expose:\n  - Nodes and interfaces.\n  - Links and their end-points.\n  - Whether links are currently potential/usable (even if not yet “active”).\n- Look for:\n  - `GetAllLinks()`, `GetPotentialLinks()`, `GetNode(id)`, `GetInterfacesForNode(id)` or similar.\n  - Any existing graph-style helpers from Scope 2/3 you can reuse.\n\nSearch terms:\n\n- `ServiceRequest`\n- `Scheduler struct`\n- `ScheduledAction`\n- `InstallRoute`, `ApplyBeamUpdate`\n- `CDPIServer.SendCreateEntry`\n\n## Tasks\n\n### 1. Expose a minimal ServiceRequest listing API on ScenarioState (if missing)\n\n- If not already present, add a read-only helper on `ScenarioState` such as:\n\n      func (s *ScenarioState) ListServiceRequests() []*model.ServiceRequest\n\n  or an equivalent method returning a slice/map of current SRs.\n\n- The helper should be:\n  - Concurrency-safe, following existing `ScenarioState` locking patterns.\n  - Returning a copy/snapshot (or clearly documented if returning internal pointers).\n\n- Ensure each `ServiceRequest` exposes at least:\n  - `SrcNodeID string`\n  - `DstNodeID string`\n  - Optionally, `Priority`, `FlowRequirements`, etc. (for future tuning, but not required for this minimal pass).\n\n### 2. Build a simple connectivity graph helper\n\nImplement a small helper (either as methods on Scheduler or a dedicated package) to derive a graph of currently usable links:\n\n- A straightforward in-memory representation is enough, e.g.:\n\n      type Graph struct {\n          Adj map[string][]string // NodeID -> neighbor NodeIDs\n      }\n\n- Populate adjacency using potential or active links from `ScenarioState`:\n\n      // Pseudocode:\n      links := state.ListPotentialLinks() // adjust to actual API\n      for _, link := range links {\n          // Each link has endpoints A and B.\n          graph.AddUndirectedEdge(link.NodeAID, link.NodeBID)\n      }\n\n- Decisions for this minimal pass:\n  - It’s OK to treat “potential” links as edges; future work can constrain this using “in view” windows or active flags.\n  - For single-hop SRs, the path will just be one edge; for multi-hop, BFS will naturally find a chain.\n\n### 3. Implement a tiny path search: BFS over the node graph\n\nAdd a helper on Scheduler (or Graph) to compute a single path between two nodes:\n\n- Example signature:\n\n      func (s *Scheduler) findAnyPath(srcNodeID, dstNodeID string) []string\n\n  where the result is a list of node IDs `[src, ..., dst]`.\n\n- Implementation details:\n\n  - Use BFS:\n\n        - Start from `srcNodeID`.\n        - Use a queue, `visited` map, and `prev` map.\n        - Stop when `dstNodeID` is reached.\n        - Reconstruct path by walking `prev` backwards.\n\n  - Return `nil` if no path is found.\n\n- Keep the logic simple and well-isolated so it can be swapped later for more sophisticated routing.\n\n### 4. Map paths to scheduled actions (beams + routes)\n\nOnce you can compute a `[node0, node1, ..., nodeN]` path:\n\n1. **Decide which agent “owns” each hop**:\n   - For a minimal implementation, treat the first node in each hop `(node[i], node[i+1])` as the agent that will execute `UpdateBeam` / `SetRoute`.\n   - This is consistent with the rest of Scope 4 where “satellite-side node” or one endpoint is chosen as the controlling agent.\n\n2. **Resolve link/interface IDs**:\n   - Use ScenarioState helpers to find the link + interface connecting `node[i]` → `node[i+1]`:\n     - e.g. `state.FindLinkBetween(nodeA, nodeB)` or manual scan if not present.\n   - Extract:\n     - The interface ID on `node[i]`.\n     - Any link metadata (e.g. `LinkID`, capacity) needed to populate `BeamSpec` or `RouteEntry`.\n\n3. **Build `ScheduledAction`s**:\n   - For each hop:\n     - A `ScheduledUpdateBeam` using a `BeamSpec` targeted from `node[i]` to `node[i+1]`.\n     - A `ScheduledSetRoute` on `node[i]` such that:\n       - `DestinationCIDR` represents traffic destined to `node[i+1]` (or the final `dst`), as per your existing `RouteEntry` assumptions.\n       - `NextHopNodeID` = `node[i+1]`.\n       - `OutInterfaceID` = interface to `node[i+1]`.\n\n4. **Determine scheduling time**:\n   - For this minimal version, assume “schedule at **now**”:\n     - `When = Clock.Now()` (or at most a small lead time).\n   - Rely on idempotent state helpers so re-sending the same `UpdateBeam` / `SetRoute` is safe if the scheduler runs repeatedly.\n\n### 5. Integrate ServiceRequest scanning into Scheduler’s main loop\n\n- Extend your Scheduler’s main loop (`Run`, `Tick`, or equivalent) to:\n\n  1. Fetch the current set of ServiceRequests.\n  2. For each SR:\n     - Call `findAnyPath(SrcNodeID, DstNodeID)`.\n     - If path exists:\n       - For each hop, build `ScheduledAction`s as described above.\n       - Use `CDPIServer.SendCreateEntry(agentID, action)` to push them to the appropriate agents.\n\n- Basic deduplication policy (minimal but sufficient):\n\n  - Option A (simplest):\n    - Trust ScenarioState helpers to be idempotent:\n      - Re-schedule `UpdateBeam` / `SetRoute` at “now” each time the loop runs.\n      - Beam updates / route installs that are already present should not cause harmful duplicates.\n  - Option B (slightly more careful, still simple):\n    - Track a small in-memory map inside Scheduler:\n      - Keyed by `(ServiceRequestID, hopIdx)` or `(SrcNodeID, DstNodeID, hopNodes)`.\n      - Skip re-scheduling if an identical action is already “known”.\n    - This map can be reset on scenario restart; no persistence needed.\n\n- Ensure this logic is **guarded** by a configuration flag if you already have one for experimental features; otherwise, keep it always-on for now.\n\n### 6. Add focused unit tests for ServiceRequest-aware scheduling\n\nUnder something like `internal/sbi/controller/scheduler_servicerequest_test.go`:\n\n- Use an in-memory `ScenarioState` with a very small topology:\n\n  - Example:\n    - Nodes: A, B, C.\n    - Links: A–B, B–C (or just A–B for single hop).\n    - One ServiceRequest: `Src = A`, `Dst = C` (multi-hop) or `Src = A`, `Dst = B` (single hop).\n\n- Provide a fake `CDPIServer` handle:\n\n  - Implements `SendCreateEntry` by:\n    - Recording `(agentID, ScheduledAction)` calls into a slice for assertions.\n\n- Test cases:\n\n  1. **Path exists → actions emitted**:\n     - Given a linear topology A–B–C and SR A→C:\n       - Run one scheduler tick.\n       - Assert:\n         - `findAnyPath` produces `[A, B, C]`.\n         - `SendCreateEntry` was called at least for hops:\n           - A→B (`ScheduledUpdateBeam` + `ScheduledSetRoute`).\n           - B→C (`ScheduledUpdateBeam` + `ScheduledSetRoute`).\n\n  2. **No path → no actions**:\n     - SR between nodes that are not connected in the graph.\n     - Assert that no actions are emitted.\n\n  3. **Idempotence across multiple ticks**:\n     - Run the scheduler tick twice with the same SR and topology.\n     - Assert either:\n       - ScenarioState’s route/install helpers prevent duplicate routes (if you can inspect state), or\n       - The number and structure of `ScheduledAction`s across ticks is consistent with your deduplication approach (e.g. same actions, but they are idempotent).\n\n- These tests can be lightweight; deeper end-to-end validation is covered in Chunk 10/11.\n\n## Acceptance criteria\n\n- ServiceRequest listing:\n  - `ScenarioState` (or equivalent) exposes a method to list current ServiceRequests, used by the scheduler.\n  - Listing is concurrency-safe and returns enough data to reason about src/dst nodes.\n\n- Connectivity graph and path search:\n  - A simple graph abstraction exists that:\n    - Is built from potential/usable links in `ScenarioState`.\n    - Supports BFS-style path search between two nodes.\n  - `findAnyPath(src, dst)` (or equivalent) returns:\n    - A non-nil node path when connectivity exists.\n    - `nil` when no path exists.\n\n- Path → actions mapping:\n  - For each hop on a chosen path, the scheduler can:\n    - Resolve link/interface information from `ScenarioState`.\n    - Construct `ScheduledUpdateBeam` and `ScheduledSetRoute` actions targeting the appropriate agent/node.\n  - Actions are scheduled at `Clock.Now()` (or a simple lead time) and emitted via `CDPIServer.SendCreateEntry`.\n\n- Scheduler integration:\n  - Scheduler’s main loop:\n    - Iterates over active ServiceRequests.\n    - Attempts to find a path between src/dst for each.\n    - Emits appropriate scheduled actions when a path exists.\n  - Behavior is intentionally naive:\n    - First-found path only.\n    - No advanced QoS or optimization.\n    - Accepts mild duplication as long as state changes are idempotent.\n\n- Tests:\n  - Unit tests cover at least:\n    - SR with a valid path → `SendCreateEntry` is called with plausible actions.\n    - SR with no path → no actions are emitted.\n    - Multiple scheduler ticks with a stable SR/topology behave consistently (no pathological explosion of actions).\n  - `go test ./...` passes, including new tests.\n\n- Repository health:\n  - `go build ./...` passes with all new scheduler code.\n  - The new ServiceRequest-aware scheduling logic compiles cleanly and does not introduce import cycles or layering violations.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/163/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/165",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/165/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/165/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/165/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/165",
    "id": 3712243993,
    "node_id": "I_kwDOQfMfks7dRFkZ",
    "number": 165,
    "title": "[Scope 4][Chunk 9] Epic – Wire scheduler, agents & telemetry into scenario lifecycle",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9738572054,
        "node_id": "LA_kwDOQfMfks8AAAACRHbRFg",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:tracking",
        "name": "type:tracking",
        "color": "4eaa16",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782140626,
        "node_id": "LA_kwDOQfMfks8AAAACRw-e0g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:9-sbi-integration",
        "name": "chunk:9-sbi-integration",
        "color": "b9eda4",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T18:57:02Z",
    "updated_at": "2025-12-09T18:57:02Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 2,
      "completed": 0,
      "percent_completed": 0
    },
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the end of **Chunk 8**, you have the core SBI mechanisms in place:\n\n- **CDPI (scheduling) path:**\n  - A `CDPIServer` that:\n    - Accepts agent `ReceiveRequests` streams (Hello/Reset/Response).\n    - Tracks per-agent handles and outgoing scheduling messages.\n  - A per-node `Agent` that:\n    - Maintains a local schedule of `ScheduledAction`s.\n    - Uses `EventScheduler` to execute actions at the right sim time.\n    - Applies beams/routes into `ScenarioState`.\n- **Scheduler logic (controller side):**\n  - A `Scheduler` component that:\n    - Inspects `ScenarioState` and potential links.\n    - Emits `ScheduledAction`s via `CDPIServer.SendCreateEntry` / `SendDeleteEntry`.\n    - (Optionally) uses `ServiceRequest`s to schedule minimal connectivity.\n- **Telemetry path:**\n  - `TelemetryState` and `TelemetryServer` implementing `ExportMetrics`.\n  - Agents with a telemetry loop:\n    - Derive per-interface metrics via `deriveInterfaceState` and `ScenarioState`.\n    - Periodically call `TelemetryService.ExportMetrics` using **sim time**.\n\nWhat’s still missing is **full integration** into the normal **scenario lifecycle**:\n\n- When a scenario is created/loaded via NBI, SBI components should spin up automatically.\n- When the sim clock advances, **EventScheduler** callbacks should run.\n- Agents and scheduler should start and stop with the scenario.\n- Telemetry and CDPI services should be registered on the in-process gRPC server used by the simulator.\n\nThis epic wires all of that together so SBI becomes a **first-class part of a normal run**, not just a set of isolated components.\n\n## Goal\n\nProvide an integrated, production-ready SBI wiring so that:\n\n- When a scenario is loaded:\n  - `ScenarioState` is constructed.\n  - CDPI, telemetry, scheduler, and per-node agents are created and started.\n- During the simulation run:\n  - The sim clock advances.\n  - `EventScheduler` runs due events.\n  - Agents execute scheduled actions and emit telemetry.\n- On shutdown:\n  - Agents and scheduler are cleanly stopped.\n- A small set of config flags controls SBI enablement and telemetry interval.\n\nAt the end of this epic, **running the simulator with SBI enabled** should “just work” without additional ad-hoc wiring.\n\n## Where to look\n\nScenario and sim lifecycle:\n\n- The code that currently coordinates a run, e.g.:\n  - `cmd/simulator/main.go` (or similar).\n  - A `runner`/`engine` package under `sim/` or `internal/sim/...`.\n- The place where:\n  - `ScenarioState` is constructed from NBI/inputs.\n  - The time controller / sim clock is created and advanced.\n\nSBI components (from previous chunks):\n\n- CDPI server:\n  - `internal/sbi/controller/cdpi_server.go` (or equivalent).\n- Scheduler:\n  - `internal/sbi/controller/scheduler.go`.\n- Agent:\n  - `internal/sbi/agent/agent.go`.\n- Telemetry:\n  - `internal/sbi/telemetry_server.go` and `TelemetryState`.\n\nTime and scheduling:\n\n- Sim clock / time controller (Scope 1–2):\n  - `timectrl` or equivalent package.\n- Event scheduler:\n  - `internal/sbi/event_scheduler.go` and `FakeEventScheduler` in tests.\n\ngRPC server:\n\n- Wherever the **NBI** server is registered:\n  - Typically `internal/nbi/server.go` and gRPC bootstrap code.\n- You will register:\n  - `ControlDataPlaneInterfaceServer`.\n  - `TelemetryServiceServer` alongside NBI services.\n\nSearch terms:\n\n- `ScenarioState` construction\n- `RunScenario`, `StartSimulation`, or similar\n- `grpc.NewServer`\n- `EventScheduler` implementation\n- `Agent struct`, `CDPIServer`, `TelemetryServer`\n\n## Tasks\n\n### 1. Introduce an SBI runtime/options struct\n\nDefine a small struct to hold SBI runtime dependencies and configuration, e.g.:\n\n- Location: `internal/sbi/runtime.go` or a similar integration-focused file.\n\n  type SBIRuntimeOptions struct {\n      EnableSBI         bool\n      TelemetryInterval time.Duration\n  }\n\n  type SBIRuntime struct {\n      State      *simstate.ScenarioState\n      Clock      sbi.EventScheduler\n      Telemetry  *TelemetryState\n      TelemetryS *TelemetryServer\n      CDPI       *CDPIServer\n      Scheduler  *Scheduler\n      Agents     map[string]*agent.Agent\n\n      opts SBIRuntimeOptions\n  }\n\nResponsibilities:\n\n- Encapsulate:\n  - Creation of telemetry/CDPI/scheduler/agents.\n  - Registration of SBI servers on the gRPC server.\n  - Start/stop lifecycle for agents and scheduler.\n- Keep sim runner code cleaner by delegating SBI details to `SBIRuntime`.\n\n### 2. Wire SBI into scenario startup\n\nIn the main scenario startup path (e.g. `RunScenario` or equivalent):\n\n1. After `ScenarioState` is constructed and the sim clock is prepared:\n\n   - Construct an `EventScheduler` instance bound to the sim clock:\n     \n         scheduler := sbi.NewEventScheduler(clock)\n\n2. Build the `TelemetryState` and `TelemetryServer`:\n\n   - Example:\n\n         telemetryState := NewTelemetryState()\n         telemetryServer := &TelemetryServer{\n             Telemetry: telemetryState,\n         }\n\n3. Build the `CDPIServer`:\n\n   - Example:\n\n         cdpi := &CDPIServer{\n             State:  scenarioState,\n             Clock:  scheduler,\n             // other fields, maps, etc., per previous chunks\n         }\n\n4. Build the `Scheduler`:\n\n         sched := &Scheduler{\n             State: scenarioState,\n             Clock: scheduler,\n             CDPI:  cdpi,\n         }\n\n5. Create an `SBIRuntime`:\n\n         sbiRuntime := &SBIRuntime{\n             State:      scenarioState,\n             Clock:      scheduler,\n             Telemetry:  telemetryState,\n             TelemetryS: telemetryServer,\n             CDPI:       cdpi,\n             Scheduler:  sched,\n             Agents:     make(map[string]*agent.Agent),\n             opts: SBIRuntimeOptions{\n                 EnableSBI:         true,              // driven by flags/config\n                 TelemetryInterval: time.Second,       // default; overridable\n             },\n         }\n\n6. For each node that should have an agent:\n\n   - Iterate over nodes in `ScenarioState` (e.g. satellites, ground stations).\n   - Construct an `Agent`:\n\n         ag := &agent.Agent{\n             AgentID:          nodeCfg.AgentID, // or derived\n             NodeID:           node.ID,\n             State:            scenarioState,\n             Scheduler:        scheduler,\n             TelemetryClient:  telemetryClientStub, // in-process gRPC client\n             TelemetryInterval: sbiRuntime.opts.TelemetryInterval,\n             // CDPI stream/client wiring handled in Chunk 9 sub-issues\n         }\n\n   - Store in `sbiRuntime.Agents[node.ID] = ag`.\n\n7. Expose a helper on `SBIRuntime`:\n\n   - `func (r *SBIRuntime) Start(ctx context.Context) error`\n   - `func (r *SBIRuntime) Stop()`\n\n   Where `Start`:\n\n   - Registers gRPC servers.\n   - Starts agents (their CDPI streams and telemetry loops).\n   - Optionally kicks the controller `Scheduler` into computing initial schedule.\n\n### 3. Register SBI services on the gRPC server\n\nUpdate the gRPC bootstrap (same place where NBI is registered):\n\n- Once the `grpc.Server` is created:\n\n      grpcServer := grpc.NewServer()\n      // Existing NBI registrations...\n      telemetry.RegisterTelemetryServiceServer(grpcServer, sbiRuntime.TelemetryS)\n      scheduling.RegisterControlDataPlaneInterfaceServer(grpcServer, sbiRuntime.CDPI)\n\nDesign notes:\n\n- For now, SBI and NBI can share the same gRPC server and port.\n- If you already have a listener for NBI, reuse it.\n- Ensure SBI services are ready before agents/clients try to connect.\n\n### 4. Integrate EventScheduler into the main sim loop\n\nEnsure the sim loop drives the `EventScheduler`:\n\n- In the main run loop, where sim time is advanced:\n\n  1. Advance sim clock (existing mechanism):\n\n         clock.AdvanceTo(nextTime) // or equivalent\n\n  2. Run due events in `EventScheduler`:\n\n         scheduler.RunDue()\n\nDesign notes:\n\n- If your `EventScheduler` already listens to the clock internally, make sure the main loop calls a `RunDue()` or equivalent method.\n- The goal is: whenever sim time jumps forward, all scheduled SBI events with `When <= Now()` are executed.\n\n### 5. Add configuration flags / options\n\nIn your CLI or configuration system:\n\n- Add flags such as:\n\n  - `--enable-sbi` (default `true` once stable).\n  - `--telemetry-interval=1s` (sim time).\n\n- Thread them through:\n\n  - From CLI → main → `SBIRuntimeOptions`.\n\nExample:\n\n- If `--enable-sbi=false`:\n\n  - Skip creation/registration of all SBI components.\n  - `SBIRuntime` can be `nil` or a no-op.\n\n- If telemetry interval is provided:\n\n  - Override `TelemetryInterval` for agents.\n\n### 6. Minimal integration tests / smoke tests\n\nAdd a small integration-oriented test (does not need full end-to-end Scope 11 coverage yet):\n\n- New test file, e.g.:\n\n  - `cmd/simulator/sbi_integration_smoke_test.go` or\n  - `internal/sim/sbi_integration_test.go`.\n\nTest ideas:\n\n1. **Scenario with one node and no links:**\n\n   - Start simulator with SBI enabled.\n   - Assert:\n     - `SBIRuntime` is created.\n     - One agent exists for the node.\n     - gRPC server registers both CDPI and Telemetry services (can introspect via reflection or test harness).\n\n2. **Scenario with one potential link:**\n\n   - Ensure scheduler creates at least one `ScheduledAction`.\n   - Advance clock and run scheduler/events.\n   - Assert:\n     - `ScenarioState` shows link becoming active at the expected time.\n\n3. **Telemetry sanity check:**\n\n   - Run sim for a short time with telemetry enabled.\n   - Assert:\n     - `TelemetryState` contains entries for the node/interface.\n\nTests can be relatively coarse, focusing on **wiring correctness** rather than algorithmic detail.\n\n## Acceptance criteria\n\n- **SBI runtime encapsulation:**\n  - `SBIRuntimeOptions` and `SBIRuntime` (or equivalent) exist and encapsulate:\n    - `ScenarioState`, `EventScheduler`, `TelemetryState`, `TelemetryServer`, `CDPIServer`, `Scheduler`, and agents.\n  - `SBIRuntime.Start/Stop` manages SBI component lifecycle.\n\n- **Scenario startup integration:**\n  - When a scenario is loaded:\n    - `EventScheduler` is constructed and bound to sim clock.\n    - `TelemetryState` and `TelemetryServer` are created.\n    - `CDPIServer` and `Scheduler` are created.\n    - Agents are created for all relevant nodes and stored in `SBIRuntime`.\n    - If `EnableSBI` is `true`, `SBIRuntime.Start` is invoked.\n\n- **gRPC wiring:**\n  - `TelemetryServiceServer` and `ControlDataPlaneInterfaceServer` are both registered on the simulator’s gRPC server.\n  - Agents can reach CDPI/Telemetry services in-process during normal runs.\n\n- **EventScheduler integration:**\n  - Main sim loop calls `scheduler.RunDue()` (or equivalent) after advancing sim time, ensuring SBI events execute at the correct simulated times.\n\n- **Configuration:**\n  - Command-line flags or config options exist for:\n    - Enabling/disabling SBI (`--enable-sbi`).\n    - Telemetry interval (`--telemetry-interval`).\n  - When SBI is disabled:\n    - Simulator runs without creating or registering SBI components.\n    - No agent or scheduler routines are started.\n\n- **Smoke tests:**\n  - At least one integration-style test validates:\n    - SBI components are constructed and registered for a simple scenario.\n    - The scheduler can cause at least one scheduled action to be executed when time advances.\n    - Telemetry is stored in `TelemetryState` for a simple case.\n  - All new tests pass via `go test ./...`.\n\n- **Repository health:**\n  - `go build ./...` passes with SBI wiring enabled.\n  - `go test ./...` passes, including new integration/smoke tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/165/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/165/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/167",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/167/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/167/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/167/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/167",
    "id": 3712327838,
    "node_id": "I_kwDOQfMfks7dRaCe",
    "number": 167,
    "title": "[Scope 4][Chunk 9] Wire SBI components into simulator scenario startup",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782140626,
        "node_id": "LA_kwDOQfMfks8AAAACRw-e0g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:9-sbi-integration",
        "name": "chunk:9-sbi-integration",
        "color": "b9eda4",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T19:23:18Z",
    "updated_at": "2025-12-09T19:23:18Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/165",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy this point you have, in earlier Scope 4 chunks:\n\n- SBI domain and plumbing:\n  - `EventScheduler` interface + real/fake implementations (Chunk 3).\n  - `Agent` implementation with:\n    - Local schedule queue and execution.\n    - CDPI stream handling.\n    - Telemetry loop (Chunk 4, 6, 7).\n  - `CDPIServer` implementing `ControlDataPlaneInterface.ReceiveRequests` (Chunk 5).\n  - `TelemetryServer` + `TelemetryState` (Chunk 6).\n  - Controller-side `Scheduler` that:\n    - Inspects `ScenarioState`.\n    - Emits `ScheduledAction`s via CDPI (Chunk 8).\n\n- NBI-based scenario load path:\n  - A way to load/create `ScenarioState` from NBI / config.\n  - A time controller / sim clock driving Scope 1/2 dynamics.\n\nWhat’s missing in **Chunk 9** is wiring all of these SBI components into the **simulator startup** so that:\n\n- When you start a scenario:\n  - SBI servers (CDPI + Telemetry) are created and registered on the gRPC server.\n  - A controller `Scheduler` is instantiated and pointed at `ScenarioState` + `CDPIServer`.\n  - One `Agent` per node is created and started, connected back to CDPI as a client.\n- When the scenario ends or context is cancelled:\n  - Agents are stopped cleanly.\n  - SBI servers can shut down along with the main gRPC server.\n\nThis issue focuses on the **startup wiring** and lifecycle plumbing in the simulator process, without yet adding feature flags or advanced run-loop integration (those come in related Chunk 9 issues).\n\n## Goal\n\n- Extend the simulator’s **scenario startup flow** to:\n  - Construct and own all SBI components:\n    - `EventScheduler` (real implementation).\n    - `TelemetryState` + `TelemetryServer`.\n    - `CDPIServer`.\n    - Controller `Scheduler`.\n    - Per-node `Agent` instances.\n  - Register CDPI and Telemetry services on the gRPC server.\n  - Start agents so they connect to CDPI and begin participating in SBI.\n- Ensure there is a clear ownership / lifecycle:\n  - Where they are created.\n  - How they are wired together.\n  - How they are shut down on scenario stop or context cancel.\n- Keep the wiring **minimal but explicit**, making future refactors (flags, multiple scenarios, etc.) straightforward.\n\n## Where to look\n\nSimulator entrypoints / scenario orchestration:\n\n- CLI / main:\n  - `cmd/simulator/main.go` or equivalent.\n- Scenario runner:\n  - Something like `sim/runner`, `internal/sim/runner.go` or `internal/app/simulator.go`.\n  - Wherever you currently:\n    - Load a scenario via NBI or config.\n    - Build `ScenarioState`.\n    - Create the time controller.\n    - Start the sim run loop.\n\nExisting state and SBI components:\n\n- `ScenarioState`:\n  - Under `internal/sim/state` or `sim/state`.\n  - Where links, nodes, and interfaces are already managed.\n\n- SBI domain:\n  - `internal/sbi/agent`:\n    - `Agent` struct and constructor(s).\n  - `internal/sbi/controller`:\n    - `CDPIServer`.\n    - `Scheduler`.\n\n- Telemetry:\n  - `TelemetryState` and `TelemetryServer`:\n    - Likely under `internal/sbi/telemetry` or `sim/state/telemetry`.\n\ngRPC server wiring:\n\n- Wherever NBI services are registered:\n  - The existing call site for:\n    - `nbi.RegisterScenarioServiceServer(grpcServer, ...)`\n    - Other NBI services.\n- This is where you’ll also register:\n  - `scheduling.RegisterControlDataPlaneInterfaceServer(grpcServer, cdpiServer)`\n  - `telemetry.RegisterTelemetryServiceServer(grpcServer, telemetryServer)`\n\nSearch terms:\n\n- `ScenarioState`\n- `NewScenarioState` / `BuildScenarioState`\n- `grpc.NewServer`\n- `RegisterScenarioServiceServer`\n- `Agent` (under `internal/sbi/agent`)\n- `CDPIServer`\n- `Scheduler` (controller)\n\n## Tasks\n\n### 1. Introduce a SBI wiring helper / struct\n\nCreate a small package or helper that encapsulates SBI wiring, e.g.:\n\n- `internal/sbi/runtime` or similar:\n\n      type SBIRuntime struct {\n          State      *simstate.ScenarioState\n          Clock      sbi.EventScheduler\n          Telemetry  *TelemetryState\n          TelemetryS *TelemetryServer\n          CDPI       *CDPIServer\n          Scheduler  *Scheduler\n          Agents     []*agent.Agent\n\n          // Optional:\n          // shutdown hooks, waitgroups, logger, etc.\n      }\n\nAdd a constructor:\n\n- `func NewSBIRuntime(state *simstate.ScenarioState, clock sbi.EventScheduler, conn *grpc.ClientConn, logger Logger) (*SBIRuntime, error)`\n\n  - Parameters:\n    - `state`: the already-built `ScenarioState`.\n    - `clock`: real `EventScheduler` implementation bound to sim clock.\n    - `conn`: gRPC client connection that agents will use to reach CDPI/Telemetry (if in-process, you may have a special client factory; wire whatever you already use for NBI).\n    - `logger`: optional structured logger.\n\n- Responsibilities inside `NewSBIRuntime`:\n  - Create `TelemetryState` and `TelemetryServer`.\n  - Create `CDPIServer` with:\n    - `State` and `Clock`.\n  - Create controller `Scheduler` with:\n    - `State`, `Clock`, `CDPI`.\n  - Iterate over nodes in `ScenarioState` and:\n    - For each node that should have an agent, create an `Agent` configured with:\n      - `NodeID` and `AgentID`.\n      - Shared `ScenarioState`.\n      - Shared `EventScheduler`.\n      - Telemetry client stub.\n      - CDPI client stub (for the agent’s `ReceiveRequests` stream).\n      - Logger.\n    - Append each agent to `Agents`.\n\n> Design note: If your agents call CDPI over the same in-process gRPC server, you might have to:\n> - Start the server first.\n> - Dial a loopback client connection for agents (`grpc.DialContext(\"localhost:port\", ...)`).\n> This issue can treat that detail as “already available”, or document that it’s done at the caller site.\n\n### 2. Register SBI servers with the gRPC server\n\nIn the main simulator wiring (where you create your gRPC server):\n\n- After `grpc.NewServer()` and before `Serve`:\n\n  - Create or receive the `SBIRuntime`.\n  - Register SBI servers:\n\n        scheduling.RegisterControlDataPlaneInterfaceServer(grpcServer, sbiRuntime.CDPI)\n        telemetry.RegisterTelemetryServiceServer(grpcServer, sbiRuntime.TelemetryS)\n\n  - Keep the existing NBI server registrations unchanged.\n\n- Ensure `SBIRuntime` is reachable from the main run loop:\n  - Store it in a higher-level struct, e.g.:\n\n        type App struct {\n            GRPC      *grpc.Server\n            State     *simstate.ScenarioState\n            Clock     sbi.EventScheduler\n            SBIRuntime *sbi_runtime.SBIRuntime\n            // ...\n        }\n\n### 3. Start agents as part of scenario startup\n\nIn the scenario startup sequence (after building `ScenarioState`, `Clock`, and `SBIRuntime`):\n\n- Start agents:\n\n      func (r *SBIRuntime) StartAgents(ctx context.Context) error {\n          var wg sync.WaitGroup\n          var firstErr error\n          for _, ag := range r.Agents {\n              wg.Add(1)\n              go func(a *agent.Agent) {\n                  defer wg.Done()\n                  if err := a.Start(ctx); err != nil {\n                      // record/log error; for now, capture the first one\n                  }\n              }(ag)\n          }\n          // Optionally return early if you want async behavior,\n          // or wait for a first successful Hello/stream in each Agent.Start.\n          return firstErr\n      }\n\n- Call this from the main scenario runner:\n\n      // 1) Load scenario & build ScenarioState.\n      // 2) Create EventScheduler bound to sim time controller.\n      // 3) Create SBIRuntime (CDPI, Telemetry, Scheduler, Agents).\n      // 4) Register SBI services on the grpc.Server.\n      // 5) Start grpc.Server (if not already running).\n      // 6) Start agents with the scenario context.\n\n- Ensure that:\n  - Agents use a context tied to the scenario lifecycle (cancelled when scenario ends).\n  - Any errors in agent startup are logged and surfaced appropriately.\n\n### 4. Ensure clean shutdown of agents & SBI components\n\nAdd shutdown/cleanup methods on `SBIRuntime`, e.g.:\n\n- `func (r *SBIRuntime) StopAgents()`\n- `func (r *SBIRuntime) Close()`\n\nImplementation sketches:\n\n- `StopAgents`:\n  - If agents hold onto a context cancel function, call it.\n  - Or expose `Agent.Stop()` and call it for each agent.\n- `Close`:\n  - Stop agents.\n  - Optionally flush any outstanding scheduler state.\n  - Let the main app handle `grpcServer.GracefulStop()`.\n\nWire `SBIRuntime.Close()` into your simulator shutdown path:\n\n- On scenario completion or process termination:\n  - Cancel the main context.\n  - Call `SBIRuntime.Close()`.\n  - Stop the gRPC server.\n\n### 5. Minimal integration tests (optional but recommended for this issue)\n\nIf feasible within this issue (or as a follow-up test issue):\n\n- Add a basic integration test under `internal/sim` or `internal/sbi`:\n\n  - Construct:\n    - In-memory `ScenarioState` with a couple of nodes.\n    - Fake `EventScheduler`.\n    - In-process gRPC server.\n  - Wire up `SBIRuntime`.\n  - Start:\n    - gRPC server.\n    - Agents.\n  - Assert that:\n    - Agents connect to CDPI (Hello logged/observed).\n    - Telemetry / CDPI servers are registered and can be dialed.\n\n> If this is too heavy for the current issue, at least add TODOs / comments indicating where dedicated integration tests will live (likely under Chunk 11 “in-process gRPC SBI & Telemetry tests”).\n\n## Acceptance criteria\n\n- SBI runtime wiring:\n  - There is a clear `SBIRuntime` (or similar) construct that:\n    - Owns `TelemetryState` + `TelemetryServer`.\n    - Owns `CDPIServer`.\n    - Owns controller `Scheduler`.\n    - Owns a list of `Agent` instances.\n  - `SBIRuntime` is created during scenario startup with references to:\n    - `ScenarioState`.\n    - Real `EventScheduler`.\n    - gRPC client connection(s) needed for agents.\n\n- gRPC server registration:\n  - `ControlDataPlaneInterface` server (`CDPIServer`) is registered on the simulator’s gRPC server.\n  - `TelemetryService` server (`TelemetryServer`) is registered on the simulator’s gRPC server.\n  - Existing NBI server registration continues to work.\n\n- Agent lifecycle:\n  - On scenario startup:\n    - One `Agent` per relevant node is created and started.\n    - Agents use the shared `EventScheduler` and `ScenarioState`.\n    - Agents are able to connect to the in-process CDPI server via client stubs.\n  - On scenario shutdown:\n    - Agents are stopped cleanly (via context cancel or explicit `Stop()`).\n    - No goroutines are left hanging in steady-state tests.\n\n- Separation of concerns:\n  - Simulator entrypoint / runner is responsible for:\n    - Building `ScenarioState` and time controller.\n    - Creating and owning `SBIRuntime`.\n    - Registering services and starting the gRPC server.\n  - `SBIRuntime` is responsible for:\n    - Constructing SBI components.\n    - Starting and stopping agents.\n\n- Repository health:\n  - `go build ./...` passes after wiring changes.\n  - Existing unit tests continue to pass.\n  - Any new tests added for SBI wiring also pass.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/167/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/167/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/168",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/168/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/168/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/168/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/168",
    "id": 3712344639,
    "node_id": "I_kwDOQfMfks7dReI_",
    "number": 168,
    "title": "[Scope 4][Chunk 9] Implement simulation run loop & EventScheduler integration",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782140626,
        "node_id": "LA_kwDOQfMfks8AAAACRw-e0g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:9-sbi-integration",
        "name": "chunk:9-sbi-integration",
        "color": "b9eda4",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-09T19:28:59Z",
    "updated_at": "2025-12-09T19:28:59Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/165",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy this point in **Scope 4** you have:\n\n- A working **ScenarioState**:\n  - Holds nodes, interfaces, links, service requests, etc.\n- A **real EventScheduler** implementation (Chunk 3):\n  - Backed by the simulation clock / time controller.\n  - Supports `Schedule`, `Cancel`, and `Now`.\n- A set of **Agents** (Chunk 4):\n  - Own local scheduled actions.\n  - Use `EventScheduler` to execute actions at the right sim time.\n  - Emit telemetry via TelemetryService.\n- A **Scheduler** on the controller side (Chunk 8):\n  - Generates `ScheduledAction`s for beams and routes.\n  - Sends them to agents via CDPI.\n- SBI plumbing (Chunks 5–7):\n  - CDPI server and agent streams.\n  - Telemetry service.\n  - Reset / Finalize / tokens semantics.\n\nWhat’s still missing for **Chunk 9** is a *single, coherent run loop* that:\n\n- Drives the **simulation clock** forward.\n- Ensures the **EventScheduler** runs due events at each step.\n- Coordinates:\n  - **Scenario startup** (loading a scenario and wiring SBI).\n  - **Scheduler execution** (when and how often to compute schedules).\n  - **Agent lifecycle** (start/stop tied to scenario lifecycle).\n\nRight now, you might have separate pieces that “can” be wired together, but no concrete, documented **run loop** that a developer can call (e.g. `RunScenario(ctx, cfg)`).\n\nThis issue focuses on the **core run loop integration**:\n- How sim time advances.\n- When EventScheduler events are executed.\n- Where controller Scheduler and agents are invoked.\n\nConfiguration flags (`--enable-sbi`, `--telemetry-interval`, etc.) are handled in a separate Chunk 9 issue.\n\n## Goal\n\nProvide a clear, testable **simulation run loop** that:\n\n- Drives the **sim clock** and **EventScheduler** together.\n- Starts and stops:\n  - CDPI server.\n  - Telemetry server.\n  - Controller Scheduler.\n  - Agents (one per node).\n- Provides a single entry point (or small API) to:\n  - Load a scenario.\n  - Wire SBI components.\n  - Run the simulation until:\n    - A specified sim-time horizon, or\n    - Context cancellation / shutdown.\n\n## Where to look\n\nScenario lifecycle & main entry:\n\n- Existing CLI / main entry points, e.g.:\n  - `cmd/simulator/main.go`\n  - Or a `sim/runner` package.\n- Where scenarios are currently:\n  - Loaded (via NBI or static config).\n  - Bound to `ScenarioState`.\n  - Driven by a time controller / timectrl package.\n\nTime controller & scheduler:\n\n- Time control module, e.g. `timectrl`:\n  - Provides:\n    - `Now()` equiv.\n    - `StepTo(t time.Time)` or a loop over time steps.\n- Event scheduler implementation (Chunk 3), e.g.:\n  - `internal/sbi/eventscheduler.go`\n  - Functions:\n    - `Schedule(at time.Time, f func()) (id string)`\n    - `Cancel(id string)`\n    - `Now() time.Time`\n    - Possibly `RunDue(now time.Time)` or similar.\n\nSBI components:\n\n- CDPI server (Chunk 5), e.g. `internal/sbi/controller/cdpi_server.go`.\n- Telemetry server (Chunk 6), e.g. `internal/sbi/telemetry_server.go`.\n- Controller Scheduler (Chunk 8), e.g. `internal/sbi/controller/scheduler.go`.\n- Agent code (Chunk 4), e.g. `internal/sbi/agent/agent.go`.\n\nSearch terms:\n\n- `ScenarioState`\n- `RunScenario`\n- `EventScheduler`\n- `timectrl`\n- `CDPIServer`\n- `TelemetryServer`\n- `Scheduler struct`\n- `Agent struct`\n\n## Tasks\n\n### 1. Define a central RunScenario API\n\nCreate a new package or file (if not already present), for example:\n\n- `internal/simrunner/runner.go` or\n- `sim/runner.go`\n\nDefine a struct to hold run-time wiring:\n\n- Example:\n\n      type ScenarioRunner struct {\n          State     *simstate.ScenarioState\n          Clock     timectrl.SimClock        // or equivalent interface\n          Scheduler sbi.EventScheduler       // real EventScheduler\n\n          CDPI      *sbi.CDPIServer\n          Telemetry *sbi.TelemetryServer\n          CtrlSched *sbi.Scheduler           // controller scheduling logic\n\n          Agents    []*sbi.Agent\n      }\n\nAdd a constructor or helper:\n\n- Example:\n\n      type RunnerConfig struct {\n          Scenario     *simstate.ScenarioState\n          Clock        timectrl.SimClock\n          Scheduler    sbi.EventScheduler\n          CDPIServer   *sbi.CDPIServer\n          TelemetrySrv *sbi.TelemetryServer\n          Controller   *sbi.Scheduler\n          Agents       []*sbi.Agent\n\n          EndTime      time.Time // sim-time horizon\n      }\n\n      func NewScenarioRunner(cfg RunnerConfig) *ScenarioRunner\n\nDesign notes:\n\n- `RunnerConfig` should be easy to build from `cmd/simulator`.\n- `EndTime` can be:\n  - A fixed horizon, or\n  - Zero-value to mean “run until context cancel”.\n\n### 2. Implement ScenarioRunner.Start / Stop\n\nAdd top-level methods:\n\n- `Start(ctx context.Context) error`\n- `Run(ctx context.Context) error` (or combine Start+Run)\n- `Stop()` / `Shutdown()` to cleanly stop agents and servers.\n\nSuggested flow in `Start`:\n\n1. Start Telemetry and CDPI gRPC servers (or assume they are already bound to a shared server; at minimum ensure they’re configured).\n2. Start each **Agent**:\n   - `for _, a := range r.Agents { go a.Start(ctx) }`\n3. Start the **controller Scheduler**, if it has a loop:\n   - Either:\n     - Provide a `CtrlSched.Start(ctx)` that runs in a goroutine, or\n     - Call a one-shot `CtrlSched.PrimeSchedule()` if you pre-compute schedules.\n4. Ensure **Clock** and **Scheduler** share the same notion of `Now()`.\n\n`Stop` should:\n\n- Cancel the context or call `Agent.Stop()` on each agent.\n- Stop any controller Scheduler loop if it has one.\n- Stop gRPC servers if they are owned here.\n\n### 3. Implement the main run loop (sim time + EventScheduler)\n\nAdd a method like:\n\n- `func (r *ScenarioRunner) RunUntil(ctx context.Context, endTime time.Time) error`\n\nCore logic:\n\n1. Determine initial time:\n\n       now := r.Clock.Now()\n\n2. Loop until end condition:\n\n       for {\n           // Check context cancellation first.\n           select {\n           case <-ctx.Done():\n               return ctx.Err()\n           default:\n           }\n\n           now = r.Clock.Now()\n           if !endTime.IsZero() && !now.Before(endTime) {\n               break\n           }\n\n           // 1) Run due EventScheduler events at this time.\n           r.Scheduler.RunDue(now) // or equivalent\n\n           // 2) Advance sim time:\n           //    - Either a fixed step, or\n           //    - To next scheduled event / connectivity event.\n           next := r.nextSimStep(now, endTime)\n           if next.IsZero() || !next.After(now) {\n               // Avoid infinite loop; choose a minimal step.\n               next = now.Add(time.Second)\n           }\n\n           // Advance time controller to `next`.\n           if err := r.Clock.StepTo(next); err != nil {\n               return err\n           }\n       }\n\n3. After loop, optionally do a final `RunDue(endTime)` to flush events.\n\n`nextSimStep` can be a helper:\n\n- For now, keep it simple:\n\n      func (r *ScenarioRunner) nextSimStep(now, endTime time.Time) time.Time {\n          // For Scope 4, a fixed delta (e.g. 1s or 10s) is fine.\n          step := 1 * time.Second\n          candidate := now.Add(step)\n          if !endTime.IsZero() && candidate.After(endTime) {\n              return endTime\n          }\n          return candidate\n      }\n\nDesign notes:\n\n- Future scopes might replace this with:\n  - “Jump to next event time” strategy.\n  - Integration with connectivity “in view” events.\n\n### 4. Ensure controller Scheduler hooks into the run loop\n\nIf your controller Scheduler has its own periodic loop:\n\n- For example, a method:\n\n      func (s *Scheduler) Tick(now time.Time)\n\nThen integrate it into the run loop:\n\n- Inside each loop iteration (or every N iterations):\n\n      r.CtrlSched.Tick(now)\n\nIf your Scheduler is event-driven or precomputes actions:\n\n- You might have:\n\n      func (s *Scheduler) PopulateInitialSchedule(horizon time.Time) error\n\nCall this once before the main loop:\n\n- In `Start` or before `RunUntil` begins.\n\nDesign notes:\n\n- For Scope 4, you can keep the Scheduler **simple**:\n  - Precompute a schedule up to `endTime`.\n  - Or run a `Tick` each loop to:\n    - Look at connectivity and service requests.\n    - Issue new CreateEntryRequests via CDPI as needed.\n\n### 5. Integrate with existing main / CLI\n\nWire `ScenarioRunner` into your existing entry point, e.g. `cmd/simulator/main.go`:\n\n1. Parse CLI flags (Scope 9 config handled in a separate issue).\n2. Build ScenarioState (load scenario via NBI or static config).\n3. Construct:\n   - SimClock / time controller.\n   - EventScheduler instance bound to sim clock.\n   - TelemetryState + TelemetryServer.\n   - CDPIServer.\n   - Controller Scheduler.\n   - Agents:\n     - One `Agent` per NetworkNode that should participate in SBI.\n4. Build `RunnerConfig` and `ScenarioRunner`.\n5. Call:\n\n       ctx, cancel := context.WithCancel(context.Background())\n       defer cancel()\n\n       if err := runner.Start(ctx); err != nil {\n           // log and exit\n       }\n\n       endTime := scenarioEndTimeFromConfigOrState(...)\n       if err := runner.RunUntil(ctx, endTime); err != nil {\n           // log and exit\n       }\n\n       runner.Stop()\n\nMake sure this path is:\n\n- The **default** when Scope 4 is enabled.\n- Trivially bypassed if someone runs a minimal core-only mode (Scope 1–3 only).\n\n### 6. Add unit tests for the run loop\n\nCreate a test file, e.g.:\n\n- `internal/simrunner/runner_test.go`\n\nUse fakes:\n\n- **FakeSimClock**:\n  - Stores current time.\n  - Implements `Now()` and `StepTo(t time.Time)`.\n- **FakeEventScheduler**:\n  - Records events.\n  - Provides `RunDue(now time.Time)` that:\n    - Runs any events scheduled at or before `now`.\n- **FakeScheduler (controller)**:\n  - Records calls to `Tick(now)` or `PopulateInitialSchedule`.\n- **FakeAgent**:\n  - Minimal struct implementing:\n    - `Start(ctx)` → record “started”.\n    - `Stop()` → record “stopped”.\n\nTest cases:\n\n1. Run loop advances sim time and runs scheduler events\n\n   - Given:\n     - Start time `T0`.\n     - End time `T0 + 3s`.\n     - A fake EventScheduler that:\n       - Has one event scheduled at `T0 + 2s`.\n   - When:\n     - `RunUntil(ctx, endTime)` is called.\n   - Assert:\n     - Sim clock `Now()` ends at or after `endTime`.\n     - Scheduled event was executed exactly once.\n     - Controller Scheduler’s `Tick` (if used) was called at least once.\n\n2. Agents are started and stopped\n\n   - Given:\n     - Runner with two fake agents.\n   - When:\n     - `Start(ctx)` then `RunUntil(ctx, endTime)` then `Stop()`.\n   - Assert:\n     - Each fake agent recorded `Start` and `Stop` calls.\n     - No panics or deadlocks.\n\n3. RunUntil respects context cancellation\n\n   - Given:\n     - A context that is cancelled mid-run.\n   - When:\n     - `RunUntil(ctx, endTime)` is running.\n   - Then:\n     - It exits with `context.Canceled` (or similar).\n     - No further EventScheduler `RunDue` calls occur after cancel.\n\n4. EndTime = zero means “run until cancel”\n\n   - Given:\n     - `endTime` is zero-value.\n   - When:\n     - You run `RunUntil(ctx, time.Time{})` and cancel context after some iterations.\n   - Assert:\n     - Run loop exits only when context is cancelled.\n\n## Acceptance criteria\n\n- **ScenarioRunner API**:\n  - A `ScenarioRunner` (or equivalent) type exists with:\n    - Fields tying together:\n      - `ScenarioState`\n      - `SimClock`\n      - `EventScheduler`\n      - `CDPIServer`\n      - `TelemetryServer`\n      - Controller `Scheduler`\n      - Agents slice\n    - A constructor or helper to build it from a `RunnerConfig`.\n\n- **Lifecycle methods**:\n  - `Start(ctx)`:\n    - Starts agents.\n    - Wires controller Scheduler (precompute or loop).\n    - Ensures SBI services are ready.\n  - `RunUntil(ctx, endTime)`:\n    - Advances simulation time via the sim clock.\n    - Calls `EventScheduler.RunDue` (or equivalent) at each step.\n    - Integrates controller Scheduler (`Tick` or precomputed schedule).\n    - Respects context cancellation and `endTime`.\n  - `Stop()`:\n    - Stops agents and any controller Scheduler loop.\n    - Cleanly shuts down any owned servers (if applicable).\n\n- **Integration with main / CLI**:\n  - `cmd/simulator` (or equivalent) uses `ScenarioRunner` when Scope 4 is enabled.\n  - A developer can:\n    - Load a scenario.\n    - Run the sim to a specified sim-time horizon.\n    - Observe agents, scheduler, and telemetry all active.\n\n- **Unit tests**:\n  - Cover:\n    - Sim time advancement and EventScheduler integration.\n    - Agents starting and stopping via runner lifecycle.\n    - Respecting context cancellation.\n    - Behavior when `endTime` is zero vs non-zero.\n  - All tests pass via `go test ./...`.\n\n- **Repository health**:\n  - `go build ./...` passes with the new runner code.\n  - No cycles introduced between packages (e.g. `simrunner` vs `sbi` vs `simstate`).\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/168/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/168/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/170",
    "id": 3714871896,
    "node_id": "I_kwDOQfMfks7dbHJY",
    "number": 170,
    "title": "[Scope 4][Chunk 10] Epic – Unit tests for agents, scheduler, and KB actions",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9738572054,
        "node_id": "LA_kwDOQfMfks8AAAACRHbRFg",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:tracking",
        "name": "type:tracking",
        "color": "4eaa16",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782141359,
        "node_id": "LA_kwDOQfMfks8AAAACRw-hrw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:10-sbi-unit-tests",
        "name": "chunk:10-sbi-unit-tests",
        "color": "95506b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2025-12-10T11:52:28Z",
    "updated_at": "2025-12-10T11:52:28Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 5,
      "completed": 0,
      "percent_completed": 0
    },
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the end of **Chunk 9**, the core SBI machinery should exist and be wired into the scenario lifecycle:\n\n- CDPI server (`ControlDataPlaneInterface`) on the controller side.\n- Simulated `Agent` per node with:\n  - Local schedule queue.\n  - Execution of scheduled actions (beams/routes) via `ScenarioState`.\n  - Telemetry loop emitting `ExportMetrics`.\n- Controller-side scheduler that:\n  - Uses connectivity / ScenarioState.\n  - Issues `CreateEntry`, `DeleteEntry`, `Finalize` actions.\n- Wiring into the simulator run:\n  - Real `EventScheduler` driven by sim-time.\n  - Agents + scheduler started with the scenario.\n\nWhat’s missing is a **focused, deterministic unit test layer** for these SBI components:\n\n- Agent schedule execution (Create/Delete/Finalize semantics).\n- Scheduler decisions given a simple in-memory `ScenarioState`.\n- Telemetry metrics evolution over time.\n\nThese tests should avoid real gRPC/network where possible, preferring fakes and in-process doubles, and must form the core safety net before Chunk 11’s in-process gRPC tests.\n\n## Goal\n\nProvide a **targeted suite of unit tests** for Scope 4 SBI components that:\n\n- Validates agent behaviour:\n  - Schedule handling for `CreateEntry`, `DeleteEntry`, `FinalizeRequest`.\n  - Correct calls into `ScenarioState` helpers (beams/routes).\n  - Proper `Response` messages back to the controller side (via a fake stream).\n- Validates scheduler behaviour:\n  - Given a tiny in-memory topology and link intervals, emits the expected scheduled actions.\n  - Produces correct `UpdateBeam` / `DeleteBeam` and `SetRoute` / `DeleteRoute` actions.\n- Validates telemetry behaviour:\n  - Given active links and bandwidth, bytes counters increase monotonically across ticks.\n  - Interfaces marked down do not accumulate bytes.\n\nAll tests should be **fast, deterministic** and runnable with `go test ./...` as part of the normal CI pipeline.\n\n## Where to look\n\nAgent and SBI code:\n\n- `internal/sbi/agent` (or equivalent):\n  - `Agent` struct and its methods:\n    - Schedule handling from CDPI messages.\n    - `execute(...)` / beam + route application.\n    - Telemetry loop helpers (if not already separated).\n- `internal/sbi/controller`:\n  - `CDPIServer` and any helper types for sending/receiving messages.\n  - `Scheduler` implementation:\n    - Logic that inspects `ScenarioState` and emits `ScheduledAction`s.\n\nState / KB helpers:\n\n- `sim/state` or `internal/simstate`:\n  - `ScenarioState`:\n    - Beam helpers (e.g. `ApplyBeamUpdate`, `ApplyBeamDelete`).\n    - Route helpers (e.g. `InstallRoute`, `RemoveRoute`).\n  - Any test-friendly constructors for in-memory states.\n\nExisting fakes / test infra:\n\n- Any existing `FakeEventScheduler` or similar from earlier chunks.\n- Any helper types for fake Telemetry, fake CDPI streams, or in-memory KBs.\n\nSearch terms:\n\n- `Agent struct`\n- `ScheduledAction`\n- `CDPIServer`\n- `Scheduler struct`\n- `ScenarioState`\n- `TelemetryState`\n- `FakeEventScheduler`\n- `*_test.go` under `internal/sbi` or `sim/state`\n\n## Tasks\n\n### 10.1 – Agent schedule execution tests\n\n- Add tests under something like `internal/sbi/agent/agent_test.go`.\n\n- Introduce or reuse a **FakeEventScheduler**:\n\n  - Manually-controlled `Now()`.\n  - `Schedule(at, f)` records events and allows tests to trigger them deterministically.\n\n- Create a **FakeScenarioState** for unit tests:\n\n  - Implements just enough of the `ScenarioState` interface used by the agent:\n    - Methods such as `ApplyBeamUpdate`, `ApplyBeamDelete`, `InstallRoute`, `RemoveRoute`.\n  - Records calls (nodeID, interfaceID, routes, etc.) into slices so assertions can be made.\n\n- Create a **FakeCDPIStream / agent response sink**:\n\n  - Instead of real gRPC streams, use a struct that:\n    - Exposes a `SendResponse`/`Write`-like method that the agent uses.\n    - Records all responses (request_id, status, type).\n\n- Test cases:\n\n  1. **CreateEntry → scheduled execution**\n\n     - Arrange:\n       - Fake scheduler with `Now()` at `T0`.\n       - Agent wired to:\n         - Fake scheduler.\n         - Fake scenario state.\n         - Fake response sink.\n       - A `ScheduledAction` for `UpdateBeam` at time `T1 = T0 + Δ`.\n     - Act:\n       - Simulate agent receiving a `CreateEntryRequest` mapped to that action.\n       - Advance fake scheduler to `T1` and invoke scheduled callbacks.\n     - Assert:\n       - Fake scenario state saw exactly one `ApplyBeamUpdate` call with expected parameters.\n       - Fake responses contain exactly one OK response for the associated `request_id`.\n\n  2. **DeleteEntry cancels scheduled execution**\n\n     - Arrange:\n       - Same as above, but:\n         - After scheduling the action, simulate a `DeleteEntryRequest` for the same `EntryID`.\n     - Act:\n       - Advance scheduler to `T1`.\n     - Assert:\n       - No `ApplyBeamUpdate` / `InstallRoute` calls were made.\n       - Optionally verify that no response is sent for the cancelled entry.\n\n  3. **FinalizeRequest drops past entries**\n\n     - Arrange:\n       - Two scheduled actions:\n         - `A1` at `T1`.\n         - `A2` at `T2` where `T2 > T_cutoff > T1`.\n     - Act:\n       - Simulate `FinalizeRequest(cutoff = T_cutoff)` on the agent.\n       - Advance scheduler to `T2`.\n     - Assert:\n       - `A1` is never executed.\n       - `A2` is executed once.\n       - Responses reflect only the surviving action.\n\n  4. **Route actions call ScenarioState helpers**\n\n     - Arrange:\n       - A `ScheduledAction` of type `ScheduledSetRoute` at `T1`.\n     - Act:\n       - Schedule + execute via fake scheduler.\n     - Assert:\n       - `FakeScenarioState.InstallRoute` called with correct node and route parameters.\n       - A later `ScheduledDeleteRoute` calls `RemoveRoute`.\n\n  5. **Reset handling (if implemented on Agent)**\n\n     - Arrange:\n       - Agent with several pending actions.\n     - Act:\n       - Simulate a Reset event (local or via CDPI semantics).\n     - Assert:\n       - Pending schedule cleared.\n       - New token (if tracked by agent) differs from old one.\n       - Subsequent messages with old token are ignored/logged (as per implementation).\n\n### 10.2 – Scheduler logic tests\n\n- Add tests under `internal/sbi/controller/scheduler_test.go`.\n\n- Use a **pure in-memory `ScenarioState`**:\n\n  - Create a minimal topology:\n    - A couple of nodes (e.g. `A`, `B`).\n    - Interfaces and one potential link between them.\n  - Set up link “in view” interval `[T_on, T_off]` in a deterministic way.\n\n- Use a **FakeCDPI server handle**:\n\n  - Implement the CDPI entrypoint the scheduler calls, e.g.:\n    - `SendCreateEntry(agentID string, action *ScheduledAction) error`\n  - Record all sent actions into slices for later assertions.\n\n- Test cases:\n\n  1. **Link-driven beam scheduling**\n\n     - Arrange:\n       - Single link with known `[T_on, T_off]`.\n       - Scheduler configured with this `ScenarioState` and fake CDPI.\n     - Act:\n       - Run scheduler’s “compute schedule” entrypoint once (or for the desired horizon).\n     - Assert:\n       - Fake CDPI recorded:\n         - One `ScheduledUpdateBeam` action at or near `T_on` (allowing for any lead time).\n         - One `ScheduledDeleteBeam` action at `T_off`.\n       - Actions are targeted to the expected agent/node.\n\n  2. **Static routes for single-hop link**\n\n     - Arrange:\n       - Same topology as above.\n     - Act:\n       - Run scheduler.\n     - Assert:\n       - For each node endpoint, one `SetRoute` is scheduled at link-on time.\n       - Corresponding `DeleteRoute` is scheduled at link-off time.\n\n  3. **ServiceRequest-aware path scheduling (minimal)**\n\n     - Arrange:\n       - Scenario with:\n         - Nodes `S` (source), `D` (destination).\n         - Potential path between them over one or more links.\n       - A single `ServiceRequest` active between `S` and `D`.\n     - Act:\n       - Run scheduler’s ServiceRequest-aware routine.\n     - Assert:\n       - At least one path is chosen (e.g. via BFS).\n       - Scheduler issues:\n         - `UpdateBeam` actions along first-hop links.\n         - `SetRoute` entries along the path.\n       - If no path exists, verify no actions are scheduled.\n\n### 10.3 – Telemetry tests\n\n- Add telemetry-focused tests under `internal/sbi/telemetry_test.go` (or similar).\n\n- Use a **FakeEventScheduler** and a **FakeScenarioState** that:\n\n  - Exposes a node with one or more interfaces.\n  - Allows toggling:\n    - Interface/link `Up`/`Down` state.\n    - Bandwidth (bps) value.\n\n- Use a **FakeTelemetryServiceClient**:\n\n  - Implements `TelemetryServiceClient` and records every `ExportMetricsRequest`:\n    - Capture `NodeId`, `InterfaceId`, `Up`, `BytesTx`, etc.\n\n- Test cases:\n\n  1. **Bytes counters increase when interface is up**\n\n     - Arrange:\n       - Agent with:\n         - `TelemetryInterval = 1s`.\n         - Fake scheduler starting at `T0`.\n         - Fake state: one interface with `up = true`, `bandwidthBps = 8000` (1 kB/s).\n     - Act:\n       - Start telemetry loop once.\n       - Trigger two telemetry ticks at `T0 + 1s` and `T0 + 2s`.\n     - Assert:\n       - Two `ExportMetrics` calls recorded.\n       - For the interface:\n         - `BytesTx` on second call ≈ `2 * 1000` bytes (within integer rounding).\n         - `Up` flag remains `true`.\n\n  2. **No byte accumulation when interface is down**\n\n     - Arrange:\n       - Same as above, but `up = false`.\n     - Act:\n       - Trigger several telemetry ticks.\n     - Assert:\n       - `BytesTx` remains at `0` for all calls.\n       - `Up` flag is `false`.\n\n  3. **No metrics when there are no interfaces**\n\n     - Arrange:\n       - Agent NodeID with no interfaces in `ScenarioState`.\n     - Act:\n       - Trigger telemetry tick.\n     - Assert:\n       - Either:\n         - No `ExportMetrics` call is sent, or\n         - The request contains an empty `InterfaceMetrics` list (depending on design).\n       - No panics or unexpected errors.\n\n  4. **Telemetry disabled behaviour**\n\n     - Arrange:\n       - Agent with `TelemetryClient = nil` or `TelemetryInterval <= 0`.\n     - Act:\n       - Call `startTelemetryLoop`.\n     - Assert:\n       - Fake scheduler never schedules telemetry events.\n       - No calls to `ExportMetrics`.\n\n## Acceptance criteria\n\n- **Agent unit tests:**\n\n  - Cover:\n    - Execution of scheduled `UpdateBeam` / `DeleteBeam` / `SetRoute` / `DeleteRoute` actions via `ScenarioState`.\n    - `DeleteEntry` prevents execution of cancelled actions.\n    - `FinalizeRequest` drops actions before cutoff but preserves later ones.\n    - (If implemented) Reset semantics clear pending entries and refresh tokens.\n  - Use fakes for:\n    - Event scheduler.\n    - ScenarioState.\n    - Response sink (CDPI stream).\n\n- **Scheduler unit tests:**\n\n  - Given a simple in-memory topology and link intervals:\n    - Scheduler issues the expected `ScheduledAction`s for beams and routes.\n    - (Optional) ServiceRequest-aware scheduling creates a basic path with corresponding actions.\n  - No real gRPC calls; all interactions go through fake CDPI methods.\n\n- **Telemetry unit tests:**\n\n  - Demonstrate:\n    - Monotonic increase of `BytesTx` when link is up and bandwidth > 0.\n    - No increase when interface is down.\n    - Safe behaviour for:\n      - No interfaces.\n      - Disabled telemetry configuration.\n  - Use fake scheduler, FakeScenarioState, and FakeTelemetryServiceClient.\n\n- **Test performance and reliability:**\n\n  - All new tests:\n    - Run quickly (no sleep-based timing, only fake clocks).\n    - Are deterministic (no reliance on real time or external services).\n  - `go test ./...` passes across the repository with new tests enabled.\n\n- **Documentation / discoverability:**\n\n  - Test files are clearly named and located:\n    - `internal/sbi/agent/agent_test.go` (and/or `agent_schedule_test.go`).\n    - `internal/sbi/controller/scheduler_test.go`.\n    - `internal/sbi/telemetry_test.go` (or equivalent).\n  - High-level comments at the top of each test file explain:\n    - What component is under test.\n    - Which parts of Scope 4 they correspond to (Chunk 10).\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/171",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/171/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/171/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/171/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/171",
    "id": 3715053712,
    "node_id": "I_kwDOQfMfks7dbziQ",
    "number": 171,
    "title": "[Scope 4][Chunk 10] Add unit tests for scheduler logic (beam intervals + route intervals)",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782141359,
        "node_id": "LA_kwDOQfMfks8AAAACRw-hrw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:10-sbi-unit-tests",
        "name": "chunk:10-sbi-unit-tests",
        "color": "95506b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-10T12:43:53Z",
    "updated_at": "2025-12-10T12:43:53Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nChunk 8 introduced the **controller-side Scheduler**, which generates `ScheduledAction` entries for:\n\n- **UpdateBeam / DeleteBeam** based on link in-view intervals.\n- **SetRoute / DeleteRoute** based on the same intervals.\n- Optional **ServiceRequest-aware scheduling** (first-hop activation), though this test focuses only on link-driven scheduling.\n\nChunk 10 requires **unit tests** ensuring that scheduler logic is correct and deterministic, independent of gRPC or agents.\n\nThis issue covers *only one slice* of Chunk 10:  \n➡️ **Testing the scheduling of beam and route actions based on in-view intervals.**\n\nNo CDPI server, no agent — just the Scheduler + ScenarioState + a fake CDPI handle.\n\n---\n\n## Goal\n\nCreate a focused test suite validating that the Scheduler:\n\n1. Computes in-view intervals correctly (delegated to ScenarioState).  \n2. Emits **one UpdateBeam** at `T_on` and **one DeleteBeam** at `T_off`.  \n3. Emits **SetRoute** and **DeleteRoute** at the same times.  \n4. Sends scheduled actions through a fake CDPI interface without real gRPC.\n5. Does not send duplicate actions or malformed intervals.\n\n---\n\n## Where to look\n\n- `internal/sbi/controller/scheduler.go`\n- `sim/state` or wherever potential links + in-view intervals are computed.\n- `internal/sbi/controller/cdpi_fake_test.go` (to create a fake CDPI sender).\n\n---\n\n## Tasks\n\n### 1. Create test file\nCreate:\n\n```\ninternal/sbi/controller/scheduler_link_intervals_test.go\n```\n\n### 2. Build a **FakeScenarioState**\nMust return:\n\n- A list of nodes + interfaces.\n- One potential link defined as **in view** from `T_on` to `T_off`.\n\nExample:\n\n```go\ntype FakeState struct {\n    TOn  time.Time\n    TOff time.Time\n}\n\nfunc (s *FakeState) GetPotentialLinks() []PotentialLink {\n    return []PotentialLink{\n        { LinkID: \"L1\", NodeA: \"A\", IfA: \"A-1\", NodeB: \"B\", IfB: \"B-1\", InView: []Interval{{Start: s.TOn, End: s.TOff}}},\n    }\n}\n```\n\n### 3. Build a **Fake CDPI sender**\nRecords CreateEntry actions:\n\n```go\ntype FakeCDPI struct {\n    Sent []*ScheduledAction\n}\n\nfunc (f *FakeCDPI) SendCreateEntry(agentID string, a *ScheduledAction) error {\n    f.Sent = append(f.Sent, a)\n    return nil\n}\n```\n\n### 4. Instantiate Scheduler in test\nUse a fake EventScheduler (already built in Chunk 3 tests).\n\n### 5. Test expectations\nRun scheduling once:\n\n```go\nsch.RunOnce()\n```\n\nThen assert:\n\n- Exactly **4 scheduled actions**:\n  - UpdateBeam at T_on\n  - DeleteBeam at T_off\n  - SetRoute at T_on\n  - DeleteRoute at T_off\n- All actions have correct fields (`EntryID`, node IDs, interface IDs).\n- Times match exactly.\n\n### 6. Negative tests\n\n#### a. Link interval zero-length → scheduler must skip it  \nStart == End.\n\n#### b. Overlapping intervals → scheduler must not duplicate events  \nIf two intervals overlap, the scheduler should still send exactly one update and one delete.\n\n#### c. Missing endpoints → scheduler must skip link  \nTest robustness for malformed state.\n\n---\n\n## Acceptance criteria\n\n- A complete unit test suite exists under  \n  `internal/sbi/controller/scheduler_link_intervals_test.go`\n\n- Tests validate:\n  - UpdateBeam → at T_on  \n  - DeleteBeam → at T_off  \n  - SetRoute → at T_on  \n  - DeleteRoute → at T_off  \n\n- Tests use:\n  - FakeScenarioState\n  - FakeEventScheduler\n  - FakeCDPI (no gRPC)\n\n- Tests cover edge cases:\n  - zero-length interval  \n  - overlapping interval  \n  - malformed link  \n\n- `go test ./...` passes.\n\n- No scheduler or CDPI code modifications required (tests only verify existing behavior).\n\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/171/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/171/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/172",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/172/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/172/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/172/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/172",
    "id": 3715063658,
    "node_id": "I_kwDOQfMfks7db19q",
    "number": 172,
    "title": "[Scope 4][Chunk 10] Add scheduler logic unit tests for link-driven beam & route scheduling",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782139839,
        "node_id": "LA_kwDOQfMfks8AAAACRw-bvw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:8-sbi-controller-logic",
        "name": "chunk:8-sbi-controller-logic",
        "color": "de618e",
        "default": false,
        "description": ""
      },
      {
        "id": 9782141359,
        "node_id": "LA_kwDOQfMfks8AAAACRw-hrw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:10-sbi-unit-tests",
        "name": "chunk:10-sbi-unit-tests",
        "color": "95506b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-10T12:46:57Z",
    "updated_at": "2025-12-10T12:46:57Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nChunk 8 introduced the controller-side **Scheduler** that:\n\n- Reads connectivity / potential links from `ScenarioState`.\n- Computes link in-view intervals `[T_on, T_off]`.\n- Schedules:\n  - `UpdateBeam` at (T_on - leadTime)\n  - `DeleteBeam` at T_off\n- Schedules static routes for single-hop paths.\n- Optionally performs minimal ServiceRequest-aware scheduling.\n\nNow, in **Chunk 10**, we must create **unit tests** validating this logic in complete isolation from:\n\n- CDPI server gRPC\n- Real agents\n- Real time controller\n\nThe Scheduler must be tested using:\n\n- **FakeEventScheduler** (from Chunk 3)\n- **FakeScenarioState** with deterministic link behavior\n- **FakeCDPI server handle** that records outgoing calls\n\nThe purpose is to confirm that scheduling logic is correct **before integration testing** (Chunk 11).\n\n---\n\n## Goals\n\nImplement a comprehensive scheduler_test.go suite that verifies:\n\n1. **Link-driven beam scheduling**:\n   - Given a link active interval `[T_on, T_off]`\n   - Scheduler emits:\n     - `UpdateBeam` at `T_on`\n     - `DeleteBeam` at `T_off`\n\n2. **Scheduler emits correct agent ID routing**:\n   - Actions must target the correct agent (node) based on link endpoint.\n\n3. **Static routing scheduling (SetRoute/DeleteRoute)**:\n   - For each in-view interval, scheduler issues:\n     - `SetRoute` at `T_on`\n     - `DeleteRoute` at `T_off`.\n\n4. **Scheduler produces no actions if link is never in view**.\n\n5. **Multiple links case**:\n   - Scheduler produces correct actions for each independent link.\n\n6. **ServiceRequest-aware scheduling (minimal)**:\n   - If a simple path exists:\n     - Scheduler emits at least one `UpdateBeam` + `SetRoute`.\n   - If no path exists:\n     - No actions should be emitted.\n\n---\n\n## Where to Look\n\nFile to create:\n\n```\ninternal/sbi/controller/scheduler_test.go\n```\n\nDependencies already available from earlier chunks:\n\n- `FakeEventScheduler`\n- `FakeScenarioState`\n- `FakeCDPIHandle` (you will create a minimal version)\n- `ScenarioState` helper mocks:\n  - `ListPotentialLinks()`\n  - `LinkInView(linkID) → intervals`\n  - `ListNodes()`\n  - `ListInterfaces(nodeID)`\n  - ServiceRequest store accessor\n\n---\n\n## Tasks\n\n### 1. Create test scaffolding\n\nImplement a small fake CDPI handle:\n\n```go\ntype FakeCDPI struct {\n    Creates []*ScheduledAction\n    Deletes []*ScheduledAction\n    Routes  []*ScheduledAction\n    mu sync.Mutex\n}\n\nfunc (f *FakeCDPI) SendCreateEntry(agentID string, action *ScheduledAction) error {\n    f.mu.Lock()\n    defer f.mu.Unlock()\n    f.Creates = append(f.Creates, action)\n    return nil\n}\n\nfunc (f *FakeCDPI) SendDeleteEntry(agentID string, entryID string) error {\n    // Add record for deletes\n}\n```\n\n### 2. Unit test: simple link interval → beam schedule\n\n```\nGiven:\n  Link L with in-view interval [T1=100s, T2=200s].\nExpect:\n  UpdateBeam at 100s\n  DeleteBeam at 200s\n```\n\nVerify:\n\n- Action.Type matches `ScheduledUpdateBeam` and `ScheduledDeleteBeam`\n- Action.When matches expected times\n- Correct agent ID chosen\n\n### 3. Unit test: static routes emitted\n\n```\nGiven:\n  Link between Node A and Node B\nExpect:\n  SetRoute at T_on\n  DeleteRoute at T_off\n```\n\nVerify correct per-node SetRoute actions.\n\n### 4. Unit test: no intervals → no actions\n\nFakeScenarioState returns no in-view intervals.\n\nScheduler must emit nothing.\n\n### 5. Unit test: multiple-link scheduling\n\nUse two links:\n\n- L1: [T1, T2]\n- L2: [T3, T4]\n\nEnsure scheduler emits four beam events and four route events exactly.\n\n### 6. Unit test: minimal ServiceRequest scheduling\n\n```\nGiven:\n  A ServiceRequest from A → C.\n  FakeScenarioState returns a simple path A → B → C.\nExpect:\n  Scheduler emits:\n    - UpdateBeam on first hop\n    - SetRoute entries for at least the first hop\n```\n\nIf no path exists:\n\n- Verify scheduler emits nothing.\n\n---\n\n## Acceptance Criteria\n\n- Fully implemented `scheduler_test.go`.\n- Tests cover:\n  - Beam scheduling\n  - Route scheduling\n  - No-op behavior when appropriate\n  - Multi-link case\n  - Minimal SR-aware scheduling\n- All tests pass via `go test ./...`.\n- Test helper fakes are small, deterministic, and easy to maintain.\n- No external dependencies (no gRPC, no real agents).\n- Code remains readable and consistent with Chunk 10 testing architecture.\n\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/172/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/172/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/173",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/173/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/173/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/173/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/173",
    "id": 3715128847,
    "node_id": "I_kwDOQfMfks7dcF4P",
    "number": 173,
    "title": "[Scope 4][Chunk 10] Add unit tests for ScenarioState beam and route helpers",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737775966,
        "node_id": "LA_kwDOQfMfks8AAAACRGqrXg",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/enhancement",
        "name": "enhancement",
        "color": "a2eeef",
        "default": true,
        "description": "New feature or request"
      },
      {
        "id": 9737888292,
        "node_id": "LA_kwDOQfMfks8AAAACRGxiJA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:1-core",
        "name": "scope:1-core",
        "color": "5a92c6",
        "default": false,
        "description": ""
      },
      {
        "id": 9737888950,
        "node_id": "LA_kwDOQfMfks8AAAACRGxktg",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:2-connectivity",
        "name": "scope:2-connectivity",
        "color": "eabb19",
        "default": false,
        "description": ""
      },
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782141359,
        "node_id": "LA_kwDOQfMfks8AAAACRw-hrw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:10-sbi-unit-tests",
        "name": "chunk:10-sbi-unit-tests",
        "color": "95506b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-10T13:05:39Z",
    "updated_at": "2025-12-10T13:05:40Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nIn earlier Scope 4 chunks you:\n\n- Extended the domain model and `ScenarioState` to support:\n  - Beam / link activation and deactivation via helpers like:\n    - `ApplyBeamUpdate(nodeID string, spec BeamSpec) error`\n    - `ApplyBeamDelete(nodeID, interfaceID, targetID string) error`\n  - Static routing via helpers:\n    - `InstallRoute(nodeID string, route RouteEntry) error`\n    - `RemoveRoute(nodeID, destCIDR string) error`\n- Wired these helpers into:\n  - The **Agent** execution path (from scheduled actions in Chunk 4).\n  - The **Scheduler** (Chunk 8) which emits `UpdateBeam`, `DeleteBeam`, `SetRoute`, and `DeleteRoute` actions based on connectivity and ServiceRequests.\n\nSo far, most of the testing has focused on:\n\n- Agent behaviour under scheduled actions.\n- Scheduler behaviour in terms of which actions it decides to send.\n- Telemetry paths consuming link/interface state.\n\nWhat is still missing is a **tight, focused unit test suite on the core KB / `ScenarioState` helpers themselves** to ensure:\n\n- Beam and route operations are **idempotent**.\n- Invalid inputs are rejected cleanly.\n- State remains internally consistent for links, interfaces, and route tables.\n- Future refactors in core / connectivity cannot silently break SBI-facing behaviour.\n\nThis issue adds those **ScenarioState-level unit tests** so you can debug logic at the core layer (without involving gRPC, agents, or the scheduler) and catch regressions early.\n\n## Goal\n\nProvide a dedicated unit test suite for the `ScenarioState` beam and routing helpers that:\n\n- Verifies correct behaviour for:\n  - Beam activation/deactivation.\n  - Route install/remove.\n- Asserts correct error handling for bad inputs.\n- Exercises basic idempotency semantics.\n- Optionally covers concurrency-safety patterns (where feasible without overcomplicating the test).\n\nThe tests should be small, deterministic, and runnable via `go test ./...` with no external services.\n\n## Where to look\n\nCore state and connectivity:\n\n- `internal/sim/state` or equivalent package where `ScenarioState` lives:\n  - Types representing:\n    - Nodes, interfaces, and links (including link IDs and active vs potential state).\n    - Route table entries (`RouteEntry`) on `NetworkNode`.\n  - Beam and routing helpers introduced in Scope 4:\n    - `ApplyBeamUpdate(...)`\n    - `ApplyBeamDelete(...)`\n    - `InstallRoute(...)`\n    - `RemoveRoute(...)`\n- Any existing tests under:\n  - `internal/sim/state/..._test.go`\n  - `core/..._test.go`\n  - Use as a pattern for test setup and assertions.\n\nSearch terms:\n\n- `ApplyBeamUpdate`\n- `ApplyBeamDelete`\n- `InstallRoute`\n- `RemoveRoute`\n- `RouteEntry`\n- `Active` / `Status` on links\n- `RoutingTable` or similar fields on `NetworkNode`\n\n## Tasks\n\n### 1. Create a dedicated test file\n\n- Add a new test file alongside the `ScenarioState` implementation, for example:\n  - `internal/sim/state/scheduling_helpers_test.go`\n  - Or similar name consistent with your existing test naming.\n- Import the minimum set of packages needed:\n  - Core model types (`NetworkNode`, `RouteEntry`, link types).\n  - `ScenarioState` constructor(s).\n  - Any internal helper constructors you already use in other tests.\n\nDesign notes:\n\n- Keep these tests focused on **state transitions** and **returned errors**.\n- Avoid involving gRPC, agents, or schedulers; those are covered in other Chunk 10 and 11 tests.\n\n### 2. Test beam activation / deactivation helpers\n\nAdd tests that cover:\n\n1. **Happy-path beam activation:**\n\n   - Arrange:\n     - Create a `ScenarioState` with:\n       - A node `node-1` with interface `if-1`.\n       - A potential link between `node-1/if-1` and some target (another node, or a generic link endpoint) with:\n         - `Status = Potential` (or `Active = false` depending on your model).\n     - Construct a minimal `BeamSpec` that should activate this link when passed to `ApplyBeamUpdate`.\n   - Act:\n     - Call `ApplyBeamUpdate(\"node-1\", spec)`.\n   - Assert:\n     - No error is returned.\n     - The corresponding link in `ScenarioState` is now marked as active:\n       - For example, `link.Status == Active` or `link.Active == true`.\n     - No unrelated links are modified.\n\n2. **Idempotent beam activation:**\n\n   - Call `ApplyBeamUpdate` twice with the same inputs.\n   - Assert:\n     - The second call does not error (or returns a specific “already active” error if you defined one).\n     - Link remains active and state is consistent (no duplicate entries or weird side effects).\n\n3. **Beam deactivation:**\n\n   - Arrange:\n     - Start from a state where the link is already active.\n   - Act:\n     - Call `ApplyBeamDelete(\"node-1\", \"if-1\", targetID)`.\n   - Assert:\n     - No error is returned.\n     - The link is now marked inactive / potential again.\n     - Idempotency: a second `ApplyBeamDelete` should not corrupt state (either no-op or a clean, documented error).\n\n4. **Invalid beam operations:**\n\n   - `ApplyBeamUpdate`:\n     - Non-existent node ID.\n     - Node exists but interface ID unknown.\n   - `ApplyBeamDelete`:\n     - Non-existent link / target combination.\n   - Assert:\n     - Proper error is returned (`ErrUnknownNode`, `ErrUnknownInterface`, or `error != nil` with a meaningful message).\n     - No new links are created; existing state is unchanged.\n\n### 3. Test route install / remove helpers\n\nAdd tests that cover:\n\n1. **Happy-path route install:**\n\n   - Arrange:\n     - Create a node `node-A` with interface `if-A-B` that should be used to reach `node-B`.\n     - Ensure `RoutingTable` for `node-A` is initially empty.\n   - Act:\n     - Call `InstallRoute(\"node-A\", RouteEntry{DestinationCIDR: \"10.0.0.0/24\", NextHopNodeID: \"node-B\", OutInterfaceID: \"if-A-B\"})`.\n   - Assert:\n     - No error.\n     - Node `node-A` now has exactly one route in its routing table.\n     - Fields match the input route.\n\n2. **Idempotent or overwrite semantics:**\n\n   - Decide and test your intended semantics:\n     - Either:\n       - Second `InstallRoute` with the same `DestinationCIDR` overwrites existing entry.\n     - Or:\n       - Returns a documented error (e.g. “duplicate route”).\n   - Assert that behaviour is clear and consistent.\n\n3. **Route removal:**\n\n   - Arrange:\n     - Node `node-A` has at least one route for `DestinationCIDR = \"10.0.0.0/24\"`.\n   - Act:\n     - `RemoveRoute(\"node-A\", \"10.0.0.0/24\")`.\n   - Assert:\n     - No error.\n     - Route is no longer present in the routing table.\n     - Subsequent `RemoveRoute` for the same CIDR behaves as designed:\n       - No error but no-op, or\n       - Clean “not found” error.\n\n4. **Invalid route operations:**\n\n   - Install route with:\n     - Non-existent node ID.\n     - `OutInterfaceID` that does not belong to the node.\n   - Remove route with:\n     - Non-existent node ID.\n     - CIDR which has no route.\n   - Assert:\n     - Clear error is returned.\n     - No routes are partially added or removed.\n     - Other nodes’ routing tables remain untouched.\n\n### 4. Optional: basic concurrency-safety checks\n\nIf your `ScenarioState` and helpers are expected to be concurrency-safe:\n\n- Add a small test using `t.Parallel()` or `sync.WaitGroup` that:\n\n  - Spawns several goroutines calling `InstallRoute`/`RemoveRoute` on the same node with different CIDRs.\n  - Alternatively, activates/deactivates different beams concurrently.\n\n- Assert:\n\n  - `go test -race ./...` does not report data races.\n  - The final routing table / link state is consistent with last-writer-wins semantics (or whatever behaviour you document).\n\nDo not overcomplicate this; a minimal smoke test is enough to catch obvious locking mistakes.\n\n### 5. Keep tests small and self-contained\n\n- Avoid relying on the full orbital / RF models:\n  - If needed, construct minimal fake links and interfaces directly in the `ScenarioState`.\n- Prefer simple helpers / factory functions in the test file to create:\n  - A `ScenarioState` with:\n    - One or two nodes.\n    - A handful of interfaces and links.\n- Ensure each test case:\n  - Clearly sets up state.\n  - Performs exactly one operation (or a short sequence).\n  - Verifies the resulting state and returned error.\n\n## Acceptance criteria\n\n- New test file exists alongside `ScenarioState` implementation, e.g.:\n  - `internal/sim/state/scheduling_helpers_test.go` (or equivalent).\n- Beam helper tests:\n  - Verify `ApplyBeamUpdate`:\n    - Activates the correct link when given a valid `BeamSpec`.\n    - Is idempotent or consistently handles repeated calls.\n    - Returns meaningful errors for unknown node/interface or missing links.\n  - Verify `ApplyBeamDelete`:\n    - Deactivates the appropriate link.\n    - Is safe to call even when the link is already inactive or missing.\n    - Leaves unrelated links untouched.\n- Route helper tests:\n  - Verify `InstallRoute`:\n    - Inserts a new `RouteEntry` on the correct node.\n    - Correctly handles repeated installs for the same destination CIDR (overwrite or documented error).\n  - Verify `RemoveRoute`:\n    - Removes existing routes cleanly.\n    - Behaves safely for non-existent nodes or destinations (no state corruption).\n- Optional but desirable:\n  - At least one concurrency-oriented test that can be run under `go test -race` without race reports.\n- All new tests:\n  - Run via `go test ./...` with no flakes or external dependencies.\n  - Keep runtime small (milliseconds), suitable for CI.\n- Repository health:\n  - `go build ./...` passes with no changes required outside of tests.\n  - `go test ./...` passes, including these new ScenarioState beam/route helper tests.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/173/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/173/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/174",
    "id": 3715148345,
    "node_id": "I_kwDOQfMfks7dcKo5",
    "number": 174,
    "title": "[Scope 4][Chunk 11] Epic – In-process gRPC SBI & Telemetry tests",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9738572054,
        "node_id": "LA_kwDOQfMfks8AAAACRHbRFg",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:tracking",
        "name": "type:tracking",
        "color": "4eaa16",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782141836,
        "node_id": "LA_kwDOQfMfks8AAAACRw-jjA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:11-sbi-e2e",
        "name": "chunk:11-sbi-e2e",
        "color": "d68358",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-10T13:11:02Z",
    "updated_at": "2025-12-10T13:11:02Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 2,
      "completed": 0,
      "percent_completed": 0
    },
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the end of **Chunk 10**, you should have:\n\n- Core SBI / CDPI implementation:\n  - Controller-side `CDPIServer` implementing `ControlDataPlaneInterface.ReceiveRequests`.\n  - Simulated `Agent` implementation handling:\n    - `Hello`, `Reset`, `CreateEntry`, `DeleteEntry`, `Finalize`, (stubbed) `SetSrPolicy` / `DeleteSrPolicy`.\n  - Local per-agent schedule execution wired to `EventScheduler` + `ScenarioState`.\n- Telemetry path:\n  - `TelemetryServer` implementing `TelemetryService.ExportMetrics`.\n  - `TelemetryState` storing `InterfaceMetrics`.\n  - Agent-side telemetry loop using sim-time and `TelemetryServiceClient`.\n- Unit tests (Chunk 10) for:\n  - Agent schedule execution against fake schedulers / fake state.\n  - Scheduler logic (beam + route scheduling) in isolation.\n  - Telemetry model + agent telemetry loop behavior.\n\nWhat you **don’t** yet have is an end-to-end test that exercises:\n\n- Real gRPC plumbing (no fakes for CDPI / Telemetry services).\n- Real generated stubs on both sides (client + server).\n- The actual message flows:\n  - Agent → Controller:\n    - `Hello`, `Reset`, `Response`, `ExportMetrics`.\n  - Controller → Agent:\n    - `CreateEntryRequest`, `DeleteEntryRequest`, `FinalizeRequest`.\n\nChunk 11 focuses on **in-process gRPC integration tests** that:\n\n- Use the real generated SBI stubs.\n- Spin up a gRPC server in-process.\n- Register the **real** `CDPIServer` and `TelemetryServer`.\n- Drive a “test agent” built from the same agent implementation (or a thin wrapper).\n- Assert that:\n  - Schedule commands traverse CDPI correctly and cause expected KB changes.\n  - Telemetry metrics sent by the agent land in `TelemetryState`.\n\nThis provides a high-confidence, end-to-end “SBI+Telemetry smoke suite” before wiring into the full simulator CLI / scenario lifecycle in Chunk 9.\n\n## Goal\n\nDeliver a small but robust set of **in-process gRPC tests** that:\n\n- Bring up:\n  - A gRPC server with registered `CDPIServer` and `TelemetryServer`.\n  - One or more real `Agent` instances (or thin test harnesses) using generated SBI clients.\n- Exercise:\n  - The CDPI `ReceiveRequests` bidi stream end-to-end.\n  - A minimal schedule (e.g., `UpdateBeam` + `DeleteBeam`) executed via sim clock.\n  - Telemetry emission from the agent and storage in `TelemetryState`.\n- Assert:\n  - Correct association of `agent_id` ↔ `NodeID`.\n  - Proper `CreateEntry` → scheduled action → KB state change.\n  - Correct `Response` messages back to controller.\n  - Telemetry metrics appear in `TelemetryState` for the expected node/interface.\n\nThis epic tracks the **full Scope 4 SBI + telemetry integration tests**; individual sub-issues will focus on:\n\n- CDPI end-to-end tests.\n- Telemetry end-to-end tests.\n- Test harness / fixtures and any shared utilities.\n\n## Where to look\n\n- **CDPI implementation:**\n  - `internal/sbi/controller`:\n    - `cdpi_server.go` (or similar file implementing `ControlDataPlaneInterfaceServer`).\n    - Types:\n      - `CDPIServer`\n      - `AgentHandle`\n- **Agent implementation:**\n  - `internal/sbi/agent`:\n    - `agent.go` (core agent type + lifecycle).\n    - Fields:\n      - `State *simstate.ScenarioState`\n      - `Scheduler sbi.EventScheduler`\n      - `Stream scheduling.ControlDataPlaneInterface_ReceiveRequestsClient` (or equivalent).\n      - `TelemetryClient telemetry.TelemetryServiceClient` (for telemetry E2E).\n- **Telemetry server + state:**\n  - `internal/sbi/telemetry` / `sim/state` (depending on where you put them):\n    - `TelemetryState` with `UpdateMetrics` / `GetMetrics`.\n    - `TelemetryServer` implementing `TelemetryServiceServer`.\n- **Generated SBI stubs:**\n  - `internal/genproto/scheduling/v1alpha`\n  - `internal/genproto/telemetry/v1alpha`\n- **Time / scheduler:**\n  - `internal/sbi`:\n    - `EventScheduler` interface.\n    - Fake scheduler used in Chunk 10 tests (for deterministic control of sim time).\n\nSearch terms:\n\n- `ControlDataPlaneInterfaceServer`\n- `TelemetryServiceServer`\n- `ReceiveRequests`\n- `ExportMetrics`\n- `Agent struct`\n- `TelemetryState`\n- `grpc.NewServer`\n\n## Tasks\n\n### 11.1 – Test harness: in-process gRPC server setup\n\n- Create a dedicated test file, e.g.:\n\n  - `internal/sbi/controller/sbi_e2e_test.go`\n\n- Implement a helper to spin up an in-process gRPC server:\n\n  - Create a `grpc.Server`.\n  - Create `ScenarioState` (in-memory, simple topology).\n  - Construct:\n    - A real `CDPIServer` instance wired to that `ScenarioState`.\n    - A real `TelemetryState` and `TelemetryServer`.\n  - Register services:\n\n    - `scheduling.RegisterControlDataPlaneInterfaceServer(grpcServer, cdpiServer)`\n    - `telemetry.RegisterTelemetryServiceServer(grpcServer, telemetryServer)`\n\n  - Listen on a random local port (e.g. `net.Listen(\"tcp\", \"127.0.0.1:0\")`) and start serving in a goroutine.\n  - Expose:\n    - The server address.\n    - Pointers to `ScenarioState`, `TelemetryState`, and `CDPIServer` for assertions.\n\n- Provide a teardown function that:\n\n  - Gracefully stops the gRPC server.\n  - Cleans up any background goroutines if needed.\n\n### 11.2 – CDPI in-process E2E test (single agent, single link)\n\n- Use the harness to:\n\n  - Create a minimal `ScenarioState` with:\n    - Two nodes: `nodeA`, `nodeB`.\n    - Interfaces on each node that form a single potential link (wired or wireless).\n    - A stable `LinkID` for that link.\n\n- Start gRPC server with `CDPIServer` and `ScenarioState`.\n\n- In the test, create a **real CDPI client**:\n\n  - `conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithBlock())` (or `WithTransportCredentials(insecure.NewCredentials())`).\n  - `cli := scheduling.NewControlDataPlaneInterfaceClient(conn)`.\n\n- Create a test agent using real agent logic (or a small wrapper):\n\n  - Construct `Agent` with:\n    - `AgentID` and `NodeID` matching `nodeA`.\n    - `State` = shared `ScenarioState`.\n    - `Scheduler` = test-friendly implementation (may be a fake or real scheduler integrated with test time).\n    - CDPI client stream:\n      - `Stream, err := cli.ReceiveRequests(ctx)`.\n\n  - Call `agent.Start(ctx)` (or an equivalent method) to:\n    - Send `Hello(agent_id)`.\n    - Begin reading/writing on the CDPI stream.\n\n- Controller-side behavior:\n\n  - Use `CDPIServer` to send a `CreateEntry` for an `UpdateBeam` (or simple action) at a known sim time `T`.\n    - E.g., `cdpiServer.SendCreateEntry(agentID, scheduledUpdateBeamAction)`.\n\n- Use the **event scheduler / fake clock** to:\n\n  - Advance time to `T`.\n  - Ensure the agent executes the scheduled action.\n\n- Assertions:\n\n  - The relevant link in `ScenarioState` is marked active (`Active` / `StatusActive`).\n  - `CDPIServer` has observed a `Response` from the agent for that `request_id` (OK status).\n  - No panics or stream errors.\n\n### 11.3 – Telemetry in-process E2E test\n\n- Reuse / extend the same harness to include `TelemetryServer`:\n\n  - Ensure `TelemetryState` is accessible in the test for inspection.\n\n- Start agent with:\n\n  - A real `TelemetryServiceClient` constructed from the same `conn`:\n    - `tcli := telemetry.NewTelemetryServiceClient(conn)`.\n  - `TelemetryClient` field set on `Agent`.\n  - `TelemetryInterval` configured to a small value (e.g. 1s sim time).\n  - Scheduler used to drive `startTelemetryLoop`.\n\n- Ensure `ScenarioState`:\n\n  - Has at least one interface for `Agent.NodeID`.\n  - Marks the link/interface as `up` with a known bandwidth (for deterministic metrics).\n\n- Test flow:\n\n  1. Start agent + telemetry loop.\n  2. Advance fake scheduler time by one interval so that:\n     - `telemetryTick` runs.\n     - Agent calls `ExportMetrics` via gRPC to `TelemetryServer`.\n  3. Wait briefly (or use sync hooks) for the RPC to complete.\n\n- Assertions:\n\n  - `TelemetryState.GetMetrics(nodeID, ifaceID)` returns non-nil.\n  - `Up == true` for that interface.\n  - `BytesTx` > 0 and roughly matches the simple `bandwidth * delta / 8` model used in the agent loop.\n  - Further time advances cause `BytesTx` to increase monotonically.\n\n### 11.4 – Error / edge-case behavior\n\nAdd focused E2E tests for:\n\n- **Agent disconnect / reconnect:**\n\n  - Simulate agent stream closure (cancel context).\n  - Ensure `CDPIServer` cleans up the associated `AgentHandle` without panicking.\n  - Optionally, start a new agent instance with the same `agent_id` and confirm Hello works.\n\n- **Token mismatch (optional at E2E level):**\n\n  - Manually send a `CreateEntry` with an incorrect `schedule_manipulation_token` (if easy to inject).\n  - Assert the agent logs/ignores it and does not update `ScenarioState`.\n\n- **Telemetry failure tolerance:**\n\n  - Temporarily stop the gRPC server or cause `ExportMetrics` to fail (e.g., by using a context timeout).\n  - Verify that:\n    - Agent does not panic.\n    - Telemetry loop continues on subsequent ticks once connectivity is restored (if reconnected).\n\n### 11.5 – Shared test utilities & documentation\n\n- Factor out common helpers into internal test-only files, for example:\n\n  - `internal/sbi/testutil/grpc_harness.go`:\n    - Functions to start/stop in-process gRPC servers with SBI services.\n  - `internal/sbi/testutil/fake_scheduler.go`:\n    - Reuse or refine the fake `EventScheduler` from Chunk 10.\n\n- Add minimal developer docs (e.g. in `docs/testing/sbi_e2e.md`) describing:\n\n  - How to run only these E2E tests, e.g.:\n\n    - `go test ./internal/sbi/controller -run TestSBI*`\n\n  - What they cover at a high level (CDPI + Telemetry end-to-end).\n\n## Acceptance criteria\n\n- **In-process gRPC harness:**\n  - A reusable helper sets up:\n    - `grpc.Server` bound to a loopback address.\n    - Registered `CDPIServer` + `TelemetryServer`.\n    - Shared `ScenarioState` + `TelemetryState`.\n  - Clean teardown without goroutine leaks or panics.\n\n- **CDPI E2E test:**\n  - Test(s) demonstrate:\n    - A real agent connecting via `ReceiveRequests`.\n    - `Hello(agent_id)` is processed and associated with a `NodeID`.\n    - Controller sends a `CreateEntry` for a scheduled `UpdateBeam` (or similar).\n    - When sim time reaches the scheduled instant:\n      - `ScenarioState` reflects the expected link/beam activation.\n      - Controller receives a `Response` with OK status for the `request_id`.\n  - Tests run deterministically using a fake or well-controlled `EventScheduler`.\n\n- **Telemetry E2E test:**\n  - Agent uses a real `TelemetryServiceClient` to call `ExportMetrics`.\n  - `TelemetryState` stores at least one `InterfaceMetrics` entry for the agent’s node/interface.\n  - Metrics fields are sane:\n    - `Up` correctly reflects interface state.\n    - `BytesTx` increases monotonically over multiple telemetry ticks.\n  - No crashes when telemetry RPC fails; failures are tolerated as per design.\n\n- **Edge-case behavior:**\n  - Tests cover:\n    - Agent stream closure and controller cleanup.\n    - Basic token-mismatch behavior (if feasible).\n    - Telemetry RPC failure without agent collapse.\n  - All such tests pass reliably.\n\n- **Repository health:**\n  - `go test ./...` passes, including new E2E tests.\n  - E2E tests are reasonably fast (suitable for CI) or clearly marked and isolated (e.g. via test names or build tags).\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/175",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/175/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/175/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/175/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/175",
    "id": 3715175639,
    "node_id": "I_kwDOQfMfks7dcRTX",
    "number": 175,
    "title": "[Scope 4][Chunk 10] Add TelemetryState & agent telemetry unit tests",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9782141359,
        "node_id": "LA_kwDOQfMfks8AAAACRw-hrw",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:10-sbi-unit-tests",
        "name": "chunk:10-sbi-unit-tests",
        "color": "95506b",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-10T13:18:10Z",
    "updated_at": "2025-12-10T13:18:10Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/170",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy this point in **Scope 4** you have:\n\n- A controller-side telemetry model and store:\n  - `InterfaceMetrics` struct (node/interface IDs, `Up`, `BytesTx`, optional RF fields).\n  - `TelemetryState` with concurrency-safe `UpdateMetrics` / `GetMetrics`.\n- A server-side `TelemetryServer` implementing:\n  - `TelemetryService.ExportMetrics`, which:\n    - Accepts `ExportMetricsRequest` from agents.\n    - Translates proto metrics → `InterfaceMetrics`.\n    - Calls `TelemetryState.UpdateMetrics(...)`.\n- An agent-side telemetry loop:\n  - `Agent.startTelemetryLoop` scheduled via `EventScheduler`.\n  - `telemetryTick()` that:\n    - Uses sim time (`Scheduler.Now()`).\n    - Derives per-interface `Up`/bandwidth via `deriveInterfaceState`.\n    - Maintains per-interface `BytesTx` counters.\n    - Builds `ExportMetricsRequest` with `InterfaceMetrics` protos.\n    - Calls `TelemetryServiceClient.ExportMetrics`.\n\nWhat’s missing is a focused set of **unit tests** that:\n\n- Validate `TelemetryState` behaviour in isolation.\n- Validate the `TelemetryServer.ExportMetrics` → `TelemetryState` integration.\n- Validate the **agent telemetry loop**:\n  - Correct sim-time `delta` handling.\n  - Correct `BytesTx` accumulation when interfaces are up.\n  - No accumulation when interfaces are down.\n  - Safe behaviour when telemetry is disabled or there are no interfaces.\n\nThis issue covers the **telemetry-focused unit tests** for Chunk 10.\n\n## Goal\n\n- Add unit tests that exercise:\n\n  - `TelemetryState`:\n    - Insert + update metrics.\n    - Retrieval semantics (copy vs pointer, nil when missing).\n  - `TelemetryServer.ExportMetrics`:\n    - Maps proto metrics into `TelemetryState` correctly.\n    - Handles multiple interfaces in one request.\n  - Agent telemetry loop:\n    - `startTelemetryLoop()` schedules ticks only when telemetry is enabled.\n    - `telemetryTick()`:\n      - Uses sim time (`Scheduler.Now()`) to compute `delta`.\n      - Calls `buildInterfaceMetrics(deltaSec)` and `sendExportMetrics`.\n    - `buildInterfaceMetrics(...)`:\n      - Enumerates interfaces for `Agent.NodeID` from `ScenarioState`.\n      - Maintains and increments `BytesTx` based on `bandwidthBps * delta / 8`.\n      - Respects `Up` flag from `deriveInterfaceState`.\n\n- Tests must be **deterministic** and use a **fake scheduler**, fake telemetry client, and fake scenario state.\n\n## Where to look\n\n- Telemetry data model and state (controller side):\n\n  - Likely under something like:\n    - `internal/sim/telemetry`\n    - or `internal/sim/state/telemetry.go`\n    - or `sim/state/telemetry.go`\n\n  - Types to look for:\n\n        type InterfaceMetrics struct {\n            NodeID      string\n            InterfaceID string\n            Up          bool\n            BytesTx     uint64\n            // optional RF fields...\n        }\n\n        type TelemetryState struct {\n            mu   sync.RWMutex\n            byIf map[string]*InterfaceMetrics // key \"nodeID/interfaceID\"\n        }\n\n  - Methods:\n\n        func NewTelemetryState() *TelemetryState\n        func (t *TelemetryState) UpdateMetrics(m *InterfaceMetrics)\n        func (t *TelemetryState) GetMetrics(nodeID, ifaceID string) *InterfaceMetrics\n\n- Telemetry server:\n\n  - In an SBI-related package, e.g.:\n\n        internal/sbi/telemetry/server.go\n\n  - Type:\n\n        type TelemetryServer struct {\n            telemetry.UnimplementedTelemetryServiceServer\n            Telemetry *TelemetryState\n            // optional logger, etc.\n        }\n\n  - Method:\n\n        func (s *TelemetryServer) ExportMetrics(\n            ctx context.Context,\n            req *telemetry.ExportMetricsRequest,\n        ) (*telemetry.ExportMetricsResponse, error)\n\n- Agent telemetry loop:\n\n  - In `internal/sbi/agent/agent.go` (or similar):\n\n        type Agent struct {\n            AgentID          string\n            NodeID           string\n            State            *simstate.ScenarioState\n            Scheduler        sbi.EventScheduler\n            TelemetryClient  telemetry.TelemetryServiceClient\n            TelemetryInterval time.Duration\n\n            telemetryMu sync.Mutex\n            bytesTx     map[string]uint64\n            lastTick    time.Time\n\n            // other fields: Stream, logger, etc.\n        }\n\n  - Methods:\n\n        func (a *Agent) startTelemetryLoop()\n        func (a *Agent) telemetryTick()\n        func (a *Agent) buildInterfaceMetrics(deltaSec float64) []*telemetry.InterfaceMetrics\n        func (a *Agent) deriveInterfaceState(nodeID, ifaceID string) (up bool, bandwidthBps float64)\n        func (a *Agent) sendExportMetrics(metrics []*telemetry.InterfaceMetrics)\n\n- Event scheduler (fake + real):\n\n  - Interface:\n\n        type EventScheduler interface {\n            Schedule(at time.Time, f func()) (id string)\n            Cancel(id string)\n            Now() time.Time\n        }\n\n  - Fake implementation for tests (may already exist from previous chunks, e.g. `FakeEventScheduler`).\n\n## Tasks\n\n### 1. Add tests for TelemetryState\n\nCreate a test file, e.g.:\n\n- `sim/state/telemetry_state_test.go`\n- or `internal/sim/telemetry/telemetry_state_test.go`\n\nTest cases:\n\n1. Insert and retrieve metrics:\n\n   - Given a fresh `TelemetryState`:\n     - Call `UpdateMetrics(&InterfaceMetrics{NodeID: \"node-1\", InterfaceID: \"if-1\", Up: true, BytesTx: 123})`.\n     - Call `GetMetrics(\"node-1\", \"if-1\")`.\n     - Assert:\n       - Result is non-nil.\n       - `NodeID == \"node-1\"`, `InterfaceID == \"if-1\"`.\n       - `Up == true`.\n       - `BytesTx == 123`.\n\n2. Update overwrites existing metrics:\n\n   - Insert initial metrics with `BytesTx = 100`.\n   - Call `UpdateMetrics` with same `NodeID`/`InterfaceID` but `BytesTx = 200`, `Up = false`.\n   - `GetMetrics` again.\n   - Assert:\n     - `BytesTx == 200`, `Up == false`.\n     - No stale values left over from the first update.\n\n3. Missing metrics returns nil:\n\n   - `GetMetrics(\"unknown-node\", \"unknown-if\")` returns `nil`.\n\n4. Optional: copy semantics vs pointer semantics:\n\n   - Depending on implementation, verify either:\n     - Mutations to the returned struct do not affect stored state (if you chose to return a copy).\n     - Or clearly document and test that the pointer is shared.\n\n### 2. Add tests for TelemetryServer.ExportMetrics\n\nCreate a test file, e.g.:\n\n- `internal/sbi/telemetry/server_test.go`\n\nTest cases:\n\n1. Single interface metrics:\n\n   - Setup:\n     - `telState := NewTelemetryState()`.\n     - `srv := &TelemetryServer{Telemetry: telState}`.\n   - Build a `telemetry.ExportMetricsRequest` with one `InterfaceMetrics` proto entry:\n     - `node_id = \"node-1\"`, `interface_id = \"if-1\"`, `up = true`, `bytes_tx = 1000`.\n   - Call `srv.ExportMetrics(context.Background(), req)`.\n   - Assert:\n     - No error.\n     - `TelemetryState.GetMetrics(\"node-1\", \"if-1\")` is non-nil and matches the proto fields.\n\n2. Multiple interfaces in one request:\n\n   - Build a request with two metrics:\n     - `(\"node-1\", \"if-1\")`, `(\"node-1\", \"if-2\")`.\n   - Call `ExportMetrics`.\n   - Assert both entries are present in `TelemetryState`.\n\n3. Overwriting existing metrics:\n\n   - Pre-populate `TelemetryState` with one entry.\n   - Send an `ExportMetricsRequest` with the same `node_id` / `interface_id` but different `bytes_tx` / `up` values.\n   - Assert state is updated accordingly.\n\n4. Empty request behaviour:\n\n   - Send an `ExportMetricsRequest` with no metrics.\n   - Assert:\n     - No panic or error (likely OK response).\n     - Existing metrics in `TelemetryState` are unchanged.\n\n### 3. Add tests for Agent telemetry loop\n\nCreate a test file, e.g.:\n\n- `internal/sbi/agent/agent_telemetry_test.go`\n\n#### 3.1 Test scaffolding: fakes\n\nAdd simple fakes / test doubles:\n\n- `FakeEventScheduler`:\n  - Fields:\n    - `now time.Time`\n    - `events []scheduledEvent` where `scheduledEvent` holds `(at time.Time, f func())`.\n  - Methods:\n    - `Now() time.Time` returns `now`.\n    - `Schedule(at time.Time, f func())` appends to `events` and returns an `id`.\n    - `Cancel(id string)` can be a no-op for these tests unless you need it.\n    - Helper `RunAll()` or `AdvanceTo(t time.Time)` for tests to execute scheduled callbacks.\n\n- `FakeTelemetryClient` implementing `TelemetryServiceClient`:\n  - Fields:\n    - `calls []*telemetry.ExportMetricsRequest`\n  - Method:\n    - `ExportMetrics(ctx context.Context, in *telemetry.ExportMetricsRequest, opts ...grpc.CallOption) (*telemetry.ExportMetricsResponse, error)`:\n      - Append `in` to `calls`.\n      - Return an empty `ExportMetricsResponse` and `nil` error.\n\n- `FakeScenarioState` (minimal interface you need for telemetry):\n  - Provide:\n    - `GetInterfacesForNode(nodeID string) []Interface` (or equivalent).\n  - Each `Interface` should have at least:\n    - `ID string`\n  - You can define a small local `type Interface struct { ID string }` in the test if needed.\n\n- Provide a test-friendly implementation of `deriveInterfaceState`:\n  - Either:\n    - Use the real method and make `FakeScenarioState` provide enough link data.\n    - Or:\n      - For tests, embed behaviour in `FakeScenarioState` (e.g., map from `ifaceID` → `(up, bandwidthBps)`).\n\n#### 3.2 Telemetry loop schedules and sends metrics\n\nTest:\n\n- Setup:\n  - Fake scheduler with `Now()` starting at `T0` (e.g., `time.Unix(0, 0)`).\n  - Fake scenario state with:\n    - `NodeID = \"node-1\"` has 1 interface `\"if-1\"`.\n    - `deriveInterfaceState(\"node-1\", \"if-1\")` returns `up = true`, `bandwidthBps = 8000` (1 kB/s).\n  - Fake telemetry client that records requests.\n  - Agent:\n    - `NodeID = \"node-1\"`.\n    - `Scheduler = fakeScheduler`.\n    - `State = fakeScenarioState`.\n    - `TelemetryClient = fakeTelemetryClient`.\n    - `TelemetryInterval = 1 * time.Second`.\n\n- Call `agent.startTelemetryLoop()`.\n\n- In test, move time forward:\n  - Set `fakeScheduler.now = T0.Add(1 * time.Second)`.\n  - Execute scheduled callback (e.g. `fakeScheduler.RunAll()` or manually execute the recorded func).\n\n- Assertions:\n  - Exactly one `ExportMetrics` call was recorded.\n  - The request contains one `InterfaceMetrics`:\n    - `NodeId == \"node-1\"`.\n    - `InterfaceId == \"if-1\"`.\n    - `Up == true`.\n    - `BytesTx` is approximately `8000 * 1 / 8 = 1000` (allowing for integer rounding).\n\n#### 3.3 Multiple ticks accumulate bytes\n\nTest:\n\n- Same setup as above.\n- Execute two telemetry ticks:\n  - Advance `now` to `T0 + 1s`, run callbacks.\n  - Advance `now` to `T0 + 2s`, run callbacks again.\n- Assertions:\n  - At least two `ExportMetrics` calls recorded.\n  - For `\"if-1\"`:\n    - `BytesTx` in the **second** call is roughly twice the first `BytesTx`.\n\n#### 3.4 Interface down → bytes not increasing\n\nTest:\n\n- Fake state / `deriveInterfaceState` returns `up = false`, `bandwidthBps = 8000`.\n- Run multiple ticks as above.\n- Assertions:\n  - For `\"if-1\"`, `BytesTx` remains `0` (or unchanged) across calls.\n\n#### 3.5 Telemetry disabled when client or scheduler missing\n\nTwo small tests:\n\n1. `TelemetryClient = nil`:\n\n   - Agent has valid scheduler/state but no telemetry client.\n   - Call `startTelemetryLoop()`.\n   - Assert:\n     - Either:\n       - No events scheduled in the fake scheduler, or\n       - `telemetryTick()` is a no-op and never calls the client.\n\n2. `Scheduler = nil`:\n\n   - Agent has valid client but `Scheduler = nil`.\n   - `startTelemetryLoop()` should safely return without panic.\n\n#### 3.6 Safe behaviour for empty node / no interfaces\n\nTest:\n\n- Agent has valid client + scheduler, but fake state returns `0` interfaces for `NodeID`.\n- Run a telemetry tick.\n- Assertions:\n  - Either:\n    - No `ExportMetrics` calls.\n    - Or calls with an empty `InterfaceMetrics` list (decide and enforce).\n  - No panic or race.\n\n## Acceptance criteria\n\n- **TelemetryState tests**:\n  - Cover:\n    - Insert + retrieve metrics for a known `(NodeID, InterfaceID)`.\n    - Overwriting existing metrics updates fields correctly.\n    - Retrieving unknown metrics returns `nil`.\n  - Run as part of `go test ./...` and pass.\n\n- **TelemetryServer.ExportMetrics tests**:\n  - Verify:\n    - Single and multiple metrics are stored correctly in `TelemetryState`.\n    - Calling `ExportMetrics` with no metrics is safe and does not corrupt state.\n  - All tests pass.\n\n- **Agent telemetry loop tests**:\n  - Use a fake scheduler, fake telemetry client, and fake scenario state.\n  - Verify:\n    - `startTelemetryLoop()` schedules the first tick only when telemetry is correctly configured.\n    - `telemetryTick()`:\n      - Computes `delta` based on sim time (`Scheduler.Now()`).\n      - Calls `buildInterfaceMetrics(delta)` and `sendExportMetrics` when interfaces exist.\n    - `BytesTx` increases as expected over multiple ticks when `Up == true` and `bandwidthBps > 0`.\n    - `BytesTx` does not increase when interfaces are down.\n    - No panics when telemetry is disabled, scheduler is nil, or there are no interfaces.\n\n- **Repository health**:\n  - `go test ./...` passes with the new telemetry-related tests.\n  - Tests are deterministic (no reliance on real time / wall-clock).\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/175/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/175/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  }
]
