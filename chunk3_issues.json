[
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/132",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/132/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/132/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/132/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/132",
    "id": 3703474331,
    "node_id": "I_kwDOQfMfks7cvoib",
    "number": 132,
    "title": "[Scope 4][Chunk 3] Simulation clock integration & event scheduling (epic)",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737888292,
        "node_id": "LA_kwDOQfMfks8AAAACRGxiJA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:1-core",
        "name": "scope:1-core",
        "color": "5a92c6",
        "default": false,
        "description": ""
      },
      {
        "id": 9738572054,
        "node_id": "LA_kwDOQfMfks8AAAACRHbRFg",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:tracking",
        "name": "type:tracking",
        "color": "4eaa16",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9785768355,
        "node_id": "LA_kwDOQfMfks8AAAACR0b5ow",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:3-scope4-events",
        "name": "chunk:3-scope4-events",
        "color": "8606b6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-07T13:10:02Z",
    "updated_at": "2025-12-07T13:10:02Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 2,
      "completed": 0,
      "percent_completed": 0
    },
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy the end of **Scope 1–2**, the simulator already has:\n\n- A **time controller** / simulation clock that advances time for orbital and connectivity calculations.\n- A notion of **simulation time** distinct from wall-clock time.\n\nIn **Chunk 0**, we introduced a small `SimClock` interface and ensured the existing time controller can implement it.  \nIn **Scope 4**, we now need a **deterministic event scheduler** that:\n\n- Runs on **simulation time**, not `time.Now()`.\n- Allows components (agents, controllers) to say:\n  - “Run this callback at simulation time **T**.”\n  - “Cancel this scheduled callback if it’s no longer needed.”\n- Is easy to test using **fake clocks** and **fake schedulers**.\n\nThis scheduler will be the backbone for:\n\n- Executing **scheduled SBI actions** (UpdateBeam, DeleteBeam, SetRoute, DeleteRoute).\n- Driving **agent-local timelines** (per-node schedule queues).\n- Periodic tasks such as **telemetry emission** (in later chunks).\n\nChunk 3 is about building that event scheduling layer on top of the simulation clock, with a clean interface and testable implementation. Wiring it into the scenario lifecycle happens later in Chunk 9.\n\n## Goal\n\nDeliver a small, well-defined **event scheduling layer** that:\n\n- Exposes a clear `EventScheduler` interface under `internal/sbi`.\n- Provides a **real implementation** that:\n\n  - Uses `SimClock` to determine current simulation time.\n  - Stores future events ordered by scheduled time.\n  - Executes all events with `when <= Now()` on demand.\n\n- Provides a **fake implementation** (and/or fake clock pattern) suitable for unit tests:\n\n  - Tests can manually advance simulated time.\n  - Scheduled callbacks run deterministically when the test decides.\n\n## Scope\n\nChunk 3 covers:\n\n- **Interface design:**\n\n  - `EventScheduler` in `internal/sbi`.\n  - Simple, minimal methods: `Schedule`, `Cancel`, `Now`, `RunDue`.\n\n- **Real implementation on top of `SimClock`:**\n\n  - Uses the real simulation time controller.\n  - Stores events in a min-heap or sorted list.\n  - Handles cancellation and past-due events.\n\n- **Fake testing support:**\n\n  - A fake scheduler and/or fake clock for unit tests.\n  - Deterministic execution semantics for agent/scheduler tests.\n\nChunk 3 **does not** cover:\n\n- Wiring the scheduler into the **main sim loop** (that’s Chunk 9).\n- Agent or controller logic that uses the scheduler (Chunks 4, 5, 8).\n- Any user-facing telemetry or logging (those are later chunks).\n\n## Planned sub-issues\n\nThis epic should be implemented via a small set of focused issues:\n\n### 1. EventScheduler interface & real implementation\n\n- Define `EventScheduler` in `internal/sbi`, e.g.:\n\n  - `Schedule(at time.Time, f func()) (id string)`\n  - `Cancel(id string)`\n  - `Now() time.Time`\n  - `RunDue()`\n\n- Implement a concrete scheduler that:\n\n  - Holds scheduled events ordered by `when`.\n  - Uses an internal mutex to be concurrency-safe.\n  - Executes due events when `RunDue()` is called.\n  - Never executes the same event twice.\n  - Handles cancellation gracefully.\n\n- Provide `NewEventScheduler(clock SimClock) EventScheduler` to build a scheduler using the real sim clock.\n\n### 2. FakeEventScheduler / fake clock for tests\n\n- Provide a **fake scheduler** (and/or pair with a `FakeSimClock`) that:\n\n  - Tracks scheduled events in memory.\n  - Exposes an `AdvanceTo(t time.Time)` method or similar to move fake time.\n  - Executes all events with `when <= t` when advanced.\n\n- Use this fake implementation in unit tests for:\n\n  - Agents (Chunk 4 tests later).\n  - Controller-side scheduler logic (Chunk 8 tests later).\n  - Any KB action tests that need deterministic time-based behaviour.\n\n### 3. Unit tests for real scheduler implementation\n\n- Add tests for the real implementation using a fake/frozen `SimClock`:\n\n  - Single event scheduled in the future runs when `Now` passes `when` and `RunDue()` is invoked.\n  - Multiple events run in the correct time order.\n  - Past-due events run on the next `RunDue()` call.\n  - Cancelled events never run.\n  - Re-entrancy: callbacks can schedule new events without deadlocks.\n\n- Ensure all tests run under `go test ./...`, and that the scheduler behaves correctly under the race detector (`go test -race`), once integrated.\n\n## Acceptance criteria\n\n- A **stable `EventScheduler` interface** exists in `internal/sbi` and is used as the primary abstraction for time-based callbacks in Scope 4.\n- A **real event scheduler implementation** exists that:\n\n  - Uses the existing `SimClock` (time controller) for `Now()`.\n  - Maintains an internal, ordered collection of scheduled events.\n  - Executes all events with `when <= Now()` when `RunDue()` is called.\n  - Supports cancellation via event IDs.\n\n- A **fake scheduler / fake clock** is available for tests, enabling:\n\n  - Manual advancement of simulated time.\n  - Deterministic execution of scheduled callbacks.\n\n- Unit tests:\n\n  - Cover scheduling, execution ordering, cancellation, and past-due behaviour.\n  - Pass as part of `go test ./...`.\n\nOnce all sub-issues under this epic are complete and tests are passing, the simulator will have a solid, reusable event scheduling layer on top of the simulation clock, ready to be used by agents and controller logic in subsequent chunks.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/132/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/132/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/133",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/133/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/133/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/133/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/133",
    "id": 3703483360,
    "node_id": "I_kwDOQfMfks7cvqvg",
    "number": 133,
    "title": "[Scope 4][Chunk 3] Define EventScheduler interface and real sim-clock-backed implementation",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737888292,
        "node_id": "LA_kwDOQfMfks8AAAACRGxiJA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:1-core",
        "name": "scope:1-core",
        "color": "5a92c6",
        "default": false,
        "description": ""
      },
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9785768355,
        "node_id": "LA_kwDOQfMfks8AAAACR0b5ow",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:3-scope4-events",
        "name": "chunk:3-scope4-events",
        "color": "8606b6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-07T13:18:12Z",
    "updated_at": "2025-12-07T13:18:12Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/132",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nBy **Chunk 0**, the simulator gained a `SimClock` interface and ensured the existing time controller can implement it. That gives a consistent notion of **simulation time**, separate from wall-clock time.\n\nFor **Scope 4**, we now need a core piece of infrastructure on top of this:\n\n> A small, deterministic **event scheduler** that runs on simulation time.\n\nThis scheduler will be used by:\n\n- **SBI agents** to execute scheduled actions (`UpdateBeam`, `DeleteBeam`, `SetRoute`, `DeleteRoute`) at the right sim time.\n- The **controller-side scheduler** to plan and trigger actions over time.\n- Periodic tasks such as **telemetry emission** (in later chunks).\n\nConceptually, we want:\n\n- `Schedule(at, f)` → “run `f()` when sim time reaches `at`”\n- `Cancel(id)` → “don’t run this event anymore”\n- `RunDue()` → “run all events with `when <= Now()`”\n\nThis issue defines the **EventScheduler interface** and a **real implementation** backed by `SimClock` and the existing time controller.\n\n## Goal\n\n- Introduce a small `EventScheduler` interface under `internal/sbi`.\n- Implement a concrete scheduler that:\n  - Uses `SimClock` for the current simulation time.\n  - Stores events ordered by `when`.\n  - Executes due events when `RunDue()` is called.\n  - Supports cancellation by ID.\n- Add unit tests to verify basic behaviour:\n  - Events run in time order.\n  - Past-due events run on the next `RunDue()`.\n  - Cancelled events never run.\n\n## Where to look\n\nLook for the **simulation time** and `SimClock` pieces added in Chunk 0:\n\n- The `SimClock` interface, for example:\n\n      type SimClock interface {\n          Now() time.Time\n          After(d time.Duration) <-chan time.Time\n      }\n\n- The existing **time controller** implementation that now satisfies `SimClock`:\n  - Likely in a package such as `timectrl` or similar.\n  - Look for fields like `currentTime` and methods that advance sim time.\n\nAlso, find the **main simulation loop** (even if you do not wire the scheduler there in this issue):\n\n- Files in `cmd/simulator` or equivalent entry points.\n- Any `Run`, `Step`, or `Advance` functions that move sim time forward.\n\nUseful search terms:\n\n- `SimClock`\n- `TimeController`\n- `AdvanceTime`, `Step`, `Tick`\n- `timectrl`\n- `simulation time`\n\n## Tasks\n\n### 1. Define the `EventScheduler` interface\n\nIn `internal/sbi` (for example `internal/sbi/scheduler.go`), define a minimal interface:\n\n    package sbi\n\n    import \"time\"\n\n    // EventScheduler schedules callbacks to run at specific simulation times\n    // based on a SimClock implementation.\n    type EventScheduler interface {\n        // Schedule registers a callback f to run at simulation time 'at'.\n        // It returns an opaque event ID that can be used to cancel the event.\n        Schedule(at time.Time, f func()) (id string)\n\n        // Cancel attempts to cancel a previously scheduled event.\n        // It is a no-op if the ID is unknown or the event already ran.\n        Cancel(id string)\n\n        // Now returns the current simulation time, usually delegated to the underlying SimClock.\n        Now() time.Time\n\n        // RunDue executes all events whose scheduled time is <= Now().\n        // It should be safe to call multiple times; already-run events must not run again.\n        RunDue()\n    }\n\nDesign notes:\n\n- Keep the interface small; more features can be added in later chunks.\n- `RunDue` will be called from the simulation loop in a later chunk (wiring happens in Chunk 9).\n- `After` on `SimClock` is **not** used in this issue; we rely on explicit `RunDue()` calls.\n\n### 2. Implement a concrete sim-clock-backed scheduler\n\nIn the same package/file, implement a struct (for example `eventScheduler`) that uses `SimClock`:\n\n    type eventScheduler struct {\n        clock SimClock\n\n        mu      sync.Mutex\n        counter uint64\n        events  []*scheduledEvent        // ordered by 'when' (min-heap or sorted slice)\n        index   map[string]*scheduledEvent\n    }\n\n    type scheduledEvent struct {\n        id        string\n        when      time.Time\n        f         func()\n        cancelled bool\n    }\n\n#### 2.1 ID generation\n\nUse a simple counter for IDs:\n\n- Increment on each `Schedule` call.\n- Construct IDs like `\"ev-1\"`, `\"ev-2\"`, etc.\n\nExample:\n\n    s.counter++\n    id := fmt.Sprintf(\"ev-%d\", s.counter)\n\nThis is sufficient for internal use; using UUIDs is optional and not required here.\n\n#### 2.2 Internal storage (heap or sorted slice)\n\nChoose one of:\n\n- **Option A – Min-heap (`container/heap`)**:\n  - Implement `heap.Interface` over `[]*scheduledEvent`, ordering by `when`.\n  - `peekNextLocked()` returns the smallest `when` event.\n  - `popNextLocked()` pops the smallest event.\n\n- **Option B – Sorted slice** (simpler, fine for initial Scope 4):\n  - Maintain `events` as a time-ordered slice.\n  - Insert new events in the correct position using linear search or `sort.Search`.\n  - `peekNextLocked()` returns `events[0]` (if any).\n  - `popNextLocked()` removes `events[0]`.\n\nEither approach is acceptable; pick the one that fits the rest of the codebase and your preferences.\n\n#### 2.3 Implement `Schedule`\n\n    func (s *eventScheduler) Schedule(at time.Time, f func()) (id string) {\n        s.mu.Lock()\n        defer s.mu.Unlock()\n\n        s.counter++\n        id = fmt.Sprintf(\"ev-%d\", s.counter)\n\n        ev := &scheduledEvent{\n            id:   id,\n            when: at,\n            f:    f,\n        }\n\n        // Insert into events (heap or sorted slice)\n        s.addEventLocked(ev)\n\n        if s.index == nil {\n            s.index = make(map[string]*scheduledEvent)\n        }\n        s.index[id] = ev\n\n        return id\n    }\n\nNotes:\n\n- `addEventLocked` is an internal helper that:\n  - For a heap: calls `heap.Push`.\n  - For a sorted slice: inserts at the correct index.\n- `Schedule` does **not** execute callbacks immediately, even if `at` is in the past; that is handled by `RunDue`.\n\n#### 2.4 Implement `Cancel`\n\n    func (s *eventScheduler) Cancel(id string) {\n        s.mu.Lock()\n        defer s.mu.Unlock()\n\n        if s.index == nil {\n            return\n        }\n\n        ev, ok := s.index[id]\n        if !ok {\n            return\n        }\n\n        ev.cancelled = true\n        delete(s.index, id)\n        // Actual removal from s.events can be lazy; RunDue will skip cancelled events.\n    }\n\nNotes:\n\n- Lazy deletion is fine:\n  - The event stays in the internal slice/heap, but is marked `cancelled`.\n  - `RunDue` simply skips cancelled events as it pops them.\n- This avoids complexity of removing items from the middle of a heap/slice.\n\n#### 2.5 Implement `Now`\n\n    func (s *eventScheduler) Now() time.Time {\n        return s.clock.Now()\n    }\n\n#### 2.6 Implement `RunDue`\n\n    func (s *eventScheduler) RunDue() {\n        for {\n            now := s.clock.Now()\n\n            s.mu.Lock()\n            ev := s.peekNextLocked()\n            if ev == nil || ev.when.After(now) {\n                s.mu.Unlock()\n                return\n            }\n\n            // Remove from events\n            _ = s.popNextLocked()\n\n            // Skip cancelled events\n            if ev.cancelled {\n                s.mu.Unlock()\n                continue\n            }\n\n            if s.index != nil {\n                delete(s.index, ev.id)\n            }\n            s.mu.Unlock()\n\n            // Execute callback OUTSIDE the lock to avoid deadlocks and allow re-entrancy.\n            ev.f()\n        }\n    }\n\nNotes:\n\n- Always execute `ev.f()` **outside** the mutex:\n  - Callbacks may schedule new events, cancel events, or interact with other components.\n- `RunDue` can be called:\n  - After each sim-time advance in the main loop.\n  - Multiple times in a row; already-executed events will not run again.\n- If there are no due events, `RunDue` should return quickly without side effects.\n\n### 3. Provide a constructor\n\nAdd a constructor function:\n\n    func NewEventScheduler(clock SimClock) EventScheduler {\n        return &eventScheduler{\n            clock: clock,\n            index: make(map[string]*scheduledEvent),\n        }\n    }\n\nNotes:\n\n- Other components (agents, controller scheduler, main runner) will call `NewEventScheduler` with either:\n  - The real `TimeController` (implementing `SimClock`) in normal runs.\n  - A fake `SimClock` in unit tests.\n\n### 4. Add unit tests for the scheduler implementation\n\nCreate `internal/sbi/scheduler_test.go` to test the real implementation using a small fake `SimClock`.\n\nYou can either:\n\n- Reuse `FakeSimClock` from Chunk 0 (if already implemented), or\n- Define a minimal test-only fake clock in this file.\n\nExample fake clock:\n\n    type fakeClock struct {\n        mu  sync.Mutex\n        now time.Time\n    }\n\n    func newFakeClock(start time.Time) *fakeClock {\n        return &fakeClock{now: start}\n    }\n\n    func (c *fakeClock) Now() time.Time {\n        c.mu.Lock()\n        defer c.mu.Unlock()\n        return c.now\n    }\n\n    func (c *fakeClock) After(d time.Duration) <-chan time.Time {\n        // Not used in these tests; simple stub is fine.\n        return nil\n    }\n\n    func (c *fakeClock) AdvanceTo(t time.Time) {\n        c.mu.Lock()\n        c.now = t\n        c.mu.Unlock()\n    }\n\nTest cases:\n\n#### 4.1 Single event runs when time reaches `when`\n\n- Start fake clock at `t0`.\n- Create scheduler: `sched := NewEventScheduler(clock)`.\n- Schedule an event at `t1 := t0.Add(10 * time.Second)` that increments a counter.\n- Call `sched.RunDue()` at `t0` → counter should still be `0`.\n- `clock.AdvanceTo(t1)`, then `sched.RunDue()` → counter should be `1`.\n\n#### 4.2 Multiple events in time order\n\n- Schedule three events at `t1 < t2 < t3`, each appending a label (`\"e1\"`, `\"e2\"`, `\"e3\"`) to a slice.\n- Advance clock in steps:\n  - Advance to `t2`, call `RunDue()` → `\"e1\"` and `\"e2\"` should have been appended in order.\n  - Advance to `t3`, call `RunDue()` → `\"e3\"` appended last.\n- Assert execution order matches expected order.\n\n#### 4.3 Past-due event runs on next `RunDue()`\n\n- Start clock at `t1`.\n- Schedule an event at `t0 := t1.Add(-5 * time.Second)`.\n- Call `RunDue()` once:\n  - Even though the event time is in the past, it should execute immediately.\n\n#### 4.4 Cancelled event does not run\n\n- Schedule an event at `t1`.\n- Call `Cancel(id)` on the returned ID before advancing the clock.\n- Advance clock to `t1`, call `RunDue()`.\n- Assert that the callback was never invoked.\n\n#### 4.5 (Optional) Re-entrancy behaviour\n\n- Schedule an event at `t1` whose callback:\n  - Increments a counter.\n  - Schedules another event at `t1` or `t2`.\n- Ensure:\n  - No deadlock occurs.\n  - The newly scheduled event runs when `RunDue()` is called after the clock is advanced appropriately.\n\n### 5. Document intended usage\n\nAdd brief comments near the `EventScheduler` interface or `NewEventScheduler` describing how this will be used:\n\n- The **main simulation loop** (wired in Chunk 9) will:\n  - Advance the simulation time using the time controller.\n  - Call `RunDue()` on the `EventScheduler` after each time advance.\n- **Agents** and the **controller-side scheduler** (Chunks 4 and 8) will:\n  - Use `Schedule` / `Cancel` to manage time-based actions (beam updates, routes, telemetry, etc.).\n\nThis makes it clear for future readers how this piece fits into the broader Scope 4 design.\n\n## Acceptance criteria\n\n- `internal/sbi` defines an `EventScheduler` interface with:\n  - `Schedule(at time.Time, f func()) (id string)`\n  - `Cancel(id string)`\n  - `Now() time.Time`\n  - `RunDue()`\n- A concrete scheduler implementation (e.g. `eventScheduler`) exists that:\n  - Uses a `SimClock` for `Now()`.\n  - Maintains an internal ordered collection of events (heap or sorted slice).\n  - Executes all events with `when <= Now()` on each `RunDue()` call.\n  - Never executes the same event twice.\n  - Skips cancelled events.\n- A constructor `NewEventScheduler(clock SimClock) EventScheduler` is available for other components.\n- Unit tests in `internal/sbi/scheduler_test.go`:\n  - Verify scheduling and execution order.\n  - Verify execution of past-due events.\n  - Verify cancellation behaviour.\n  - Optionally verify re-entrancy (callbacks scheduling more events).\n- `go test ./...` passes with the new scheduler code in place.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/133/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/133/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/134",
    "repository_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
    "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/134/labels{/name}",
    "comments_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/134/comments",
    "events_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/134/events",
    "html_url": "https://github.com/Cizor/spacetime-constellation-sim/issues/134",
    "id": 3703485065,
    "node_id": "I_kwDOQfMfks7cvrKJ",
    "number": 134,
    "title": "[Scope 4][Chunk 3] Add FakeEventScheduler for deterministic tests",
    "user": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "labels": [
      {
        "id": 9737888292,
        "node_id": "LA_kwDOQfMfks8AAAACRGxiJA",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:1-core",
        "name": "scope:1-core",
        "color": "5a92c6",
        "default": false,
        "description": ""
      },
      {
        "id": 9737890014,
        "node_id": "LA_kwDOQfMfks8AAAACRGxo3g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:feature",
        "name": "type:feature",
        "color": "942327",
        "default": false,
        "description": ""
      },
      {
        "id": 9737891558,
        "node_id": "LA_kwDOQfMfks8AAAACRGxu5g",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
        "name": "type:test",
        "color": "3c874f",
        "default": false,
        "description": ""
      },
      {
        "id": 9782134341,
        "node_id": "LA_kwDOQfMfks8AAAACRw-GRQ",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
        "name": "scope:4-sbi",
        "color": "5a2e28",
        "default": false,
        "description": ""
      },
      {
        "id": 9785768355,
        "node_id": "LA_kwDOQfMfks8AAAACR0b5ow",
        "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:3-scope4-events",
        "name": "chunk:3-scope4-events",
        "color": "8606b6",
        "default": false,
        "description": ""
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": {
      "login": "Cizor",
      "id": 11782718,
      "node_id": "MDQ6VXNlcjExNzgyNzE4",
      "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Cizor",
      "html_url": "https://github.com/Cizor",
      "followers_url": "https://api.github.com/users/Cizor/followers",
      "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
      "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
      "organizations_url": "https://api.github.com/users/Cizor/orgs",
      "repos_url": "https://api.github.com/users/Cizor/repos",
      "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Cizor/received_events",
      "type": "User",
      "user_view_type": "public",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
      "html_url": "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
      "labels_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
      "id": 14244293,
      "node_id": "MI_kwDOQfMfks4A2VnF",
      "number": 4,
      "title": "Scope 4 – Planning & Scheduling",
      "description": "",
      "creator": {
        "login": "Cizor",
        "id": 11782718,
        "node_id": "MDQ6VXNlcjExNzgyNzE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/11782718?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Cizor",
        "html_url": "https://github.com/Cizor",
        "followers_url": "https://api.github.com/users/Cizor/followers",
        "following_url": "https://api.github.com/users/Cizor/following{/other_user}",
        "gists_url": "https://api.github.com/users/Cizor/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Cizor/subscriptions",
        "organizations_url": "https://api.github.com/users/Cizor/orgs",
        "repos_url": "https://api.github.com/users/Cizor/repos",
        "events_url": "https://api.github.com/users/Cizor/events{/privacy}",
        "received_events_url": "https://api.github.com/users/Cizor/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
      },
      "open_issues": 73,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2025-11-29T09:54:27Z",
      "updated_at": "2025-12-10T17:09:37Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2025-12-07T13:20:07Z",
    "updated_at": "2025-12-07T13:20:07Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "sub_issues_summary": {
      "total": 0,
      "completed": 0,
      "percent_completed": 0
    },
    "parent_issue_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/132",
    "issue_dependencies_summary": {
      "blocked_by": 0,
      "total_blocked_by": 0,
      "blocking": 0,
      "total_blocking": 0
    },
    "body": "## Background\n\nIn the previous Chunk 3 issue, we introduced:\n\n- An `EventScheduler` interface under `internal/sbi`.\n- A **real implementation** backed by `SimClock` (driven by the existing time controller).\n\nFor **higher-level tests** (agents, controller scheduler, SBI protocol flows), we want something even more controllable:\n\n> A **FakeEventScheduler** that does not depend on the real time controller and lets tests advance simulation time manually.\n\nThis fake scheduler will be used in later chunks to:\n\n- Drive **Agent** tests deterministically (e.g. “advance to T, run all actions due at T”).\n- Drive **Scheduler** tests without having to wire the time controller or main loop.\n- Support integration/unit tests that simulate time jumps quickly.\n\nThe idea: tests can call:\n\n- `AdvanceTo(t)` → set fake “Now” to `t` and execute due events.\n- `Schedule(at, f)` → queue callbacks that will run at or before `t` when advanced.\n\n## Goal\n\n- Implement a `FakeEventScheduler` type under `internal/sbi` that:\n  - Implements the existing `EventScheduler` interface.\n  - Maintains its own internal notion of “now” (simulation time).\n  - Allows tests to advance time explicitly (e.g. `AdvanceTo(t time.Time)`).\n  - Executes scheduled callbacks when time is advanced to or beyond their `when`.\n- Add unit tests that prove:\n  - Scheduling + advancing time executes callbacks in order.\n  - Cancelled events do not run.\n  - Past-due events run when time is advanced past their `when`.\n\n## Where to look\n\nLook at the existing scheduler code from the previous Chunk 3 issue:\n\n- Interface (in `internal/sbi`, e.g. `scheduler.go`):\n\n      type EventScheduler interface {\n          Schedule(at time.Time, f func()) (id string)\n          Cancel(id string)\n          Now() time.Time\n          RunDue()\n      }\n\n- The real scheduler implementation (e.g. `eventScheduler`):\n  - How it generates IDs.\n  - How it stores events and skips cancelled ones.\n  - How `RunDue` iterates over events based on `Now()`.\n\nAlso, find any existing **fake clock** you added earlier (e.g. in scheduler tests or Chunk 0):\n\n- `FakeSimClock` or similar, if present.\n- Otherwise, you will implement a self-contained fake time mechanism inside `FakeEventScheduler`.\n\nUseful search terms:\n\n- `EventScheduler`\n- `eventScheduler`\n- `NewEventScheduler`\n- `SimClock`\n- `FakeSimClock`\n\n## Tasks\n\n### 1. Define the `FakeEventScheduler` type\n\nCreate a new file under `internal/sbi`, for example: `fake_scheduler.go`.\n\nDefine a struct:\n\n    type FakeEventScheduler struct {\n        mu      sync.Mutex\n        now     time.Time\n        counter uint64\n\n        // Events ordered by 'when' (earliest first).\n        events []*fakeScheduledEvent\n        index  map[string]*fakeScheduledEvent\n    }\n\n    type fakeScheduledEvent struct {\n        id        string\n        when      time.Time\n        f         func()\n        cancelled bool\n    }\n\nNotes:\n\n- `now` is the fake simulation time, controlled only by the test.\n- `counter` is used to generate simple, unique event IDs.\n- `events` is a slice kept ordered by `when`.\n- `index` allows fast lookup for cancellation.\n\n### 2. Implement `EventScheduler` interface methods\n\n#### 2.1 Constructor\n\nProvide a constructor that sets the initial time and prepares the maps/slices:\n\n    func NewFakeEventScheduler(start time.Time) *FakeEventScheduler {\n        return &FakeEventScheduler{\n            now:    start,\n            events: make([]*fakeScheduledEvent, 0),\n            index:  make(map[string]*fakeScheduledEvent),\n        }\n    }\n\n#### 2.2 `Now() time.Time`\n\nReturn the current fake time:\n\n    func (s *FakeEventScheduler) Now() time.Time {\n        s.mu.Lock()\n        defer s.mu.Unlock()\n        return s.now\n    }\n\n#### 2.3 `Schedule(at time.Time, f func()) (id string)`\n\nImplement scheduling with ID generation and sorted insert:\n\n    func (s *FakeEventScheduler) Schedule(at time.Time, f func()) (id string) {\n        s.mu.Lock()\n        defer s.mu.Unlock()\n\n        s.counter++\n        id = fmt.Sprintf(\"fake-ev-%d\", s.counter)\n\n        ev := &fakeScheduledEvent{\n            id:   id,\n            when: at,\n            f:    f,\n        }\n\n        // Insert into events slice in time order (earliest first).\n        inserted := false\n        for i, existing := range s.events {\n            if at.Before(existing.when) {\n                s.events = append(s.events[:i], append([]*fakeScheduledEvent{ev}, s.events[i:]...)...)\n                inserted = true\n                break\n            }\n        }\n        if !inserted {\n            s.events = append(s.events, ev)\n        }\n\n        s.index[id] = ev\n        return id\n    }\n\nNotes:\n\n- Linear insert is fine for small test workloads.\n- If you prefer, you can use `sort.Search` instead of the manual loop.\n\n#### 2.4 `Cancel(id string)`\n\nMark an event as cancelled and remove it from `index`:\n\n    func (s *FakeEventScheduler) Cancel(id string) {\n        s.mu.Lock()\n        defer s.mu.Unlock()\n\n        if s.index == nil {\n            return\n        }\n\n        ev, ok := s.index[id]\n        if !ok {\n            return\n        }\n\n        ev.cancelled = true\n        delete(s.index, id)\n        // We keep ev in s.events; RunDue will skip cancelled ones.\n    }\n\nNotes:\n\n- Lazy removal is good enough, since test volumes are small.\n- Cancel is a no-op if the ID is unknown or the event already ran.\n\n#### 2.5 `RunDue()`\n\nFor the fake scheduler, `RunDue()` executes all events with `when <= now`:\n\n    func (s *FakeEventScheduler) RunDue() {\n        for {\n            s.mu.Lock()\n\n            if len(s.events) == 0 {\n                s.mu.Unlock()\n                return\n            }\n\n            ev := s.events[0]\n            if ev.when.After(s.now) {\n                s.mu.Unlock()\n                return\n            }\n\n            // Pop the first event\n            s.events = s.events[1:]\n\n            if ev.cancelled {\n                s.mu.Unlock()\n                continue\n            }\n\n            if s.index != nil {\n                delete(s.index, ev.id)\n            }\n\n            callback := ev.f\n            s.mu.Unlock()\n\n            // Execute callback outside the lock.\n            if callback != nil {\n                callback()\n            }\n        }\n    }\n\nNotes:\n\n- This matches the semantics used by the real scheduler, but driven by fake `now`.\n- Repeated `RunDue()` calls are safe; once an event is popped, it will not run again.\n\n### 3. Add `AdvanceTo` helper for tests\n\nThe `EventScheduler` interface does not include an `AdvanceTo` method, but tests using `*FakeEventScheduler` can use a concrete API.\n\nImplement:\n\n    func (s *FakeEventScheduler) AdvanceTo(t time.Time) {\n        s.mu.Lock()\n        if t.Before(s.now) {\n            // Do not go backwards in time; keep it monotonic.\n            s.mu.Unlock()\n            return\n        }\n        s.now = t\n        s.mu.Unlock()\n\n        // After adjusting time, run all due events.\n        s.RunDue()\n    }\n\nNotes:\n\n- This is **not** part of the interface, but is very convenient for agent/scheduler tests.\n- If you do need a backwards-time test later, you can adjust semantics, but for now keeping time monotonic is fine.\n\n### 4. Add unit tests for `FakeEventScheduler`\n\nCreate a test file, e.g. `internal/sbi/fake_scheduler_test.go`.\n\nTest cases should focus on:\n\n#### 4.1 Basic scheduling and execution\n\n- Start with `start := time.Unix(0, 0)`.\n- `sched := NewFakeEventScheduler(start)`.\n- Schedule a callback at `t1 := start.Add(10 * time.Second)` that appends `\"e1\"` to a slice.\n- Before advancing time:\n  - Call `sched.RunDue()` → slice should still be empty.\n- Call `sched.AdvanceTo(t1)`:\n  - Slice should contain `\"e1\"`.\n\n#### 4.2 Multiple events in order\n\n- Schedule three events at `t1 < t2 < t3`, each appending `e1`, `e2`, `e3`.\n- `AdvanceTo(t2)`:\n  - Slice should contain `[\"e1\", \"e2\"]` in order.\n- `AdvanceTo(t3)`:\n  - Slice should now be `[\"e1\", \"e2\", \"e3\"]`.\n\n#### 4.3 Past-due event\n\n- Start at `start`.\n- Schedule event at `tPast := start.Add(-5 * time.Second)`.\n- Call `AdvanceTo(start)`:\n  - Even though event time is in the past, it should run when we first call `AdvanceTo` (since `when <= now`).\n\n#### 4.4 Cancellation\n\n- Schedule an event at `t1`.\n- Cancel it by ID.\n- `AdvanceTo(t1)`:\n  - Callback must not run (counter remains zero or slice remains empty).\n\n#### 4.5 Monotonic time behaviour\n\n- Set initial `now` to `t1`.\n- Call `AdvanceTo(t0)` where `t0 < t1`:\n  - `now` should remain `t1` (no backwards jump).\n  - No events should be executed because of this call.\n\n### 5. Document intended usage\n\nAdd a short comment above `FakeEventScheduler` explaining its purpose, for example:\n\n- “This fake implementation is intended for unit tests of SBI agents, controller scheduler, and other components that rely on `EventScheduler` but should not depend on the real time controller.”\n\nThis will help future contributors understand why both a real scheduler and a fake scheduler exist.\n\n## Acceptance criteria\n\n- `internal/sbi/fake_scheduler.go` defines:\n  - `FakeEventScheduler` type implementing `EventScheduler`.\n  - Internal `fakeScheduledEvent` struct.\n  - `NewFakeEventScheduler(start time.Time) *FakeEventScheduler`.\n  - `AdvanceTo(t time.Time)` helper for tests.\n- `FakeEventScheduler`:\n  - Maintains its own fake `now` time.\n  - Stores events ordered by `when`.\n  - Executes all events with `when <= now` on `RunDue()` / `AdvanceTo`.\n  - Never runs cancelled events.\n- Unit tests in `internal/sbi/fake_scheduler_test.go`:\n  - Verify basic scheduling and execution when time is advanced.\n  - Verify correct ordering of multiple events.\n  - Verify past-due events run when time is first advanced.\n  - Verify cancellation prevents execution.\n  - Verify time does not go backwards when `AdvanceTo` is called with an earlier time.\n- `go test ./...` passes with the new fake scheduler implementation added.\n",
    "closed_by": null,
    "reactions": {
      "url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/134/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/134/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  }
]
