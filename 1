diff --git a/internal/sbi/controller/scheduler.go b/internal/sbi/controller/scheduler.go
index 7965366..5debc99 100644
--- a/internal/sbi/controller/scheduler.go
+++ b/internal/sbi/controller/scheduler.go
@@ -740,8 +740,8 @@ func (s *Scheduler) ScheduleServiceRequests(ctx context.Context) error {
 		if provisionedInterval == nil {
 			now := s.Clock.Now()
 			provisionedInterval = &model.TimeInterval{
-				Start: now,
-				End:   now.Add(ContactHorizon),
+				StartTime: now,
+				EndTime:   now.Add(ContactHorizon),
 			}
 		}
 		if err := s.updateServiceRequestStatus(ctx, sr.ID, true, provisionedInterval); err != nil {
@@ -1117,8 +1117,8 @@ func (s *Scheduler) scheduleActionsForPath(_ context.Context, path []string, srI
 	}
 
 	return &model.TimeInterval{
-		Start: earliestStart,
-		End:   latestEnd,
+		StartTime: earliestStart,
+		EndTime:   latestEnd,
 	}, entries, nil
 }
 
diff --git a/internal/sbi/controller/scheduler_servicerequest_status_test.go b/internal/sbi/controller/scheduler_servicerequest_status_test.go
index ec3ee18..954a377 100644
--- a/internal/sbi/controller/scheduler_servicerequest_status_test.go
+++ b/internal/sbi/controller/scheduler_servicerequest_status_test.go
@@ -159,10 +159,10 @@ func TestScheduler_ServiceRequestStatusUpdates(t *testing.T) {
 	}
 	if len(sr.ProvisionedIntervals) > 0 {
 		interval := sr.ProvisionedIntervals[0]
-		if interval.Start.IsZero() || interval.End.IsZero() {
+		if interval.StartTime.IsZero() || interval.EndTime.IsZero() {
 			t.Errorf("ProvisionedInterval has zero times: %+v", interval)
 		}
-		if interval.End.Before(interval.Start) {
+		if interval.EndTime.Before(interval.StartTime) {
 			t.Errorf("ProvisionedInterval End before Start: %+v", interval)
 		}
 	}
diff --git a/internal/sim/state/state.go b/internal/sim/state/state.go
index 7955aff..5fd6151 100644
--- a/internal/sim/state/state.go
+++ b/internal/sim/state/state.go
@@ -69,7 +69,9 @@ type ScenarioState struct {
 	// serviceRequests is an in-memory store of active ServiceRequests,
 	// keyed by their internal ID.
 	serviceRequests map[string]*model.ServiceRequest
-	dtnStorageUsage map[string]float64
+	// serviceRequestStatuses track provisioning state / intervals per request.
+	serviceRequestStatuses map[string]*model.ServiceRequestStatus
+	dtnStorageUsage        map[string]float64
 
 	// motion is an optional motion model used by the simulator; it is
 	// reset alongside scenario clears.
@@ -146,11 +148,12 @@ func NewScenarioState(phys *kb.KnowledgeBase, net *network.KnowledgeBase, log lo
 		log = logging.Noop()
 	}
 	state := &ScenarioState{
-		physKB:          phys,
-		netKB:           net,
-		serviceRequests: make(map[string]*model.ServiceRequest),
-		dtnStorageUsage: make(map[string]float64),
-		log:             log,
+		physKB:                 phys,
+		netKB:                  net,
+		serviceRequests:        make(map[string]*model.ServiceRequest),
+		serviceRequestStatuses: make(map[string]*model.ServiceRequestStatus),
+		dtnStorageUsage:        make(map[string]float64),
+		log:                    log,
 	}
 	for _, opt := range opts {
 		if opt != nil {
@@ -968,6 +971,8 @@ func (s *ScenarioState) CreateServiceRequest(sr *model.ServiceRequest) error {
 	}
 	s.serviceRequests[sr.ID] = sr
 
+	s.ensureServiceRequestStatusLocked(sr.ID)
+
 	s.updateMetricsLocked()
 	return nil
 }
@@ -1026,11 +1031,68 @@ func (s *ScenarioState) DeleteServiceRequest(id string) error {
 		return ErrServiceRequestNotFound
 	}
 	delete(s.serviceRequests, id)
+	delete(s.serviceRequestStatuses, id)
 
 	s.updateMetricsLocked()
 	return nil
 }
 
+// UpdateServiceRequestStatus updates the provisioning metadata tracked for a ServiceRequest.
+func (s *ScenarioState) UpdateServiceRequestStatus(srID string, isProvisioned bool, interval *model.TimeInterval) error {
+	if srID == "" {
+		return errors.New("service request ID is empty")
+	}
+
+	s.mu.Lock()
+	defer s.mu.Unlock()
+
+	sr, exists := s.serviceRequests[srID]
+	if !exists {
+		return ErrServiceRequestNotFound
+	}
+
+	status := s.ensureServiceRequestStatusLocked(srID)
+	intervalCopy := copyTimeInterval(interval)
+
+	status.IsProvisionedNow = isProvisioned
+	if intervalCopy != nil {
+		status.AllIntervals = append(status.AllIntervals, *intervalCopy)
+	}
+	if isProvisioned {
+		status.CurrentInterval = intervalCopy
+		if intervalCopy != nil {
+			status.LastProvisionedAt = intervalCopy.StartTime
+			sr.ProvisionedIntervals = append(sr.ProvisionedIntervals, *intervalCopy)
+		}
+	} else {
+		status.CurrentInterval = nil
+		if intervalCopy != nil {
+			status.LastUnprovisionedAt = intervalCopy.EndTime
+		}
+	}
+	sr.IsProvisionedNow = isProvisioned
+	sr.LastProvisionedAt = status.LastProvisionedAt
+	sr.LastUnprovisionedAt = status.LastUnprovisionedAt
+
+	return nil
+}
+
+// GetServiceRequestStatus returns a copy of the provisioning metadata for the request.
+func (s *ScenarioState) GetServiceRequestStatus(srID string) (*model.ServiceRequestStatus, error) {
+	s.mu.RLock()
+	defer s.mu.RUnlock()
+
+	if _, exists := s.serviceRequests[srID]; !exists {
+		return nil, ErrServiceRequestNotFound
+	}
+
+	status := s.serviceRequestStatuses[srID]
+	if status == nil {
+		return &model.ServiceRequestStatus{}, nil
+	}
+	return cloneServiceRequestStatus(status), nil
+}
+
 // updateMetricsLocked pushes current entity counts into the metrics recorder.
 // Caller must hold s.mu when invoking this helper.
 func (s *ScenarioState) updateMetricsLocked() {
@@ -1050,6 +1112,42 @@ func (s *ScenarioState) updateMetricsLocked() {
 	s.metrics.SetScenarioCounts(platforms, nodes, links, len(s.serviceRequests))
 }
 
+func (s *ScenarioState) ensureServiceRequestStatusLocked(srID string) *model.ServiceRequestStatus {
+	if status := s.serviceRequestStatuses[srID]; status != nil {
+		return status
+	}
+	status := &model.ServiceRequestStatus{}
+	s.serviceRequestStatuses[srID] = status
+	return status
+}
+
+func copyTimeInterval(interval *model.TimeInterval) *model.TimeInterval {
+	if interval == nil {
+		return nil
+	}
+	clone := *interval
+	if interval.Path != nil {
+		pathCopy := *interval.Path
+		clone.Path = &pathCopy
+	}
+	return &clone
+}
+
+func cloneServiceRequestStatus(src *model.ServiceRequestStatus) *model.ServiceRequestStatus {
+	if src == nil {
+		return nil
+	}
+	dst := *src
+	if src.CurrentInterval != nil {
+		intervalCopy := *src.CurrentInterval
+		dst.CurrentInterval = &intervalCopy
+	}
+	if len(src.AllIntervals) > 0 {
+		dst.AllIntervals = append([]model.TimeInterval(nil), src.AllIntervals...)
+	}
+	return &dst
+}
+
 // interfacesByNodeLocked builds a map of nodeID -> interfaces for callers that
 // already hold the ScenarioState lock.
 func (s *ScenarioState) interfacesByNodeLocked(nodes []*model.NetworkNode, interfaces []*network.NetworkInterface) map[string][]*network.NetworkInterface {
@@ -1235,6 +1333,7 @@ func (s *ScenarioState) ClearScenario(ctx context.Context) error {
 		s.netKB.Clear()
 	}
 	s.serviceRequests = make(map[string]*model.ServiceRequest)
+	s.serviceRequestStatuses = make(map[string]*model.ServiceRequestStatus)
 	s.dtnStorageUsage = make(map[string]float64)
 
 	if s.motion != nil {
diff --git a/model/servicerequest.go b/model/servicerequest.go
index 5a664ba..1e4b06f 100644
--- a/model/servicerequest.go
+++ b/model/servicerequest.go
@@ -17,8 +17,16 @@ type FlowRequirement struct {
 
 // TimeInterval represents a time interval with start and end times.
 type TimeInterval struct {
-	Start time.Time
-	End   time.Time
+	StartTime time.Time
+	EndTime   time.Time
+	Path      *Path
+}
+
+type Path struct {
+	// ID is an internal identifier for the path.
+	ID string
+	// Nodes captures the ordered nodes that form the path.
+	Nodes []string
 }
 
 type ServiceRequest struct {
@@ -41,4 +49,16 @@ type ServiceRequest struct {
 	// ProvisionedIntervals tracks the time intervals when this service request
 	// was/is provisioned. This allows tracking provisioning history.
 	ProvisionedIntervals []TimeInterval
+	// LastProvisionedAt records when the request was last marked as provisioned.
+	LastProvisionedAt time.Time
+	// LastUnprovisionedAt records when the request was last marked as not provisioned.
+	LastUnprovisionedAt time.Time
+}
+
+type ServiceRequestStatus struct {
+	IsProvisionedNow    bool
+	CurrentInterval     *TimeInterval
+	AllIntervals        []TimeInterval
+	LastProvisionedAt   time.Time
+	LastUnprovisionedAt time.Time
 }
