Chunk 1 – Data model completion (Interfaces & Transceivers)

Goals

Bring the core structs in line with the Scope 2 doc:

NetworkInterface knows which links it participates in.

TransceiverModel carries MaxBeams.

Make sure the KB keeps adjacency in both directions.

What we’ll change

core/network_model.go (or wherever NetworkInterface, NetworkLink, TransceiverModel are defined).

kb package functions that add/remove/update interfaces & links.

Steps

Extend structs

Add LinkIDs []string to NetworkInterface.

Add MaxBeams int (default 1) to TransceiverModel.

Update KB mutators

In AddNetworkLink, also:

append link ID into both endpoint interfaces’ LinkIDs,

keep your existing linksByInterface map in sync.

In any “remove link” function (if present), clean up both maps and LinkIDs.

Initialisation / defaulting

When loading transceivers, if max_beams not present, set MaxBeams = 1.

Acceptance

go test ./... still green.

Debug log / simple helper shows that after inserting links, the two interfaces list those link IDs in LinkIDs.

Chunk 2 – Frequency compatibility & band checks

Goals

Respect radio band compatibility so Ku–Ku works, Ku–Ka or Ku–Optical doesn’t (unless explicitly allowed).

Exactly what the Scope 2 pseudo-code hints at.

What we’ll change

core/connectivity_service.go – wireless branch in UpdateConnectivity.

core/network_model.go – ensure TransceiverModel has a Band structure (min/max GHz or band enum).

Steps

Define a compatibility helper

Add a function in core (or inside connectivity_service):

func areTransceiversFrequencyCompatible(a, b *TransceiverModel) bool {
    // simplest: check band overlap
    return a.Band.MinGHz <= b.Band.MaxGHz && b.Band.MinGHz <= a.Band.MaxGHz
}


Use it in connectivity

In the wireless evaluation path:

look up both transceiver models,

if either is missing → treat as “not compatible” and mark link down,

if !areTransceiversFrequencyCompatible(...) → link down (quality = down, SNR 0).

Add tests

In connectivity_service_test.go:

Test where two interfaces share the same trx → link can be up.

Test where A uses Ku band and B uses Ka (non-overlapping) → link remains down even with perfect geometry.

Acceptance

All tests green.

New tests explicitly prove:

band match → geometry decides,

band mismatch → link down even when hasLineOfSight returns true.

Chunk 3 – Multi-beam metadata & “multi-link” behaviour test

Goals

Store MaxBeams metadata (already added in Chunk 1).

Verify that Scope 2’s behaviour (“we don’t enforce concurrency yet”) is documented & tested:

one ground interface, two visible satellites, two up links at once.

What we’ll change

Mostly tests; the runtime behaviour is already permissive.

Steps

Scenario in test

In connectivity_service_test.go, add:

nodeGS with one wireless interface using a trx_ku_multi transceiver (MaxBeams = 2).

Two satellites (nodeSat1, nodeSat2) both in view above the horizon with same Ku-band radios.

Two wireless links: GS ↔ Sat1, GS ↔ Sat2.

Run connectivity

Call UpdateConnectivity().

Assertions

Both links should be IsUp == true.

Document in test name / comments that this is expected in Scope 2, and that MaxBeams is informational only.

Acceptance

Tests confirm the behaviour matches the plan: MaxBeams is stored but not enforced.

No code changes in connectivity itself (we are deliberately not enforcing concurrency in Scope 2).

Chunk 4 – Scenario loader for interfaces + links (JSON)

Goals

Move away from “everything hard-coded in main.go” to:

scenario JSON describing interfaces + links,

loader that populates KB.

This aligns with the plan’s config-driven approach.

What we’ll change

New file: core/scenario_loader.go (or cmd/simulator/scenario.go).

Update cmd/simulator/main.go to call loader instead of hard-coding net topology.

Add JSON under configs/, e.g. configs/network_scenario.json.

Steps

Define JSON schema

We already sketched:

{
  "interfaces": [ ... ],
  "links": [ ... ],
  "positions": { "nodeID": { "X": ..., "Y": ..., "Z": ... } }
}


Extend if needed to include impairment flags or IP addresses.

Implement loader

Functions like:

func LoadNetworkScenario(kb *KnowledgeBase, r io.Reader) (*Scenario, error)


which:

unmarshals JSON,

adds interfaces,

adds links,

optionally seeds initial node positions.

Integrate into main.go

Replace direct calls to AddInterface/AddNetworkLink with:

f, _ := os.Open("configs/network_scenario.json")
defer f.Close()
if _, err := core.LoadNetworkScenario(netKB, f); err != nil { panic(err) }


Add a small test

core/scenario_loader_test.go:

load a tiny in-memory JSON,

assert the KB got expected interfaces + links.

Acceptance

You can point configs/network_scenario.json at different setups without changing Go code.

go test ./... stays green.

Chunk 5 – KB Network API (NBI-ish helper functions)

Goals

Expose a clean “network API” from KB for higher layers / future scopes:

Get an interface by ID.

Get all links for an interface.

Get all up links.

Get neighbours of a node.

What we’ll change

kb/knowledge_base.go (or equivalent file where KB methods live).

Steps

Add methods like:

func (kb *KnowledgeBase) GetNetworkInterface(id string) (*NetworkInterface, bool)
func (kb *KnowledgeBase) GetNetworkLink(id string) (*NetworkLink, bool)
func (kb *KnowledgeBase) GetLinksForInterface(ifID string) []*NetworkLink
func (kb *KnowledgeBase) GetUpLinks() []*NetworkLink
func (kb *KnowledgeBase) GetNeighbours(nodeID string) []string // neighbour node IDs


GetNeighbours can:

iterate over links,

for each up link, map interface → node → neighbour.

Small refactors

Replace any ad-hoc map access in connectivity_service_test.go with these helpers where it makes sense.

Add tests

kb/network_api_test.go:

create 2–3 nodes, 3–4 links,

verify each function’s output is correct.

Acceptance

Tests show the KB network API behaves as described.

No behaviour changes to the sim; this is purely API ergonomics but aligns with the Scope 2 “NBI-ish” intention.

Chunk 6 – Manual impairments: API + simple CLI knobs

Goals

Keep the existing boolean fields (Impaired / IsOperational), but:

provide clear API functions for toggling them,

optionally wire simple CLI flags or commands in cmd/simulator so you can run quick experiments.

What we’ll change

kb/knowledge_base.go: add functions to toggle.

cmd/simulator/main.go: add basic flags or stub commands.

Steps

KB API functions

func (kb *KnowledgeBase) SetInterfaceImpaired(ifID string, impaired bool) error
func (kb *KnowledgeBase) SetLinkImpaired(linkID string, impaired bool) error


Each:

looks up the entity,

sets the flag,

returns error if not found.

Minimal CLI support (optional but nice)

Add flags like:

go run ./cmd/... --impair-link=test-link-blocked


Or read a small JSON config with initial impairments.

Tests

In core/connectivity_service_test.go, add a test:

create a link that would be up,

call SetLinkImpaired(linkID, true),

run UpdateConnectivity(),

assert link is down regardless of geometry.

Acceptance

You can programmatically impair any link/interface without reaching into structs.

Tests prove “impairment overrides geometry & range” logic.

Chunk 7 – Test matrix expansion (Scope 2 test strategy)

Goals

Bring test coverage closer to what Scope 2 describes:

ID collisions,

bad references,

adjacency consistency,

min-elevation, range cut-off, frequency mismatch, multi-sat view, etc.

What we’ll change

Mostly new tests across core and kb.

Steps

Data model tests (kb)

kb/validation_test.go:

attempt to add two interfaces with same ID → expect error.

add link referencing non-existent interface → expect error (or logged problem).

verify interface LinkIDs stays consistent when links are added/removed.

Connectivity tests (core)

Extend connectivity_service_test.go:

horizon/min elevation: one sat just below threshold → link down.

range cut-off: pre-set positions beyond MaxRangeKm → link down.

frequency mismatch: (already in Chunk 2).

multi-sat-in-view case: (already in Chunk 3).

Graph / NBI helpers tests (Chunk 5)

Ensure GetNeighbours returns the expected node set for a small topology.

Acceptance

go test ./... remains green.

Tests clearly document all behaviours the Scope 2 plan cares about.