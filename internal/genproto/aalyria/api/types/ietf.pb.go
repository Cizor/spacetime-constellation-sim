// Copyright 2024 Aalyria Technologies, Inc., and its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: api/types/ietf.proto

package types

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// A type representing an IP prefix that may optionally need an
// additional qualifier to be properly unique. This is required, for
// example, when multiple non-public IP prefixes may be referenced
// within an NMTS model (e.g., overlapping RFC 1918 networks, or
// incorrectly-allocated ULAs).
//
// The `ip_prefix` field is the approximate equivalent of
// "inet:ip-prefix" from the "ietf-inet-types" YANG module; see also
// [RFC 6991](https://rfc-editor.org/rfc/rfc6991). It contains the
// the string representation of an IPv4 or IPv6 prefix, with a CIDR
// suffix and without any zone/scope ID qualifier. Text formatting
// should follow [RFC 5952](https://rfc-editor.org/rfc/rfc5952),
// especially section 4.3.
//
// The `realm` field is an optional qualifier containing a string name
// for a "realm" that is significant within the model and sufficient
// to differentiate one instance of a non-public prefix from another.
// The name "realm" is modeled after RFC 3102/3103 Realm-specific IP,
// though this in no way implies support for this protocol.
type IPNetwork struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IpPrefix      string                 `protobuf:"bytes,1,opt,name=ip_prefix,json=ipPrefix,proto3" json:"ip_prefix,omitempty"`
	Realm         string                 `protobuf:"bytes,2,opt,name=realm,proto3" json:"realm,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPNetwork) Reset() {
	*x = IPNetwork{}
	mi := &file_api_types_ietf_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPNetwork) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPNetwork) ProtoMessage() {}

func (x *IPNetwork) ProtoReflect() protoreflect.Message {
	mi := &file_api_types_ietf_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPNetwork.ProtoReflect.Descriptor instead.
func (*IPNetwork) Descriptor() ([]byte, []int) {
	return file_api_types_ietf_proto_rawDescGZIP(), []int{0}
}

func (x *IPNetwork) GetIpPrefix() string {
	if x != nil {
		return x.IpPrefix
	}
	return ""
}

func (x *IPNetwork) GetRealm() string {
	if x != nil {
		return x.Realm
	}
	return ""
}

// The format of the `dotted_quad` string field is given by RFC 6991
// [Section 3](https://rfc-editor.org/rfc/rfc6991#section-3):
//
//	"An unsigned 32-bit number expressed in the dotted-quad
//	 notation, i.e., four octets written as decimal numbers
//	 and separated with the '.' (full stop) character."
//
// See also:
//   - [OSPFv2](https://rfc-editor.org/rfc/rfc2328#section-1.2)
//   - [OSPFv3](https://rfc-editor.org/rfc/rfc5340#section-2.11)
//
// IS-IS identifiers may be much larger, but 4-octet conventions and
// uses are common practice, e.g.:
//   - [IS-IS for IP](https://rfc-editor.org/rfc/rfc1195#section-3.3)
//   - [IS-IS TE](https://rfc-editor.org/rfc/rfc5305#section-4.3)
//
// Note: "0.0.0.0" is commonly considered RESERVED in several router
// identification and configuration contexts and SHOULD NOT be used.
type RouterId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*RouterId_DottedQuad
	//	*RouterId_U32
	Type          isRouterId_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouterId) Reset() {
	*x = RouterId{}
	mi := &file_api_types_ietf_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouterId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouterId) ProtoMessage() {}

func (x *RouterId) ProtoReflect() protoreflect.Message {
	mi := &file_api_types_ietf_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouterId.ProtoReflect.Descriptor instead.
func (*RouterId) Descriptor() ([]byte, []int) {
	return file_api_types_ietf_proto_rawDescGZIP(), []int{1}
}

func (x *RouterId) GetType() isRouterId_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *RouterId) GetDottedQuad() string {
	if x != nil {
		if x, ok := x.Type.(*RouterId_DottedQuad); ok {
			return x.DottedQuad
		}
	}
	return ""
}

func (x *RouterId) GetU32() uint32 {
	if x != nil {
		if x, ok := x.Type.(*RouterId_U32); ok {
			return x.U32
		}
	}
	return 0
}

type isRouterId_Type interface {
	isRouterId_Type()
}

type RouterId_DottedQuad struct {
	DottedQuad string `protobuf:"bytes,1,opt,name=dotted_quad,json=dottedQuad,proto3,oneof"`
}

type RouterId_U32 struct {
	U32 uint32 `protobuf:"varint,2,opt,name=u32,proto3,oneof"`
}

func (*RouterId_DottedQuad) isRouterId_Type() {}

func (*RouterId_U32) isRouterId_Type() {}

// A Segment Routing Architecture Segment Identifier (SID).
//
// One representation of a SID is as an index relative to a block of
// other identifiers. That representation is presently NOT RECOMMENDED
// here; all SIDs should be resolved to concrete data plane values
// prior to input to the model.
//
// It is not expected that networks would operate both SR-MPLS and
// SRv6 at the same time. Nevertheless, a router could conceivably
// "bridge" an SR-MPLS domain and an SRv6 domain (especially since
// an SRv6 domain can more easily span multiple administrative
// domains, whether advisable or not).
//
// Values for `mpls` fields are 20-bit unsigned integers. Zero (0),
// being reserved for the "IPv4 Explicit NULL Label", is not a valid
// SR-MPLS label value. See also:
//
//	https://rfc-editor.org/rfc/rfc3032#section-2.1
//	https://iana.org/assignments/mpls-label-values
//
// Values for `ipv6` fields may be any forwardable unicast IPv6
// address. Use of addresses from the IANA-reserved 5f00::/16 prefix
// is RECOMMENDED. Empty `IPv6Address` strings and the zero-value "::"
// are both invalid SRv6 SIDs. See also:
//
//	https://datatracker.ietf.org/doc/draft-ietf-6man-sids/
//	https://iana.org/assignments/iana-ipv6-special-registry
type SegmentId struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mpls          *uint32                `protobuf:"varint,1,opt,name=mpls,proto3,oneof" json:"mpls,omitempty"` // restricted to unsigned 20-bit values
	Ipv6          *string                `protobuf:"bytes,2,opt,name=ipv6,proto3,oneof" json:"ipv6,omitempty"`  // An IPv6 (SRv6) address.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SegmentId) Reset() {
	*x = SegmentId{}
	mi := &file_api_types_ietf_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SegmentId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SegmentId) ProtoMessage() {}

func (x *SegmentId) ProtoReflect() protoreflect.Message {
	mi := &file_api_types_ietf_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SegmentId.ProtoReflect.Descriptor instead.
func (*SegmentId) Descriptor() ([]byte, []int) {
	return file_api_types_ietf_proto_rawDescGZIP(), []int{2}
}

func (x *SegmentId) GetMpls() uint32 {
	if x != nil && x.Mpls != nil {
		return *x.Mpls
	}
	return 0
}

func (x *SegmentId) GetIpv6() string {
	if x != nil && x.Ipv6 != nil {
		return *x.Ipv6
	}
	return ""
}

var File_api_types_ietf_proto protoreflect.FileDescriptor

const file_api_types_ietf_proto_rawDesc = "" +
	"\n" +
	"\x14api/types/ietf.proto\x12\x1baalyria.spacetime.api.types\">\n" +
	"\tIPNetwork\x12\x1b\n" +
	"\tip_prefix\x18\x01 \x01(\tR\bipPrefix\x12\x14\n" +
	"\x05realm\x18\x02 \x01(\tR\x05realm\"I\n" +
	"\bRouterId\x12!\n" +
	"\vdotted_quad\x18\x01 \x01(\tH\x00R\n" +
	"dottedQuad\x12\x12\n" +
	"\x03u32\x18\x02 \x01(\rH\x00R\x03u32B\x06\n" +
	"\x04type\"O\n" +
	"\tSegmentId\x12\x17\n" +
	"\x04mpls\x18\x01 \x01(\rH\x00R\x04mpls\x88\x01\x01\x12\x17\n" +
	"\x04ipv6\x18\x02 \x01(\tH\x01R\x04ipv6\x88\x01\x01B\a\n" +
	"\x05_mplsB\a\n" +
	"\x05_ipv6BB\n" +
	"\x1fcom.aalyria.spacetime.api.typesZ\x1faalyria.com/spacetime/api/typesb\x06proto3"

var (
	file_api_types_ietf_proto_rawDescOnce sync.Once
	file_api_types_ietf_proto_rawDescData []byte
)

func file_api_types_ietf_proto_rawDescGZIP() []byte {
	file_api_types_ietf_proto_rawDescOnce.Do(func() {
		file_api_types_ietf_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_types_ietf_proto_rawDesc), len(file_api_types_ietf_proto_rawDesc)))
	})
	return file_api_types_ietf_proto_rawDescData
}

var file_api_types_ietf_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_api_types_ietf_proto_goTypes = []any{
	(*IPNetwork)(nil), // 0: aalyria.spacetime.api.types.IPNetwork
	(*RouterId)(nil),  // 1: aalyria.spacetime.api.types.RouterId
	(*SegmentId)(nil), // 2: aalyria.spacetime.api.types.SegmentId
}
var file_api_types_ietf_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_api_types_ietf_proto_init() }
func file_api_types_ietf_proto_init() {
	if File_api_types_ietf_proto != nil {
		return
	}
	file_api_types_ietf_proto_msgTypes[1].OneofWrappers = []any{
		(*RouterId_DottedQuad)(nil),
		(*RouterId_U32)(nil),
	}
	file_api_types_ietf_proto_msgTypes[2].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_types_ietf_proto_rawDesc), len(file_api_types_ietf_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_api_types_ietf_proto_goTypes,
		DependencyIndexes: file_api_types_ietf_proto_depIdxs,
		MessageInfos:      file_api_types_ietf_proto_msgTypes,
	}.Build()
	File_api_types_ietf_proto = out.File
	file_api_types_ietf_proto_goTypes = nil
	file_api_types_ietf_proto_depIdxs = nil
}
