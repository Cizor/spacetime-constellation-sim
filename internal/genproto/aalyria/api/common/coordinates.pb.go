// Copyright 2023 Aalyria Technologies, Inc., and its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file defines types for expressing the time-dynamic motion of
// platforms. Note that for many types, the motion determines the orientation
// of the platform's axes. These axes must be considered, for example, when
// modeling the antenna's gain pattern or field of regard, or interpreting the
// direction vector of a link.
// TODO: Decouple the choice of a platform's motion and its axes, and
// provide options to allow users to set the platform's axes.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: api/common/coordinates.proto

package common

import (
	interval "google.golang.org/genproto/googleapis/type/interval"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Interpolation methods listed in increasing order of their ability to fit
// complex functions.
type InterpolationMethod int32

const (
	InterpolationMethod_UNKNOWN_METHOD InterpolationMethod = 0
	// Uses linear interpolation. See
	// https://en.wikipedia.org/wiki/Linear_interpolation for reference.
	InterpolationMethod_LINEAR InterpolationMethod = 1
	// Uses a Lagrange interpolating polynomial.
	// Conceptually, this method finds the lowest-order polynomial that intersects
	// each point. See https://en.wikipedia.org/wiki/Lagrange_polynomial for
	// reference.
	InterpolationMethod_LAGRANGE InterpolationMethod = 2
	// Uses a Hermite interpolating polynomial.
	// Conceptually, this method finds the lowest-order polynomial that not only
	// intersects each point but also matches the derivatives of the function.
	// See https://en.wikipedia.org/wiki/Hermite_interpolation for reference.
	InterpolationMethod_HERMITIAN InterpolationMethod = 3
)

// Enum value maps for InterpolationMethod.
var (
	InterpolationMethod_name = map[int32]string{
		0: "UNKNOWN_METHOD",
		1: "LINEAR",
		2: "LAGRANGE",
		3: "HERMITIAN",
	}
	InterpolationMethod_value = map[string]int32{
		"UNKNOWN_METHOD": 0,
		"LINEAR":         1,
		"LAGRANGE":       2,
		"HERMITIAN":      3,
	}
)

func (x InterpolationMethod) Enum() *InterpolationMethod {
	p := new(InterpolationMethod)
	*p = x
	return p
}

func (x InterpolationMethod) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InterpolationMethod) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_coordinates_proto_enumTypes[0].Descriptor()
}

func (InterpolationMethod) Type() protoreflect.EnumType {
	return &file_api_common_coordinates_proto_enumTypes[0]
}

func (x InterpolationMethod) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *InterpolationMethod) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = InterpolationMethod(num)
	return nil
}

// Deprecated: Use InterpolationMethod.Descriptor instead.
func (InterpolationMethod) EnumDescriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{0}
}

// Celestial bodies.
type CentralBody int32

const (
	CentralBody_UNKNOWN_CENTRAL_BODY CentralBody = 0
	CentralBody_EARTH                CentralBody = 1
	CentralBody_MOON                 CentralBody = 2
)

// Enum value maps for CentralBody.
var (
	CentralBody_name = map[int32]string{
		0: "UNKNOWN_CENTRAL_BODY",
		1: "EARTH",
		2: "MOON",
	}
	CentralBody_value = map[string]int32{
		"UNKNOWN_CENTRAL_BODY": 0,
		"EARTH":                1,
		"MOON":                 2,
	}
)

func (x CentralBody) Enum() *CentralBody {
	p := new(CentralBody)
	*p = x
	return p
}

func (x CentralBody) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CentralBody) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_coordinates_proto_enumTypes[1].Descriptor()
}

func (CentralBody) Type() protoreflect.EnumType {
	return &file_api_common_coordinates_proto_enumTypes[1]
}

func (x CentralBody) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *CentralBody) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = CentralBody(num)
	return nil
}

// Deprecated: Use CentralBody.Descriptor instead.
func (CentralBody) EnumDescriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{1}
}

// Additional values are unlikely to be added.
type Geodetic_VerticalDatum int32

const (
	Geodetic_VERTICAL_DATUM_UNSPECIFIED Geodetic_VerticalDatum = 0
	Geodetic_WGS84_ELLIPSOID            Geodetic_VerticalDatum = 1
	Geodetic_MEAN_SEA_LEVEL             Geodetic_VerticalDatum = 2
)

// Enum value maps for Geodetic_VerticalDatum.
var (
	Geodetic_VerticalDatum_name = map[int32]string{
		0: "VERTICAL_DATUM_UNSPECIFIED",
		1: "WGS84_ELLIPSOID",
		2: "MEAN_SEA_LEVEL",
	}
	Geodetic_VerticalDatum_value = map[string]int32{
		"VERTICAL_DATUM_UNSPECIFIED": 0,
		"WGS84_ELLIPSOID":            1,
		"MEAN_SEA_LEVEL":             2,
	}
)

func (x Geodetic_VerticalDatum) Enum() *Geodetic_VerticalDatum {
	p := new(Geodetic_VerticalDatum)
	*p = x
	return p
}

func (x Geodetic_VerticalDatum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Geodetic_VerticalDatum) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_coordinates_proto_enumTypes[2].Descriptor()
}

func (Geodetic_VerticalDatum) Type() protoreflect.EnumType {
	return &file_api_common_coordinates_proto_enumTypes[2]
}

func (x Geodetic_VerticalDatum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Geodetic_VerticalDatum) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Geodetic_VerticalDatum(num)
	return nil
}

// Deprecated: Use Geodetic_VerticalDatum.Descriptor instead.
func (Geodetic_VerticalDatum) EnumDescriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{2, 0}
}

type StateVector_CoordinateFrame int32

const (
	// The frame should always be known; using this must indicate some error.
	StateVector_UNKNOWN_FRAME StateVector_CoordinateFrame = 0
	// This indicates the frame used for most E-M Lagrange point orbit studies.
	// It is a natural and convenient way to input L1/L2 orbits.
	StateVector_EARTH_MOON_BARYCENTER_SYNODIC_FRAME StateVector_CoordinateFrame = 1
	// Internally, ECEF is used most everywhere else in our software.
	StateVector_ECEF_FRAME StateVector_CoordinateFrame = 2
)

// Enum value maps for StateVector_CoordinateFrame.
var (
	StateVector_CoordinateFrame_name = map[int32]string{
		0: "UNKNOWN_FRAME",
		1: "EARTH_MOON_BARYCENTER_SYNODIC_FRAME",
		2: "ECEF_FRAME",
	}
	StateVector_CoordinateFrame_value = map[string]int32{
		"UNKNOWN_FRAME":                       0,
		"EARTH_MOON_BARYCENTER_SYNODIC_FRAME": 1,
		"ECEF_FRAME":                          2,
	}
)

func (x StateVector_CoordinateFrame) Enum() *StateVector_CoordinateFrame {
	p := new(StateVector_CoordinateFrame)
	*p = x
	return p
}

func (x StateVector_CoordinateFrame) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StateVector_CoordinateFrame) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_coordinates_proto_enumTypes[3].Descriptor()
}

func (StateVector_CoordinateFrame) Type() protoreflect.EnumType {
	return &file_api_common_coordinates_proto_enumTypes[3]
}

func (x StateVector_CoordinateFrame) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *StateVector_CoordinateFrame) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = StateVector_CoordinateFrame(num)
	return nil
}

// Deprecated: Use StateVector_CoordinateFrame.Descriptor instead.
func (StateVector_CoordinateFrame) EnumDescriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{16, 0}
}

type StateVector_PropagationAlgorithm int32

const (
	// Generally, a particular class of algorithm should be specified instead.
	StateVector_UNSPECIFIED_ALGORITHM StateVector_PropagationAlgorithm = 0
	// State vector for a vehicle in cislunar space, that should be
	// propagated using a three-body algorithm considering the Earth and
	// Moon's gravity contributions.
	StateVector_EARTH_MOON_THREE_BODY_NUMERICAL_ALGORITHM StateVector_PropagationAlgorithm = 1
)

// Enum value maps for StateVector_PropagationAlgorithm.
var (
	StateVector_PropagationAlgorithm_name = map[int32]string{
		0: "UNSPECIFIED_ALGORITHM",
		1: "EARTH_MOON_THREE_BODY_NUMERICAL_ALGORITHM",
	}
	StateVector_PropagationAlgorithm_value = map[string]int32{
		"UNSPECIFIED_ALGORITHM":                     0,
		"EARTH_MOON_THREE_BODY_NUMERICAL_ALGORITHM": 1,
	}
)

func (x StateVector_PropagationAlgorithm) Enum() *StateVector_PropagationAlgorithm {
	p := new(StateVector_PropagationAlgorithm)
	*p = x
	return p
}

func (x StateVector_PropagationAlgorithm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StateVector_PropagationAlgorithm) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_coordinates_proto_enumTypes[4].Descriptor()
}

func (StateVector_PropagationAlgorithm) Type() protoreflect.EnumType {
	return &file_api_common_coordinates_proto_enumTypes[4]
}

func (x StateVector_PropagationAlgorithm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *StateVector_PropagationAlgorithm) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = StateVector_PropagationAlgorithm(num)
	return nil
}

// Deprecated: Use StateVector_PropagationAlgorithm.Descriptor instead.
func (StateVector_PropagationAlgorithm) EnumDescriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{16, 1}
}

// This enum is used in various other messages, e.g. Targeting, to reference
// supported or required motion description formats.
//
// The enum values are kept deliberately in sync with the field values in the
// oneof below, but this is not stricly required in order to read the
// contents of the oneof.  In this case it suffices to use the
// protobuf-constructed language-specific support for switch statements
// (which, for C++ and Java for example, generates a language-appropriate
// enum to use).
type Motion_Type int32

const (
	Motion_MOTION_UNSPECIFIED     Motion_Type = 0
	Motion_GEODETIC_MSL           Motion_Type = 7
	Motion_GEODETIC_WGS84         Motion_Type = 1
	Motion_ECEF_FIXED             Motion_Type = 2
	Motion_ECEF_INTERPOLATION     Motion_Type = 3
	Motion_CARTOGRAPHIC_WAYPOINTS Motion_Type = 4
	Motion_GEODETIC_WAYPOINTS     Motion_Type = 12
	Motion_TLE                    Motion_Type = 5
	Motion_KEPLERIAN_ELEMENTS     Motion_Type = 6
	// WARNING: This message is under development and not fully supported.
	Motion_STATE_VECTOR                  Motion_Type = 9
	Motion_SELENOGRAPHIC_MLR             Motion_Type = 8
	Motion_STK_EPHEM_AND_ATTITUDE_FILE   Motion_Type = 11
	Motion_CCSDS_ORBIT_EPHEMERIS_MESSAGE Motion_Type = 13
)

// Enum value maps for Motion_Type.
var (
	Motion_Type_name = map[int32]string{
		0:  "MOTION_UNSPECIFIED",
		7:  "GEODETIC_MSL",
		1:  "GEODETIC_WGS84",
		2:  "ECEF_FIXED",
		3:  "ECEF_INTERPOLATION",
		4:  "CARTOGRAPHIC_WAYPOINTS",
		12: "GEODETIC_WAYPOINTS",
		5:  "TLE",
		6:  "KEPLERIAN_ELEMENTS",
		9:  "STATE_VECTOR",
		8:  "SELENOGRAPHIC_MLR",
		11: "STK_EPHEM_AND_ATTITUDE_FILE",
		13: "CCSDS_ORBIT_EPHEMERIS_MESSAGE",
	}
	Motion_Type_value = map[string]int32{
		"MOTION_UNSPECIFIED":            0,
		"GEODETIC_MSL":                  7,
		"GEODETIC_WGS84":                1,
		"ECEF_FIXED":                    2,
		"ECEF_INTERPOLATION":            3,
		"CARTOGRAPHIC_WAYPOINTS":        4,
		"GEODETIC_WAYPOINTS":            12,
		"TLE":                           5,
		"KEPLERIAN_ELEMENTS":            6,
		"STATE_VECTOR":                  9,
		"SELENOGRAPHIC_MLR":             8,
		"STK_EPHEM_AND_ATTITUDE_FILE":   11,
		"CCSDS_ORBIT_EPHEMERIS_MESSAGE": 13,
	}
)

func (x Motion_Type) Enum() *Motion_Type {
	p := new(Motion_Type)
	*p = x
	return p
}

func (x Motion_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Motion_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_coordinates_proto_enumTypes[5].Descriptor()
}

func (Motion_Type) Type() protoreflect.EnumType {
	return &file_api_common_coordinates_proto_enumTypes[5]
}

func (x Motion_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *Motion_Type) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = Motion_Type(num)
	return nil
}

// Deprecated: Use Motion_Type.Descriptor instead.
func (Motion_Type) EnumDescriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{22, 0}
}

// GeodeticWgs84, GeodeticMsl, and Geodetic are sets of curvilinear
// 3D coordinates with different vertical datum. These are natural
// choices to describe the motion of terrestrial platforms.
//
// Note that Spacetime's wireless propagation analysis considers the presence
// of terrain as a potential obstruction to wireless links. Therefore, when
// modeling terrestrial platforms, ensure that the height situates the
// platform above the terrain at that point. For example, suppose a fixed
// user terminal were located on a mountainside. If the height of
// the platform representing this user terminal were set to 0m, this user
// terminal would be considered to be "under" the mountain, and therefore, would
// not be able to form any wireless links.
// TODO: Add an option to clamp a platform to the height of the terrain
// at a given point.
//
// When a platform's motion is described using GeodeticWgs84, GeodeticMsl, or
// Geodetic, the platform's axes are oriented in the Earth's reference frame,
// such that:
//   - The x-axis points in the local East direction.
//   - The y-axis points in the local North direction.
//   - The z-axis points in the direction of the normal vector to the WGS 84
//     ellipsoid surface which passes through the point. Conceptually, the
//     z-axis is oriented "outwards" from the Earth's surface towards space.
type GeodeticWgs84 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to 0.
	LongitudeDeg *float64 `protobuf:"fixed64,1,opt,name=longitude_deg,json=longitudeDeg" json:"longitude_deg,omitempty"`
	// Defaults to 0.
	LatitudeDeg *float64 `protobuf:"fixed64,2,opt,name=latitude_deg,json=latitudeDeg" json:"latitude_deg,omitempty"`
	// The height is relative to the WGS84 ellipsoid. For reference on the
	// vertical datum used, see the World Geodetic System - 1984 (WGS-84) Manual
	// (Doc 9674 of the International Civil Aviation Organization).
	// Defaults to 0.
	HeightWgs84M  *float64 `protobuf:"fixed64,3,opt,name=height_wgs84_m,json=heightWgs84M" json:"height_wgs84_m,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeodeticWgs84) Reset() {
	*x = GeodeticWgs84{}
	mi := &file_api_common_coordinates_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeodeticWgs84) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeodeticWgs84) ProtoMessage() {}

func (x *GeodeticWgs84) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeodeticWgs84.ProtoReflect.Descriptor instead.
func (*GeodeticWgs84) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{0}
}

func (x *GeodeticWgs84) GetLongitudeDeg() float64 {
	if x != nil && x.LongitudeDeg != nil {
		return *x.LongitudeDeg
	}
	return 0
}

func (x *GeodeticWgs84) GetLatitudeDeg() float64 {
	if x != nil && x.LatitudeDeg != nil {
		return *x.LatitudeDeg
	}
	return 0
}

func (x *GeodeticWgs84) GetHeightWgs84M() float64 {
	if x != nil && x.HeightWgs84M != nil {
		return *x.HeightWgs84M
	}
	return 0
}

// See above for notes on this type.
type GeodeticMsl struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to 0.
	LongitudeDeg *float64 `protobuf:"fixed64,1,opt,name=longitude_deg,json=longitudeDeg" json:"longitude_deg,omitempty"`
	// Defaults to 0.
	LatitudeDeg *float64 `protobuf:"fixed64,2,opt,name=latitude_deg,json=latitudeDeg" json:"latitude_deg,omitempty"`
	// The height is relative to mean sea level.
	// Defaults to 0.
	HeightMslM    *float64 `protobuf:"fixed64,3,opt,name=height_msl_m,json=heightMslM" json:"height_msl_m,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeodeticMsl) Reset() {
	*x = GeodeticMsl{}
	mi := &file_api_common_coordinates_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeodeticMsl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeodeticMsl) ProtoMessage() {}

func (x *GeodeticMsl) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeodeticMsl.ProtoReflect.Descriptor instead.
func (*GeodeticMsl) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{1}
}

func (x *GeodeticMsl) GetLongitudeDeg() float64 {
	if x != nil && x.LongitudeDeg != nil {
		return *x.LongitudeDeg
	}
	return 0
}

func (x *GeodeticMsl) GetLatitudeDeg() float64 {
	if x != nil && x.LatitudeDeg != nil {
		return *x.LatitudeDeg
	}
	return 0
}

func (x *GeodeticMsl) GetHeightMslM() float64 {
	if x != nil && x.HeightMslM != nil {
		return *x.HeightMslM
	}
	return 0
}

// An alternate way to specify GeodeticWgs84 or GeodeticMsl coordinates, used by
// GeodeticTemporalInterpolation to define a platform's motion.
// See above for notes on this type.
type Geodetic struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to 0.
	LongitudeDeg *float64 `protobuf:"fixed64,2,opt,name=longitude_deg,json=longitudeDeg" json:"longitude_deg,omitempty"`
	// Defaults to 0.
	LatitudeDeg *float64 `protobuf:"fixed64,1,opt,name=latitude_deg,json=latitudeDeg" json:"latitude_deg,omitempty"`
	// Defaults to 0.
	HeightM *float64 `protobuf:"fixed64,3,opt,name=height_m,json=heightM" json:"height_m,omitempty"`
	// Defaults to 0.
	VerticalDatum *Geodetic_VerticalDatum `protobuf:"varint,4,opt,name=vertical_datum,json=verticalDatum,enum=aalyria.spacetime.api.common.Geodetic_VerticalDatum" json:"vertical_datum,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Geodetic) Reset() {
	*x = Geodetic{}
	mi := &file_api_common_coordinates_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Geodetic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Geodetic) ProtoMessage() {}

func (x *Geodetic) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Geodetic.ProtoReflect.Descriptor instead.
func (*Geodetic) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{2}
}

func (x *Geodetic) GetLongitudeDeg() float64 {
	if x != nil && x.LongitudeDeg != nil {
		return *x.LongitudeDeg
	}
	return 0
}

func (x *Geodetic) GetLatitudeDeg() float64 {
	if x != nil && x.LatitudeDeg != nil {
		return *x.LatitudeDeg
	}
	return 0
}

func (x *Geodetic) GetHeightM() float64 {
	if x != nil && x.HeightM != nil {
		return *x.HeightM
	}
	return 0
}

func (x *Geodetic) GetVerticalDatum() Geodetic_VerticalDatum {
	if x != nil && x.VerticalDatum != nil {
		return *x.VerticalDatum
	}
	return Geodetic_VERTICAL_DATUM_UNSPECIFIED
}

// A timestamped GeodeticWgs84 coordinate.
type GeodeticWgs84Temporal struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required.
	Point *GeodeticWgs84 `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	// Required.
	Time          *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=time" json:"time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeodeticWgs84Temporal) Reset() {
	*x = GeodeticWgs84Temporal{}
	mi := &file_api_common_coordinates_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeodeticWgs84Temporal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeodeticWgs84Temporal) ProtoMessage() {}

func (x *GeodeticWgs84Temporal) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeodeticWgs84Temporal.ProtoReflect.Descriptor instead.
func (*GeodeticWgs84Temporal) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{3}
}

func (x *GeodeticWgs84Temporal) GetPoint() *GeodeticWgs84 {
	if x != nil {
		return x.Point
	}
	return nil
}

func (x *GeodeticWgs84Temporal) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

// A timestamped Geodetic coordinate.
type GeodeticTemporal struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required.
	Point *Geodetic `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	// Required.
	Time          *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=time" json:"time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GeodeticTemporal) Reset() {
	*x = GeodeticTemporal{}
	mi := &file_api_common_coordinates_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeodeticTemporal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeodeticTemporal) ProtoMessage() {}

func (x *GeodeticTemporal) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeodeticTemporal.ProtoReflect.Descriptor instead.
func (*GeodeticTemporal) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{4}
}

func (x *GeodeticTemporal) GetPoint() *Geodetic {
	if x != nil {
		return x.Point
	}
	return nil
}

func (x *GeodeticTemporal) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

// A set of rectilinear 3D coordinates described as (x, y, z) in meters.
// This type is often used to represent a 3D position vector.
type Cartesian struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to 0.
	XM *float64 `protobuf:"fixed64,1,opt,name=x_m,json=xM" json:"x_m,omitempty"`
	// Defaults to 0.
	YM *float64 `protobuf:"fixed64,2,opt,name=y_m,json=yM" json:"y_m,omitempty"`
	// Defaults to 0.
	ZM            *float64 `protobuf:"fixed64,3,opt,name=z_m,json=zM" json:"z_m,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cartesian) Reset() {
	*x = Cartesian{}
	mi := &file_api_common_coordinates_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cartesian) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cartesian) ProtoMessage() {}

func (x *Cartesian) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cartesian.ProtoReflect.Descriptor instead.
func (*Cartesian) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{5}
}

func (x *Cartesian) GetXM() float64 {
	if x != nil && x.XM != nil {
		return *x.XM
	}
	return 0
}

func (x *Cartesian) GetYM() float64 {
	if x != nil && x.YM != nil {
		return *x.YM
	}
	return 0
}

func (x *Cartesian) GetZM() float64 {
	if x != nil && x.ZM != nil {
		return *x.ZM
	}
	return 0
}

// A 3D rotational coordinate that describes an angular rotation about an
// arbitrary axis. See
// https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation for reference.
// Quaternions are generally represented in the form:
//
//	w + xi + yj + zk
//
// where x, y, z, and w are real numbers, and i, j, and k are three imaginary
// numbers. 3D rotations are also commonly represented as Euler angles, such as
// yaw, pitch, and roll. See
// https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
// for how to convert between this representation and quaternions.
// The quaternion is interpreted as the identity if none of the fields are set.
//
// A note about axes defined in terms of quaternion transformations from parent
// reference frames: Let A be a fixed point in space. Let v be A's cartesian
// coordinates in the axes reference frame and w A's cartesian coordinates in
// the parent reference frame. You can use the unit quaternion q below to
// compute
//
//	w = q*v*q'    or    v = q'*w*q
//
// where q' is the conjugate of q and * denotes quaternion multiplication. Note
// that in the formulas above the 3-vectors v and w are treated as quaternions
// whose real part is zero and whose imaginary components correspond to the
// respective components of the 3-vectors. Note also that since q is a unit
// quaternion, q' can be computed simply by negating the three imaginary
// components of q.
// TODO: Migrate uses of this to google.type.Quaternion.
type Quaternion struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to 0.
	W *float64 `protobuf:"fixed64,1,opt,name=w" json:"w,omitempty"`
	// Defaults to 0.
	X *float64 `protobuf:"fixed64,2,opt,name=x" json:"x,omitempty"`
	// Defaults to 0.
	Y *float64 `protobuf:"fixed64,3,opt,name=y" json:"y,omitempty"`
	// Defaults to 0.
	Z             *float64 `protobuf:"fixed64,4,opt,name=z" json:"z,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Quaternion) Reset() {
	*x = Quaternion{}
	mi := &file_api_common_coordinates_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Quaternion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Quaternion) ProtoMessage() {}

func (x *Quaternion) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Quaternion.ProtoReflect.Descriptor instead.
func (*Quaternion) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{6}
}

func (x *Quaternion) GetW() float64 {
	if x != nil && x.W != nil {
		return *x.W
	}
	return 0
}

func (x *Quaternion) GetX() float64 {
	if x != nil && x.X != nil {
		return *x.X
	}
	return 0
}

func (x *Quaternion) GetY() float64 {
	if x != nil && x.Y != nil {
		return *x.Y
	}
	return 0
}

func (x *Quaternion) GetZ() float64 {
	if x != nil && x.Z != nil {
		return *x.Z
	}
	return 0
}

// A rotational coordinate that represents a sequence of rotations about a
// reference set of axes. For an aircraft, yaw corresponds to the heading angle,
// pitch corresponds to the elevation angle, and roll corresponds to the bank
// angle.
type YawPitchRoll struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to 0.
	YawDeg *float64 `protobuf:"fixed64,1,opt,name=yaw_deg,json=yawDeg" json:"yaw_deg,omitempty"`
	// Defaults to 0.
	PitchDeg *float64 `protobuf:"fixed64,2,opt,name=pitch_deg,json=pitchDeg" json:"pitch_deg,omitempty"`
	// Defaults to 0.
	RollDeg       *float64 `protobuf:"fixed64,3,opt,name=roll_deg,json=rollDeg" json:"roll_deg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *YawPitchRoll) Reset() {
	*x = YawPitchRoll{}
	mi := &file_api_common_coordinates_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *YawPitchRoll) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*YawPitchRoll) ProtoMessage() {}

func (x *YawPitchRoll) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use YawPitchRoll.ProtoReflect.Descriptor instead.
func (*YawPitchRoll) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{7}
}

func (x *YawPitchRoll) GetYawDeg() float64 {
	if x != nil && x.YawDeg != nil {
		return *x.YawDeg
	}
	return 0
}

func (x *YawPitchRoll) GetPitchDeg() float64 {
	if x != nil && x.PitchDeg != nil {
		return *x.PitchDeg
	}
	return 0
}

func (x *YawPitchRoll) GetRollDeg() float64 {
	if x != nil && x.RollDeg != nil {
		return *x.RollDeg
	}
	return 0
}

// A point in user-defined axes.
type PointAxes struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required.
	Point *Cartesian `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	// These axes are interpreted as an offset from the Earth-centered,
	// Earth-fixed reference frame. If this field is unset, the platform's axes
	// will be the Earth-centered, Earth-fixed reference frame.
	//
	// The quaternion q satisfies w = q*v*q' where v is a point in the axes'
	// coordinate frame, and w is that same point in the parent reference frame
	// (i.e. the same frame in which the "point" is specified).
	// Required.
	Axes          *Quaternion `protobuf:"bytes,2,opt,name=axes" json:"axes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PointAxes) Reset() {
	*x = PointAxes{}
	mi := &file_api_common_coordinates_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PointAxes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PointAxes) ProtoMessage() {}

func (x *PointAxes) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PointAxes.ProtoReflect.Descriptor instead.
func (*PointAxes) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{8}
}

func (x *PointAxes) GetPoint() *Cartesian {
	if x != nil {
		return x.Point
	}
	return nil
}

func (x *PointAxes) GetAxes() *Quaternion {
	if x != nil {
		return x.Axes
	}
	return nil
}

// A timestamped point in user-defined axes.
type PointAxesTemporal struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required.
	Point *Cartesian `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	// These axes are interpreted as an offset from the Earth-centered,
	// Earth-fixed reference frame. If this field is unset, the platform's axes
	// will be the Earth-centered, Earth-fixed reference frame.
	//
	// The quaternion q satisfies w = q*v*q' where v is a point in the axes'
	// coordinate frame, and w is that same point in the parent reference frame
	// (i.e. the same frame in which the "point" is specified).
	// Required.
	Axes *Quaternion `protobuf:"bytes,2,opt,name=axes" json:"axes,omitempty"`
	// TODO: Migrate to Timestamp.
	// Required.
	GpsTime *GpsTime `protobuf:"bytes,4,opt,name=gps_time,json=gpsTime" json:"gps_time,omitempty"`
	// WARNING: To specify a time with this point, the gps_time field above must
	// be used, and this field will not be considered. This field is used by the
	// Spacetime UI.
	Time          *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=time" json:"time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PointAxesTemporal) Reset() {
	*x = PointAxesTemporal{}
	mi := &file_api_common_coordinates_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PointAxesTemporal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PointAxesTemporal) ProtoMessage() {}

func (x *PointAxesTemporal) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PointAxesTemporal.ProtoReflect.Descriptor instead.
func (*PointAxesTemporal) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{9}
}

func (x *PointAxesTemporal) GetPoint() *Cartesian {
	if x != nil {
		return x.Point
	}
	return nil
}

func (x *PointAxesTemporal) GetAxes() *Quaternion {
	if x != nil {
		return x.Axes
	}
	return nil
}

func (x *PointAxesTemporal) GetGpsTime() *GpsTime {
	if x != nil {
		return x.GpsTime
	}
	return nil
}

func (x *PointAxesTemporal) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

// PointAxesTemporalInterpolation, GeodeticWgs84TemporalInterpolation, and
// GeodeticTemporalInterpolation specify a list of points and orientations over
// time. Both the translational and rotational coordinates are interpolated
// to calculate the position and orientation of the platform at a given
// timestamp. This is a natural choice to express the motion of platforms with a
// known trajectory, such as an aircraft, ship, or launch vehicle.
//
// These types are commonly used in conjunction with a gRPC client that
// periodically updates the motion of a platform across the NBI. Imagine there
// is an airborne vehicle carrying a sensor that needs to constantly stream
// data to a Command Center, and an Ops Center that is tracking the
// position of this airbone vehicle. A lightweight script or binary can ingest
// the position observations from the Ops Center and then update, via the NBI,
// the corresponding Spacetime platform's position in real-time. This allows
// Spacetime to orchestrate constant connectivity between the airborne vehicle
// and the Command Center.
//
// A "location updater" job, similar to the scenario described above, could use
// one of PointAxesTemporalInterpolation, GeodeticWgs84TemporalInterpolation, or
// GeodeticTemporalInterpolation to describe the motion of a mobile platform.
// This job would simply append points to the locations_orientations_over_time
// or locations_over_time fields below in real-time.
// WARNING: If this job always set the timestamp of each observation to
// the current timestamp and the list contained no points in the future, you
// likely would not see the platform in the "live" Spacetime UI. By the time the
// request had been sent across the NBI, the timestamp would have already
// passed, so the "live" view of the Spacetime UI would not have location data
// to interpolate and render. To see the platform in the UI, either:
//  1. if available, store one or more predicted future points based on the
//     platform's trajectory in the locations_over_time field
//  2. if your network can tolerate it, or for non-production purposes, shift
//     the timestamp of each point into the future so that at least one
//     point in the future always exists within the locations_over_time field
//
// TODO: Implement a configurable approach to remove the oldest points in
// the locations list to prevent this list from growing to an unbounded size.
type PointAxesTemporalInterpolation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If no axes are specified, the platform's axes will match the
	// Earth-centered, Earth-fixed reference frame.
	LocationsOrientationsOverTime []*PointAxesTemporal `protobuf:"bytes,1,rep,name=locations_orientations_over_time,json=locationsOrientationsOverTime" json:"locations_orientations_over_time,omitempty"`
	InterpolationMethod           *InterpolationMethod `protobuf:"varint,2,opt,name=interpolation_method,json=interpolationMethod,enum=aalyria.spacetime.api.common.InterpolationMethod,def=1" json:"interpolation_method,omitempty"`
	// The degree of the polynomial to use for interpolation.
	InterpolationDegree *int32 `protobuf:"varint,3,opt,name=interpolation_degree,json=interpolationDegree,def=1" json:"interpolation_degree,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

// Default values for PointAxesTemporalInterpolation fields.
const (
	Default_PointAxesTemporalInterpolation_InterpolationMethod = InterpolationMethod_LINEAR
	Default_PointAxesTemporalInterpolation_InterpolationDegree = int32(1)
)

func (x *PointAxesTemporalInterpolation) Reset() {
	*x = PointAxesTemporalInterpolation{}
	mi := &file_api_common_coordinates_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PointAxesTemporalInterpolation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PointAxesTemporalInterpolation) ProtoMessage() {}

func (x *PointAxesTemporalInterpolation) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PointAxesTemporalInterpolation.ProtoReflect.Descriptor instead.
func (*PointAxesTemporalInterpolation) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{10}
}

func (x *PointAxesTemporalInterpolation) GetLocationsOrientationsOverTime() []*PointAxesTemporal {
	if x != nil {
		return x.LocationsOrientationsOverTime
	}
	return nil
}

func (x *PointAxesTemporalInterpolation) GetInterpolationMethod() InterpolationMethod {
	if x != nil && x.InterpolationMethod != nil {
		return *x.InterpolationMethod
	}
	return Default_PointAxesTemporalInterpolation_InterpolationMethod
}

func (x *PointAxesTemporalInterpolation) GetInterpolationDegree() int32 {
	if x != nil && x.InterpolationDegree != nil {
		return *x.InterpolationDegree
	}
	return Default_PointAxesTemporalInterpolation_InterpolationDegree
}

// See above for notes on this type.
type GeodeticWgs84TemporalInterpolation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The platform's axes are oriented in the Earth's reference frame, such that:
	//   - The x-axis points in the local East direction.
	//   - The y-axis points in the local North direction.
	//   - The z-axis points in the direction of the normal vector to the WGS 84
	//     ellipsoid surface which passes through the point. Conceptually,
	//     the z-axis is oriented "outwards" from the Earth's surface towards
	//     space.
	LocationsOverTime   []*GeodeticWgs84Temporal `protobuf:"bytes,1,rep,name=locations_over_time,json=locationsOverTime" json:"locations_over_time,omitempty"`
	InterpolationMethod *InterpolationMethod     `protobuf:"varint,2,opt,name=interpolation_method,json=interpolationMethod,enum=aalyria.spacetime.api.common.InterpolationMethod,def=1" json:"interpolation_method,omitempty"`
	// The degree of the polynomial to use for interpolation.
	InterpolationDegree *int32 `protobuf:"varint,3,opt,name=interpolation_degree,json=interpolationDegree,def=1" json:"interpolation_degree,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

// Default values for GeodeticWgs84TemporalInterpolation fields.
const (
	Default_GeodeticWgs84TemporalInterpolation_InterpolationMethod = InterpolationMethod_LINEAR
	Default_GeodeticWgs84TemporalInterpolation_InterpolationDegree = int32(1)
)

func (x *GeodeticWgs84TemporalInterpolation) Reset() {
	*x = GeodeticWgs84TemporalInterpolation{}
	mi := &file_api_common_coordinates_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeodeticWgs84TemporalInterpolation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeodeticWgs84TemporalInterpolation) ProtoMessage() {}

func (x *GeodeticWgs84TemporalInterpolation) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeodeticWgs84TemporalInterpolation.ProtoReflect.Descriptor instead.
func (*GeodeticWgs84TemporalInterpolation) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{11}
}

func (x *GeodeticWgs84TemporalInterpolation) GetLocationsOverTime() []*GeodeticWgs84Temporal {
	if x != nil {
		return x.LocationsOverTime
	}
	return nil
}

func (x *GeodeticWgs84TemporalInterpolation) GetInterpolationMethod() InterpolationMethod {
	if x != nil && x.InterpolationMethod != nil {
		return *x.InterpolationMethod
	}
	return Default_GeodeticWgs84TemporalInterpolation_InterpolationMethod
}

func (x *GeodeticWgs84TemporalInterpolation) GetInterpolationDegree() int32 {
	if x != nil && x.InterpolationDegree != nil {
		return *x.InterpolationDegree
	}
	return Default_GeodeticWgs84TemporalInterpolation_InterpolationDegree
}

// See above for notes on this type.
type GeodeticTemporalInterpolation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The platform's axes are oriented in the Earth's reference frame, such that:
	//   - The x-axis points in the local East direction.
	//   - The y-axis points in the local North direction.
	//   - The z-axis points in the direction of the normal vector to the WGS 84
	//     ellipsoid surface which passes through the point. Conceptually,
	//     the z-axis is oriented "outwards" from the Earth's surface towards
	//     space.
	LocationsOverTime   []*GeodeticTemporal  `protobuf:"bytes,1,rep,name=locations_over_time,json=locationsOverTime" json:"locations_over_time,omitempty"`
	InterpolationMethod *InterpolationMethod `protobuf:"varint,2,opt,name=interpolation_method,json=interpolationMethod,enum=aalyria.spacetime.api.common.InterpolationMethod,def=1" json:"interpolation_method,omitempty"`
	// The degree of the polynomial to use for interpolation.
	InterpolationDegree *int32 `protobuf:"varint,3,opt,name=interpolation_degree,json=interpolationDegree,def=1" json:"interpolation_degree,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

// Default values for GeodeticTemporalInterpolation fields.
const (
	Default_GeodeticTemporalInterpolation_InterpolationMethod = InterpolationMethod_LINEAR
	Default_GeodeticTemporalInterpolation_InterpolationDegree = int32(1)
)

func (x *GeodeticTemporalInterpolation) Reset() {
	*x = GeodeticTemporalInterpolation{}
	mi := &file_api_common_coordinates_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GeodeticTemporalInterpolation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GeodeticTemporalInterpolation) ProtoMessage() {}

func (x *GeodeticTemporalInterpolation) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GeodeticTemporalInterpolation.ProtoReflect.Descriptor instead.
func (*GeodeticTemporalInterpolation) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{12}
}

func (x *GeodeticTemporalInterpolation) GetLocationsOverTime() []*GeodeticTemporal {
	if x != nil {
		return x.LocationsOverTime
	}
	return nil
}

func (x *GeodeticTemporalInterpolation) GetInterpolationMethod() InterpolationMethod {
	if x != nil && x.InterpolationMethod != nil {
		return *x.InterpolationMethod
	}
	return Default_GeodeticTemporalInterpolation_InterpolationMethod
}

func (x *GeodeticTemporalInterpolation) GetInterpolationDegree() int32 {
	if x != nil && x.InterpolationDegree != nil {
		return *x.InterpolationDegree
	}
	return Default_GeodeticTemporalInterpolation_InterpolationDegree
}

// A two-line element set (TLE).
// TLEs for some unclassified objects are publicly available at
// https://celestrak.org. See https://en.wikipedia.org/wiki/Two-line_element_set
// for reference.
// When a platform's motion is described using this message, the platform's axes
// are oriented in the Earth's inertial frame, such that:
//   - The x-axis is aligned with the platform's velocity vector.
//   - The y-axis is aligned with the negative angular momentum vector.
//   - The z-axis is aligned with the negative position vector, which points
//     towards the Earth's center of mass.
//
// For reference, see The Consultative Committee for Space Data Systems
// CCSDS 500.0-G-4 Section 4.3.7.2.
// The orbit is propagated using the NORAD SGP4/SDP4 model as defined by the
// Center for Space Standards and Innovation (CSSI).
type TwoLineElementSet struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Line1         *string                `protobuf:"bytes,1,opt,name=line1" json:"line1,omitempty"`
	Line2         *string                `protobuf:"bytes,2,opt,name=line2" json:"line2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TwoLineElementSet) Reset() {
	*x = TwoLineElementSet{}
	mi := &file_api_common_coordinates_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TwoLineElementSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TwoLineElementSet) ProtoMessage() {}

func (x *TwoLineElementSet) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TwoLineElementSet.ProtoReflect.Descriptor instead.
func (*TwoLineElementSet) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{13}
}

func (x *TwoLineElementSet) GetLine1() string {
	if x != nil && x.Line1 != nil {
		return *x.Line1
	}
	return ""
}

func (x *TwoLineElementSet) GetLine2() string {
	if x != nil && x.Line2 != nil {
		return *x.Line2
	}
	return ""
}

// Keplerian elements.
// See https://en.wikipedia.org/wiki/Orbital_elements#Keplerian_elements or The
// Consultative Committee for Space Data  CCSDS 500.0-G-4
// section 5.2.2.4, for reference.
// When a platform's motion is described using this message, the platform's axes
// are oriented in the Earth's inertial frame, such that:
//   - The x-axis is aligned with the platform's velocity vector.
//   - The y-axis is aligned with the negative angular momentum vector.
//   - The z-axis is aligned with the negative position vector, which points
//     towards the Earth's center of mass.
//
// For reference, see The Consultative Committee for Space Data Systems
// CCSDS 500.0-G-4 Section 4.3.7.2.
// The orbit is propagated using a first order J2 perturbation algorithm which
// models only the secular effects on the orbital elements. The Earth
// Gravitational Model of 1996 (EGM96) according to NASA Technical Publication
// 1998-206861 is used.
type KeplerianElements struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Semimajor axis (distance), in meters.
	// Defaults to 0.
	SemimajorAxisM *float64 `protobuf:"fixed64,1,opt,name=semimajor_axis_m,json=semimajorAxisM" json:"semimajor_axis_m,omitempty"`
	// Eccentricity (the shape of the orbital ellipse).
	// This value must be between 0.0 (a circular orbit) and 1.0.
	// Defaults to 0.
	Eccentricity *float64 `protobuf:"fixed64,2,opt,name=eccentricity" json:"eccentricity,omitempty"`
	// Inclination, in degrees.
	// Defaults to 0.
	InclinationDeg *float64 `protobuf:"fixed64,3,opt,name=inclination_deg,json=inclinationDeg" json:"inclination_deg,omitempty"`
	// Argument of periapsis, in degrees.
	// Defaults to 0.
	ArgumentOfPeriapsisDeg *float64 `protobuf:"fixed64,4,opt,name=argument_of_periapsis_deg,json=argumentOfPeriapsisDeg" json:"argument_of_periapsis_deg,omitempty"`
	// Right ascension of ascending node, in degrees.
	// Defaults to 0.
	RaanDeg *float64 `protobuf:"fixed64,5,opt,name=raan_deg,json=raanDeg" json:"raan_deg,omitempty"`
	// True anomaly, in degrees.
	// Defaults to 0.
	TrueAnomalyDeg *float64 `protobuf:"fixed64,6,opt,name=true_anomaly_deg,json=trueAnomalyDeg" json:"true_anomaly_deg,omitempty"`
	// A set of orbital elements is a snapshot, at a particular time, of the orbit
	// of a satellite. This specifies the time at which the snapshot was taken.
	// Required.
	Epoch *DateTime `protobuf:"bytes,7,opt,name=epoch" json:"epoch,omitempty"`
	// The celestial body used to fetch gravitational parameters.
	// Required.
	CentralBody   *CentralBody `protobuf:"varint,8,opt,name=central_body,json=centralBody,enum=aalyria.spacetime.api.common.CentralBody,def=1" json:"central_body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

// Default values for KeplerianElements fields.
const (
	Default_KeplerianElements_CentralBody = CentralBody_EARTH
)

func (x *KeplerianElements) Reset() {
	*x = KeplerianElements{}
	mi := &file_api_common_coordinates_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeplerianElements) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeplerianElements) ProtoMessage() {}

func (x *KeplerianElements) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeplerianElements.ProtoReflect.Descriptor instead.
func (*KeplerianElements) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{14}
}

func (x *KeplerianElements) GetSemimajorAxisM() float64 {
	if x != nil && x.SemimajorAxisM != nil {
		return *x.SemimajorAxisM
	}
	return 0
}

func (x *KeplerianElements) GetEccentricity() float64 {
	if x != nil && x.Eccentricity != nil {
		return *x.Eccentricity
	}
	return 0
}

func (x *KeplerianElements) GetInclinationDeg() float64 {
	if x != nil && x.InclinationDeg != nil {
		return *x.InclinationDeg
	}
	return 0
}

func (x *KeplerianElements) GetArgumentOfPeriapsisDeg() float64 {
	if x != nil && x.ArgumentOfPeriapsisDeg != nil {
		return *x.ArgumentOfPeriapsisDeg
	}
	return 0
}

func (x *KeplerianElements) GetRaanDeg() float64 {
	if x != nil && x.RaanDeg != nil {
		return *x.RaanDeg
	}
	return 0
}

func (x *KeplerianElements) GetTrueAnomalyDeg() float64 {
	if x != nil && x.TrueAnomalyDeg != nil {
		return *x.TrueAnomalyDeg
	}
	return 0
}

func (x *KeplerianElements) GetEpoch() *DateTime {
	if x != nil {
		return x.Epoch
	}
	return nil
}

func (x *KeplerianElements) GetCentralBody() CentralBody {
	if x != nil && x.CentralBody != nil {
		return *x.CentralBody
	}
	return Default_KeplerianElements_CentralBody
}

// A set of 3D velocity components.
type CartesianDot struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Velocity along x-axis in meters per second.
	// Defaults to 0.
	XMps *float64 `protobuf:"fixed64,1,opt,name=x_mps,json=xMps" json:"x_mps,omitempty"`
	// Velocity along y-axis in meters per second.
	// Defaults to 0.
	YMps *float64 `protobuf:"fixed64,2,opt,name=y_mps,json=yMps" json:"y_mps,omitempty"`
	// Velocity along z-axis in meters per second.
	// Defaults to 0.
	ZMps          *float64 `protobuf:"fixed64,3,opt,name=z_mps,json=zMps" json:"z_mps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CartesianDot) Reset() {
	*x = CartesianDot{}
	mi := &file_api_common_coordinates_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CartesianDot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CartesianDot) ProtoMessage() {}

func (x *CartesianDot) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CartesianDot.ProtoReflect.Descriptor instead.
func (*CartesianDot) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{15}
}

func (x *CartesianDot) GetXMps() float64 {
	if x != nil && x.XMps != nil {
		return *x.XMps
	}
	return 0
}

func (x *CartesianDot) GetYMps() float64 {
	if x != nil && x.YMps != nil {
		return *x.YMps
	}
	return 0
}

func (x *CartesianDot) GetZMps() float64 {
	if x != nil && x.ZMps != nil {
		return *x.ZMps
	}
	return 0
}

// Generic state vector for any satellite positions. State vectors are used in
// the CCSDS Orbit Parameter Message standard (502.0-B-2), and are typical for
// lunar and other interplanetary mission data, as well as any other generic
// trajectories where TLEs or Keplerian elements are not well suited, e.g. for
// powered flight, maneuvers, etc.
//
// When a platform's motion is described using this message, the platform's axes
// are oriented in the Moon's inertial frame, such that:
//   - The x-axis is aligned with the platform's velocity vector.
//   - The y-axis is aligned with the negative angular momentum vector.
//   - The z-axis is aligned with the negative position vector, which points
//     towards the Moon's center of mass.
//
// For reference, see The Consultative Committee for Space Data Systems
// CCSDS 500.0-G-4 Section 4.3.7.2.
//
// WARNING: This message is under development and not fully supported.
type StateVector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time that the state vector was measured.
	Epoch *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=epoch" json:"epoch,omitempty"`
	// Indication of the reference frame for the state vector.
	CoordinateFrame *StateVector_CoordinateFrame `protobuf:"varint,2,opt,name=coordinate_frame,json=coordinateFrame,enum=aalyria.spacetime.api.common.StateVector_CoordinateFrame" json:"coordinate_frame,omitempty"`
	// Three dimensional position and velocity relative to the reference frame.
	Position *Cartesian    `protobuf:"bytes,3,opt,name=position" json:"position,omitempty"`
	Velocity *CartesianDot `protobuf:"bytes,4,opt,name=velocity" json:"velocity,omitempty"`
	// Indicate the type of propagation algorithm to be used.
	PropagationAlgorithm *StateVector_PropagationAlgorithm `protobuf:"varint,5,opt,name=propagation_algorithm,json=propagationAlgorithm,enum=aalyria.spacetime.api.common.StateVector_PropagationAlgorithm" json:"propagation_algorithm,omitempty"`
	// The approximate mass of the body, in kilograms.
	MassKg *float64 `protobuf:"fixed64,6,opt,name=mass_kg,json=massKg,def=2000" json:"mass_kg,omitempty"`
	// The approximate coefficient of reflectivity and applicable area in
	// square meters as pertains to solar radiation pressure.
	//
	// For the coefficient of reflectivity, only values from 0.0 (perfect
	// absorption) to 1.0 (perfect reflectivity) are meaningful.
	Reflectivity      *float64 `protobuf:"fixed64,7,opt,name=reflectivity,def=1" json:"reflectivity,omitempty"`
	ReflectiveAreaSqm *float64 `protobuf:"fixed64,8,opt,name=reflective_area_sqm,json=reflectiveAreaSqm,def=20" json:"reflective_area_sqm,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

// Default values for StateVector fields.
const (
	Default_StateVector_MassKg            = float64(2000)
	Default_StateVector_Reflectivity      = float64(1)
	Default_StateVector_ReflectiveAreaSqm = float64(20)
)

func (x *StateVector) Reset() {
	*x = StateVector{}
	mi := &file_api_common_coordinates_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StateVector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StateVector) ProtoMessage() {}

func (x *StateVector) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StateVector.ProtoReflect.Descriptor instead.
func (*StateVector) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{16}
}

func (x *StateVector) GetEpoch() *timestamppb.Timestamp {
	if x != nil {
		return x.Epoch
	}
	return nil
}

func (x *StateVector) GetCoordinateFrame() StateVector_CoordinateFrame {
	if x != nil && x.CoordinateFrame != nil {
		return *x.CoordinateFrame
	}
	return StateVector_UNKNOWN_FRAME
}

func (x *StateVector) GetPosition() *Cartesian {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *StateVector) GetVelocity() *CartesianDot {
	if x != nil {
		return x.Velocity
	}
	return nil
}

func (x *StateVector) GetPropagationAlgorithm() StateVector_PropagationAlgorithm {
	if x != nil && x.PropagationAlgorithm != nil {
		return *x.PropagationAlgorithm
	}
	return StateVector_UNSPECIFIED_ALGORITHM
}

func (x *StateVector) GetMassKg() float64 {
	if x != nil && x.MassKg != nil {
		return *x.MassKg
	}
	return Default_StateVector_MassKg
}

func (x *StateVector) GetReflectivity() float64 {
	if x != nil && x.Reflectivity != nil {
		return *x.Reflectivity
	}
	return Default_StateVector_Reflectivity
}

func (x *StateVector) GetReflectiveAreaSqm() float64 {
	if x != nil && x.ReflectiveAreaSqm != nil {
		return *x.ReflectiveAreaSqm
	}
	return Default_StateVector_ReflectiveAreaSqm
}

// A set of curvilinear 3D coordinates relative to the Mean Lunar Radius
// according to the Report of the IAU/IAG Working Group on Cartographic
// Coordinates and Rotational Elements of the Planets and satellites: 2000.
//
// When a platform's motion is described using this message, the platform's axes
// are defined in the Moon's reference frame, such that:
//   - The x-axis points in the local East direction.
//   - The y-axis points in the local North direction.
//   - The z-axis points in the direction of the normal vector to the reference
//     Moon ellipsoid surface which passes through the point. Conceptually, the
//     z-axis is oriented "outwards" from the Moon's surface towards space.
type SelenographicMlr struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to 0.
	LongitudeDeg *float64 `protobuf:"fixed64,1,opt,name=longitude_deg,json=longitudeDeg" json:"longitude_deg,omitempty"`
	// Defaults to 0.
	LatitudeDeg *float64 `protobuf:"fixed64,2,opt,name=latitude_deg,json=latitudeDeg" json:"latitude_deg,omitempty"`
	// Defaults to 0.
	HeightMlrM    *float64 `protobuf:"fixed64,3,opt,name=height_mlr_m,json=heightMlrM" json:"height_mlr_m,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SelenographicMlr) Reset() {
	*x = SelenographicMlr{}
	mi := &file_api_common_coordinates_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SelenographicMlr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SelenographicMlr) ProtoMessage() {}

func (x *SelenographicMlr) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SelenographicMlr.ProtoReflect.Descriptor instead.
func (*SelenographicMlr) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{17}
}

func (x *SelenographicMlr) GetLongitudeDeg() float64 {
	if x != nil && x.LongitudeDeg != nil {
		return *x.LongitudeDeg
	}
	return 0
}

func (x *SelenographicMlr) GetLatitudeDeg() float64 {
	if x != nil && x.LatitudeDeg != nil {
		return *x.LatitudeDeg
	}
	return 0
}

func (x *SelenographicMlr) GetHeightMlrM() float64 {
	if x != nil && x.HeightMlrM != nil {
		return *x.HeightMlrM
	}
	return 0
}

// STK Ephemeris and Attitude files generated by the STK Desktop tool.
// The maximum size of this message is constrained by the maximum size
// of protocol buffers, which is 2GB.
type StkEphemAndAttitudeFile struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required.
	EphemFile *string `protobuf:"bytes,1,opt,name=ephem_file,json=ephemFile" json:"ephem_file,omitempty"`
	// Required.
	AttitudeFile  *string `protobuf:"bytes,2,opt,name=attitude_file,json=attitudeFile" json:"attitude_file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StkEphemAndAttitudeFile) Reset() {
	*x = StkEphemAndAttitudeFile{}
	mi := &file_api_common_coordinates_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StkEphemAndAttitudeFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StkEphemAndAttitudeFile) ProtoMessage() {}

func (x *StkEphemAndAttitudeFile) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StkEphemAndAttitudeFile.ProtoReflect.Descriptor instead.
func (*StkEphemAndAttitudeFile) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{18}
}

func (x *StkEphemAndAttitudeFile) GetEphemFile() string {
	if x != nil && x.EphemFile != nil {
		return *x.EphemFile
	}
	return ""
}

func (x *StkEphemAndAttitudeFile) GetAttitudeFile() string {
	if x != nil && x.AttitudeFile != nil {
		return *x.AttitudeFile
	}
	return ""
}

// A type to express spatial regions over the Earth's surface.
// The S2 library defines an index over the 3D surface of the Earth. Arbitrary
// regions can be described as a collection of S2 cells, each of which can
// represent a region of a different size. See http://s2geometry.io for
// reference.
type S2Cells struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Required.
	Ids           []uint64 `protobuf:"varint,1,rep,name=ids" json:"ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *S2Cells) Reset() {
	*x = S2Cells{}
	mi := &file_api_common_coordinates_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *S2Cells) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*S2Cells) ProtoMessage() {}

func (x *S2Cells) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use S2Cells.ProtoReflect.Descriptor instead.
func (*S2Cells) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{19}
}

func (x *S2Cells) GetIds() []uint64 {
	if x != nil {
		return x.Ids
	}
	return nil
}

// An azimuth/elevation direction vector.
type PointingVector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to 0.
	AzimuthDeg *float64 `protobuf:"fixed64,1,opt,name=azimuth_deg,json=azimuthDeg" json:"azimuth_deg,omitempty"`
	// Defaults to 0.
	ElevationDeg  *float64 `protobuf:"fixed64,2,opt,name=elevation_deg,json=elevationDeg" json:"elevation_deg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PointingVector) Reset() {
	*x = PointingVector{}
	mi := &file_api_common_coordinates_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PointingVector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PointingVector) ProtoMessage() {}

func (x *PointingVector) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PointingVector.ProtoReflect.Descriptor instead.
func (*PointingVector) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{20}
}

func (x *PointingVector) GetAzimuthDeg() float64 {
	if x != nil && x.AzimuthDeg != nil {
		return *x.AzimuthDeg
	}
	return 0
}

func (x *PointingVector) GetElevationDeg() float64 {
	if x != nil && x.ElevationDeg != nil {
		return *x.ElevationDeg
	}
	return 0
}

// A phi/theta direction vector.
type PhiTheta struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Defaults to 0.
	PhiRad *float64 `protobuf:"fixed64,1,opt,name=phi_rad,json=phiRad" json:"phi_rad,omitempty"`
	// Defaults to 0.
	ThetaRad      *float64 `protobuf:"fixed64,2,opt,name=theta_rad,json=thetaRad" json:"theta_rad,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PhiTheta) Reset() {
	*x = PhiTheta{}
	mi := &file_api_common_coordinates_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PhiTheta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhiTheta) ProtoMessage() {}

func (x *PhiTheta) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhiTheta.ProtoReflect.Descriptor instead.
func (*PhiTheta) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{21}
}

func (x *PhiTheta) GetPhiRad() float64 {
	if x != nil && x.PhiRad != nil {
		return *x.PhiRad
	}
	return 0
}

func (x *PhiTheta) GetThetaRad() float64 {
	if x != nil && x.ThetaRad != nil {
		return *x.ThetaRad
	}
	return 0
}

type Motion struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The time interval for which this motion specification is applicable.
	//
	// This may be left- or right-unbounded, or unspecified altogether. When
	// the start or end times (or both) are unspecified, and the motion
	// specification does not contain a clear indication of valid timestamps,
	// it is an error if an applicable boundary is required but cannot be
	// inferred from context (e.g., if there is more than one Motion message
	// in a sequence but the start/end time of one cannot be inferred from the
	// end/start time of another).
	Interval *interval.Interval `protobuf:"bytes,10,opt,name=interval" json:"interval,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*Motion_GeodeticMsl
	//	*Motion_GeodeticWgs84
	//	*Motion_EcefFixed
	//	*Motion_EcefInterpolation
	//	*Motion_CartographicWaypoints
	//	*Motion_GeodeticWaypoints
	//	*Motion_Tle
	//	*Motion_KeplerianElements
	//	*Motion_StateVector
	//	*Motion_SelenographicMlr
	//	*Motion_StkEphemAndAttitudeFile
	//	*Motion_CcsdsOrbitEphemerisMessage
	Type          isMotion_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Motion) Reset() {
	*x = Motion{}
	mi := &file_api_common_coordinates_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Motion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Motion) ProtoMessage() {}

func (x *Motion) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Motion.ProtoReflect.Descriptor instead.
func (*Motion) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{22}
}

func (x *Motion) GetInterval() *interval.Interval {
	if x != nil {
		return x.Interval
	}
	return nil
}

func (x *Motion) GetType() isMotion_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *Motion) GetGeodeticMsl() *GeodeticMsl {
	if x != nil {
		if x, ok := x.Type.(*Motion_GeodeticMsl); ok {
			return x.GeodeticMsl
		}
	}
	return nil
}

func (x *Motion) GetGeodeticWgs84() *GeodeticWgs84 {
	if x != nil {
		if x, ok := x.Type.(*Motion_GeodeticWgs84); ok {
			return x.GeodeticWgs84
		}
	}
	return nil
}

func (x *Motion) GetEcefFixed() *PointAxes {
	if x != nil {
		if x, ok := x.Type.(*Motion_EcefFixed); ok {
			return x.EcefFixed
		}
	}
	return nil
}

func (x *Motion) GetEcefInterpolation() *PointAxesTemporalInterpolation {
	if x != nil {
		if x, ok := x.Type.(*Motion_EcefInterpolation); ok {
			return x.EcefInterpolation
		}
	}
	return nil
}

func (x *Motion) GetCartographicWaypoints() *GeodeticWgs84TemporalInterpolation {
	if x != nil {
		if x, ok := x.Type.(*Motion_CartographicWaypoints); ok {
			return x.CartographicWaypoints
		}
	}
	return nil
}

func (x *Motion) GetGeodeticWaypoints() *GeodeticTemporalInterpolation {
	if x != nil {
		if x, ok := x.Type.(*Motion_GeodeticWaypoints); ok {
			return x.GeodeticWaypoints
		}
	}
	return nil
}

func (x *Motion) GetTle() *TwoLineElementSet {
	if x != nil {
		if x, ok := x.Type.(*Motion_Tle); ok {
			return x.Tle
		}
	}
	return nil
}

func (x *Motion) GetKeplerianElements() *KeplerianElements {
	if x != nil {
		if x, ok := x.Type.(*Motion_KeplerianElements); ok {
			return x.KeplerianElements
		}
	}
	return nil
}

func (x *Motion) GetStateVector() *StateVector {
	if x != nil {
		if x, ok := x.Type.(*Motion_StateVector); ok {
			return x.StateVector
		}
	}
	return nil
}

func (x *Motion) GetSelenographicMlr() *SelenographicMlr {
	if x != nil {
		if x, ok := x.Type.(*Motion_SelenographicMlr); ok {
			return x.SelenographicMlr
		}
	}
	return nil
}

func (x *Motion) GetStkEphemAndAttitudeFile() *StkEphemAndAttitudeFile {
	if x != nil {
		if x, ok := x.Type.(*Motion_StkEphemAndAttitudeFile); ok {
			return x.StkEphemAndAttitudeFile
		}
	}
	return nil
}

func (x *Motion) GetCcsdsOrbitEphemerisMessage() *CcsdsOrbitEphemerisMessage {
	if x != nil {
		if x, ok := x.Type.(*Motion_CcsdsOrbitEphemerisMessage); ok {
			return x.CcsdsOrbitEphemerisMessage
		}
	}
	return nil
}

type isMotion_Type interface {
	isMotion_Type()
}

type Motion_GeodeticMsl struct {
	GeodeticMsl *GeodeticMsl `protobuf:"bytes,7,opt,name=geodetic_msl,json=geodeticMsl,oneof"`
}

type Motion_GeodeticWgs84 struct {
	GeodeticWgs84 *GeodeticWgs84 `protobuf:"bytes,1,opt,name=geodetic_wgs84,json=geodeticWgs84,oneof"`
}

type Motion_EcefFixed struct {
	EcefFixed *PointAxes `protobuf:"bytes,2,opt,name=ecef_fixed,json=ecefFixed,oneof"`
}

type Motion_EcefInterpolation struct {
	EcefInterpolation *PointAxesTemporalInterpolation `protobuf:"bytes,3,opt,name=ecef_interpolation,json=ecefInterpolation,oneof"`
}

type Motion_CartographicWaypoints struct {
	CartographicWaypoints *GeodeticWgs84TemporalInterpolation `protobuf:"bytes,4,opt,name=cartographic_waypoints,json=cartographicWaypoints,oneof"`
}

type Motion_GeodeticWaypoints struct {
	GeodeticWaypoints *GeodeticTemporalInterpolation `protobuf:"bytes,12,opt,name=geodetic_waypoints,json=geodeticWaypoints,oneof"`
}

type Motion_Tle struct {
	Tle *TwoLineElementSet `protobuf:"bytes,5,opt,name=tle,oneof"`
}

type Motion_KeplerianElements struct {
	KeplerianElements *KeplerianElements `protobuf:"bytes,6,opt,name=keplerian_elements,json=keplerianElements,oneof"`
}

type Motion_StateVector struct {
	// WARNING: This message is under development and not fully supported.
	StateVector *StateVector `protobuf:"bytes,9,opt,name=state_vector,json=stateVector,oneof"`
}

type Motion_SelenographicMlr struct {
	SelenographicMlr *SelenographicMlr `protobuf:"bytes,8,opt,name=selenographic_mlr,json=selenographicMlr,oneof"`
}

type Motion_StkEphemAndAttitudeFile struct {
	StkEphemAndAttitudeFile *StkEphemAndAttitudeFile `protobuf:"bytes,11,opt,name=stk_ephem_and_attitude_file,json=stkEphemAndAttitudeFile,oneof"`
}

type Motion_CcsdsOrbitEphemerisMessage struct {
	CcsdsOrbitEphemerisMessage *CcsdsOrbitEphemerisMessage `protobuf:"bytes,13,opt,name=ccsds_orbit_ephemeris_message,json=ccsdsOrbitEphemerisMessage,oneof"`
}

func (*Motion_GeodeticMsl) isMotion_Type() {}

func (*Motion_GeodeticWgs84) isMotion_Type() {}

func (*Motion_EcefFixed) isMotion_Type() {}

func (*Motion_EcefInterpolation) isMotion_Type() {}

func (*Motion_CartographicWaypoints) isMotion_Type() {}

func (*Motion_GeodeticWaypoints) isMotion_Type() {}

func (*Motion_Tle) isMotion_Type() {}

func (*Motion_KeplerianElements) isMotion_Type() {}

func (*Motion_StateVector) isMotion_Type() {}

func (*Motion_SelenographicMlr) isMotion_Type() {}

func (*Motion_StkEphemAndAttitudeFile) isMotion_Type() {}

func (*Motion_CcsdsOrbitEphemerisMessage) isMotion_Type() {}

// A CCSDS Orbit Ephemeris Message (OEM), per the
// specification CCSDS 502.0-B-3 published April 2023.
//
// Notes:
//   - Though the OEM Metadata INTERPOLATION and INTERPOLATION_DEGREE
//     fields are Optional in the specification, they are required by Spacetime
//   - File format can be either Key-value notation (KVN) or extensible markup
//     language (XML)
//   - Presently supports single-segment CCSDS OEM Files (multi-segment will
//     throw error)
type CcsdsOrbitEphemerisMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CCSDS OEM file contents as a string.
	File          *string `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CcsdsOrbitEphemerisMessage) Reset() {
	*x = CcsdsOrbitEphemerisMessage{}
	mi := &file_api_common_coordinates_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CcsdsOrbitEphemerisMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CcsdsOrbitEphemerisMessage) ProtoMessage() {}

func (x *CcsdsOrbitEphemerisMessage) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_coordinates_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CcsdsOrbitEphemerisMessage.ProtoReflect.Descriptor instead.
func (*CcsdsOrbitEphemerisMessage) Descriptor() ([]byte, []int) {
	return file_api_common_coordinates_proto_rawDescGZIP(), []int{23}
}

func (x *CcsdsOrbitEphemerisMessage) GetFile() string {
	if x != nil && x.File != nil {
		return *x.File
	}
	return ""
}

var File_api_common_coordinates_proto protoreflect.FileDescriptor

const file_api_common_coordinates_proto_rawDesc = "" +
	"\n" +
	"\x1capi/common/coordinates.proto\x12\x1caalyria.spacetime.api.common\x1a\x15api/common/time.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1agoogle/type/interval.proto\"}\n" +
	"\rGeodeticWgs84\x12#\n" +
	"\rlongitude_deg\x18\x01 \x01(\x01R\flongitudeDeg\x12!\n" +
	"\flatitude_deg\x18\x02 \x01(\x01R\vlatitudeDeg\x12$\n" +
	"\x0eheight_wgs84_m\x18\x03 \x01(\x01R\fheightWgs84M\"w\n" +
	"\vGeodeticMsl\x12#\n" +
	"\rlongitude_deg\x18\x01 \x01(\x01R\flongitudeDeg\x12!\n" +
	"\flatitude_deg\x18\x02 \x01(\x01R\vlatitudeDeg\x12 \n" +
	"\fheight_msl_m\x18\x03 \x01(\x01R\n" +
	"heightMslM\"\xa4\x02\n" +
	"\bGeodetic\x12#\n" +
	"\rlongitude_deg\x18\x02 \x01(\x01R\flongitudeDeg\x12!\n" +
	"\flatitude_deg\x18\x01 \x01(\x01R\vlatitudeDeg\x12\x19\n" +
	"\bheight_m\x18\x03 \x01(\x01R\aheightM\x12[\n" +
	"\x0evertical_datum\x18\x04 \x01(\x0e24.aalyria.spacetime.api.common.Geodetic.VerticalDatumR\rverticalDatum\"X\n" +
	"\rVerticalDatum\x12\x1e\n" +
	"\x1aVERTICAL_DATUM_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fWGS84_ELLIPSOID\x10\x01\x12\x12\n" +
	"\x0eMEAN_SEA_LEVEL\x10\x02\"\x8a\x01\n" +
	"\x15GeodeticWgs84Temporal\x12A\n" +
	"\x05point\x18\x01 \x01(\v2+.aalyria.spacetime.api.common.GeodeticWgs84R\x05point\x12.\n" +
	"\x04time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x04time\"\x80\x01\n" +
	"\x10GeodeticTemporal\x12<\n" +
	"\x05point\x18\x01 \x01(\v2&.aalyria.spacetime.api.common.GeodeticR\x05point\x12.\n" +
	"\x04time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x04time\">\n" +
	"\tCartesian\x12\x0f\n" +
	"\x03x_m\x18\x01 \x01(\x01R\x02xM\x12\x0f\n" +
	"\x03y_m\x18\x02 \x01(\x01R\x02yM\x12\x0f\n" +
	"\x03z_m\x18\x03 \x01(\x01R\x02zM\"D\n" +
	"\n" +
	"Quaternion\x12\f\n" +
	"\x01w\x18\x01 \x01(\x01R\x01w\x12\f\n" +
	"\x01x\x18\x02 \x01(\x01R\x01x\x12\f\n" +
	"\x01y\x18\x03 \x01(\x01R\x01y\x12\f\n" +
	"\x01z\x18\x04 \x01(\x01R\x01z\"_\n" +
	"\fYawPitchRoll\x12\x17\n" +
	"\ayaw_deg\x18\x01 \x01(\x01R\x06yawDeg\x12\x1b\n" +
	"\tpitch_deg\x18\x02 \x01(\x01R\bpitchDeg\x12\x19\n" +
	"\broll_deg\x18\x03 \x01(\x01R\arollDeg\"\x88\x01\n" +
	"\tPointAxes\x12=\n" +
	"\x05point\x18\x01 \x01(\v2'.aalyria.spacetime.api.common.CartesianR\x05point\x12<\n" +
	"\x04axes\x18\x02 \x01(\v2(.aalyria.spacetime.api.common.QuaternionR\x04axes\"\x82\x02\n" +
	"\x11PointAxesTemporal\x12=\n" +
	"\x05point\x18\x01 \x01(\v2'.aalyria.spacetime.api.common.CartesianR\x05point\x12<\n" +
	"\x04axes\x18\x02 \x01(\v2(.aalyria.spacetime.api.common.QuaternionR\x04axes\x12@\n" +
	"\bgps_time\x18\x04 \x01(\v2%.aalyria.spacetime.api.common.GpsTimeR\agpsTime\x12.\n" +
	"\x04time\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x04time\"\xbe\x02\n" +
	"\x1ePointAxesTemporalInterpolation\x12x\n" +
	" locations_orientations_over_time\x18\x01 \x03(\v2/.aalyria.spacetime.api.common.PointAxesTemporalR\x1dlocationsOrientationsOverTime\x12l\n" +
	"\x14interpolation_method\x18\x02 \x01(\x0e21.aalyria.spacetime.api.common.InterpolationMethod:\x06LINEARR\x13interpolationMethod\x124\n" +
	"\x14interpolation_degree\x18\x03 \x01(\x05:\x011R\x13interpolationDegree\"\xad\x02\n" +
	"\"GeodeticWgs84TemporalInterpolation\x12c\n" +
	"\x13locations_over_time\x18\x01 \x03(\v23.aalyria.spacetime.api.common.GeodeticWgs84TemporalR\x11locationsOverTime\x12l\n" +
	"\x14interpolation_method\x18\x02 \x01(\x0e21.aalyria.spacetime.api.common.InterpolationMethod:\x06LINEARR\x13interpolationMethod\x124\n" +
	"\x14interpolation_degree\x18\x03 \x01(\x05:\x011R\x13interpolationDegree\"\xa3\x02\n" +
	"\x1dGeodeticTemporalInterpolation\x12^\n" +
	"\x13locations_over_time\x18\x01 \x03(\v2..aalyria.spacetime.api.common.GeodeticTemporalR\x11locationsOverTime\x12l\n" +
	"\x14interpolation_method\x18\x02 \x01(\x0e21.aalyria.spacetime.api.common.InterpolationMethod:\x06LINEARR\x13interpolationMethod\x124\n" +
	"\x14interpolation_degree\x18\x03 \x01(\x05:\x011R\x13interpolationDegree\"?\n" +
	"\x11TwoLineElementSet\x12\x14\n" +
	"\x05line1\x18\x01 \x01(\tR\x05line1\x12\x14\n" +
	"\x05line2\x18\x02 \x01(\tR\x05line2\"\x9d\x03\n" +
	"\x11KeplerianElements\x12(\n" +
	"\x10semimajor_axis_m\x18\x01 \x01(\x01R\x0esemimajorAxisM\x12\"\n" +
	"\feccentricity\x18\x02 \x01(\x01R\feccentricity\x12'\n" +
	"\x0finclination_deg\x18\x03 \x01(\x01R\x0einclinationDeg\x129\n" +
	"\x19argument_of_periapsis_deg\x18\x04 \x01(\x01R\x16argumentOfPeriapsisDeg\x12\x19\n" +
	"\braan_deg\x18\x05 \x01(\x01R\araanDeg\x12(\n" +
	"\x10true_anomaly_deg\x18\x06 \x01(\x01R\x0etrueAnomalyDeg\x12<\n" +
	"\x05epoch\x18\a \x01(\v2&.aalyria.spacetime.api.common.DateTimeR\x05epoch\x12S\n" +
	"\fcentral_body\x18\b \x01(\x0e2).aalyria.spacetime.api.common.CentralBody:\x05EARTHR\vcentralBody\"M\n" +
	"\fCartesianDot\x12\x13\n" +
	"\x05x_mps\x18\x01 \x01(\x01R\x04xMps\x12\x13\n" +
	"\x05y_mps\x18\x02 \x01(\x01R\x04yMps\x12\x13\n" +
	"\x05z_mps\x18\x03 \x01(\x01R\x04zMps\"\xe2\x05\n" +
	"\vStateVector\x120\n" +
	"\x05epoch\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x05epoch\x12d\n" +
	"\x10coordinate_frame\x18\x02 \x01(\x0e29.aalyria.spacetime.api.common.StateVector.CoordinateFrameR\x0fcoordinateFrame\x12C\n" +
	"\bposition\x18\x03 \x01(\v2'.aalyria.spacetime.api.common.CartesianR\bposition\x12F\n" +
	"\bvelocity\x18\x04 \x01(\v2*.aalyria.spacetime.api.common.CartesianDotR\bvelocity\x12s\n" +
	"\x15propagation_algorithm\x18\x05 \x01(\x0e2>.aalyria.spacetime.api.common.StateVector.PropagationAlgorithmR\x14propagationAlgorithm\x12\x1d\n" +
	"\amass_kg\x18\x06 \x01(\x01:\x042000R\x06massKg\x12%\n" +
	"\freflectivity\x18\a \x01(\x01:\x011R\freflectivity\x122\n" +
	"\x13reflective_area_sqm\x18\b \x01(\x01:\x0220R\x11reflectiveAreaSqm\"]\n" +
	"\x0fCoordinateFrame\x12\x11\n" +
	"\rUNKNOWN_FRAME\x10\x00\x12'\n" +
	"#EARTH_MOON_BARYCENTER_SYNODIC_FRAME\x10\x01\x12\x0e\n" +
	"\n" +
	"ECEF_FRAME\x10\x02\"`\n" +
	"\x14PropagationAlgorithm\x12\x19\n" +
	"\x15UNSPECIFIED_ALGORITHM\x10\x00\x12-\n" +
	")EARTH_MOON_THREE_BODY_NUMERICAL_ALGORITHM\x10\x01\"|\n" +
	"\x10SelenographicMlr\x12#\n" +
	"\rlongitude_deg\x18\x01 \x01(\x01R\flongitudeDeg\x12!\n" +
	"\flatitude_deg\x18\x02 \x01(\x01R\vlatitudeDeg\x12 \n" +
	"\fheight_mlr_m\x18\x03 \x01(\x01R\n" +
	"heightMlrM\"]\n" +
	"\x17StkEphemAndAttitudeFile\x12\x1d\n" +
	"\n" +
	"ephem_file\x18\x01 \x01(\tR\tephemFile\x12#\n" +
	"\rattitude_file\x18\x02 \x01(\tR\fattitudeFile\"\x1b\n" +
	"\aS2Cells\x12\x10\n" +
	"\x03ids\x18\x01 \x03(\x04R\x03ids\"V\n" +
	"\x0ePointingVector\x12\x1f\n" +
	"\vazimuth_deg\x18\x01 \x01(\x01R\n" +
	"azimuthDeg\x12#\n" +
	"\relevation_deg\x18\x02 \x01(\x01R\felevationDeg\"@\n" +
	"\bPhiTheta\x12\x17\n" +
	"\aphi_rad\x18\x01 \x01(\x01R\x06phiRad\x12\x1b\n" +
	"\ttheta_rad\x18\x02 \x01(\x01R\bthetaRad\"\x88\f\n" +
	"\x06Motion\x121\n" +
	"\binterval\x18\n" +
	" \x01(\v2\x15.google.type.IntervalR\binterval\x12N\n" +
	"\fgeodetic_msl\x18\a \x01(\v2).aalyria.spacetime.api.common.GeodeticMslH\x00R\vgeodeticMsl\x12T\n" +
	"\x0egeodetic_wgs84\x18\x01 \x01(\v2+.aalyria.spacetime.api.common.GeodeticWgs84H\x00R\rgeodeticWgs84\x12H\n" +
	"\n" +
	"ecef_fixed\x18\x02 \x01(\v2'.aalyria.spacetime.api.common.PointAxesH\x00R\tecefFixed\x12m\n" +
	"\x12ecef_interpolation\x18\x03 \x01(\v2<.aalyria.spacetime.api.common.PointAxesTemporalInterpolationH\x00R\x11ecefInterpolation\x12y\n" +
	"\x16cartographic_waypoints\x18\x04 \x01(\v2@.aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolationH\x00R\x15cartographicWaypoints\x12l\n" +
	"\x12geodetic_waypoints\x18\f \x01(\v2;.aalyria.spacetime.api.common.GeodeticTemporalInterpolationH\x00R\x11geodeticWaypoints\x12C\n" +
	"\x03tle\x18\x05 \x01(\v2/.aalyria.spacetime.api.common.TwoLineElementSetH\x00R\x03tle\x12`\n" +
	"\x12keplerian_elements\x18\x06 \x01(\v2/.aalyria.spacetime.api.common.KeplerianElementsH\x00R\x11keplerianElements\x12N\n" +
	"\fstate_vector\x18\t \x01(\v2).aalyria.spacetime.api.common.StateVectorH\x00R\vstateVector\x12]\n" +
	"\x11selenographic_mlr\x18\b \x01(\v2..aalyria.spacetime.api.common.SelenographicMlrH\x00R\x10selenographicMlr\x12u\n" +
	"\x1bstk_ephem_and_attitude_file\x18\v \x01(\v25.aalyria.spacetime.api.common.StkEphemAndAttitudeFileH\x00R\x17stkEphemAndAttitudeFile\x12}\n" +
	"\x1dccsds_orbit_ephemeris_message\x18\r \x01(\v28.aalyria.spacetime.api.common.CcsdsOrbitEphemerisMessageH\x00R\x1accsdsOrbitEphemerisMessage\"\xae\x02\n" +
	"\x04Type\x12\x16\n" +
	"\x12MOTION_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fGEODETIC_MSL\x10\a\x12\x12\n" +
	"\x0eGEODETIC_WGS84\x10\x01\x12\x0e\n" +
	"\n" +
	"ECEF_FIXED\x10\x02\x12\x16\n" +
	"\x12ECEF_INTERPOLATION\x10\x03\x12\x1a\n" +
	"\x16CARTOGRAPHIC_WAYPOINTS\x10\x04\x12\x16\n" +
	"\x12GEODETIC_WAYPOINTS\x10\f\x12\a\n" +
	"\x03TLE\x10\x05\x12\x16\n" +
	"\x12KEPLERIAN_ELEMENTS\x10\x06\x12\x10\n" +
	"\fSTATE_VECTOR\x10\t\x12\x15\n" +
	"\x11SELENOGRAPHIC_MLR\x10\b\x12\x1f\n" +
	"\x1bSTK_EPHEM_AND_ATTITUDE_FILE\x10\v\x12!\n" +
	"\x1dCCSDS_ORBIT_EPHEMERIS_MESSAGE\x10\rB\x06\n" +
	"\x04type\"0\n" +
	"\x1aCcsdsOrbitEphemerisMessage\x12\x12\n" +
	"\x04file\x18\x01 \x01(\tR\x04file*R\n" +
	"\x13InterpolationMethod\x12\x12\n" +
	"\x0eUNKNOWN_METHOD\x10\x00\x12\n" +
	"\n" +
	"\x06LINEAR\x10\x01\x12\f\n" +
	"\bLAGRANGE\x10\x02\x12\r\n" +
	"\tHERMITIAN\x10\x03*<\n" +
	"\vCentralBody\x12\x18\n" +
	"\x14UNKNOWN_CENTRAL_BODY\x10\x00\x12\t\n" +
	"\x05EARTH\x10\x01\x12\b\n" +
	"\x04MOON\x10\x02BD\n" +
	" com.aalyria.spacetime.api.commonZ aalyria.com/spacetime/api/common"

var (
	file_api_common_coordinates_proto_rawDescOnce sync.Once
	file_api_common_coordinates_proto_rawDescData []byte
)

func file_api_common_coordinates_proto_rawDescGZIP() []byte {
	file_api_common_coordinates_proto_rawDescOnce.Do(func() {
		file_api_common_coordinates_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_common_coordinates_proto_rawDesc), len(file_api_common_coordinates_proto_rawDesc)))
	})
	return file_api_common_coordinates_proto_rawDescData
}

var file_api_common_coordinates_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_api_common_coordinates_proto_msgTypes = make([]protoimpl.MessageInfo, 24)
var file_api_common_coordinates_proto_goTypes = []any{
	(InterpolationMethod)(0),                   // 0: aalyria.spacetime.api.common.InterpolationMethod
	(CentralBody)(0),                           // 1: aalyria.spacetime.api.common.CentralBody
	(Geodetic_VerticalDatum)(0),                // 2: aalyria.spacetime.api.common.Geodetic.VerticalDatum
	(StateVector_CoordinateFrame)(0),           // 3: aalyria.spacetime.api.common.StateVector.CoordinateFrame
	(StateVector_PropagationAlgorithm)(0),      // 4: aalyria.spacetime.api.common.StateVector.PropagationAlgorithm
	(Motion_Type)(0),                           // 5: aalyria.spacetime.api.common.Motion.Type
	(*GeodeticWgs84)(nil),                      // 6: aalyria.spacetime.api.common.GeodeticWgs84
	(*GeodeticMsl)(nil),                        // 7: aalyria.spacetime.api.common.GeodeticMsl
	(*Geodetic)(nil),                           // 8: aalyria.spacetime.api.common.Geodetic
	(*GeodeticWgs84Temporal)(nil),              // 9: aalyria.spacetime.api.common.GeodeticWgs84Temporal
	(*GeodeticTemporal)(nil),                   // 10: aalyria.spacetime.api.common.GeodeticTemporal
	(*Cartesian)(nil),                          // 11: aalyria.spacetime.api.common.Cartesian
	(*Quaternion)(nil),                         // 12: aalyria.spacetime.api.common.Quaternion
	(*YawPitchRoll)(nil),                       // 13: aalyria.spacetime.api.common.YawPitchRoll
	(*PointAxes)(nil),                          // 14: aalyria.spacetime.api.common.PointAxes
	(*PointAxesTemporal)(nil),                  // 15: aalyria.spacetime.api.common.PointAxesTemporal
	(*PointAxesTemporalInterpolation)(nil),     // 16: aalyria.spacetime.api.common.PointAxesTemporalInterpolation
	(*GeodeticWgs84TemporalInterpolation)(nil), // 17: aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation
	(*GeodeticTemporalInterpolation)(nil),      // 18: aalyria.spacetime.api.common.GeodeticTemporalInterpolation
	(*TwoLineElementSet)(nil),                  // 19: aalyria.spacetime.api.common.TwoLineElementSet
	(*KeplerianElements)(nil),                  // 20: aalyria.spacetime.api.common.KeplerianElements
	(*CartesianDot)(nil),                       // 21: aalyria.spacetime.api.common.CartesianDot
	(*StateVector)(nil),                        // 22: aalyria.spacetime.api.common.StateVector
	(*SelenographicMlr)(nil),                   // 23: aalyria.spacetime.api.common.SelenographicMlr
	(*StkEphemAndAttitudeFile)(nil),            // 24: aalyria.spacetime.api.common.StkEphemAndAttitudeFile
	(*S2Cells)(nil),                            // 25: aalyria.spacetime.api.common.S2Cells
	(*PointingVector)(nil),                     // 26: aalyria.spacetime.api.common.PointingVector
	(*PhiTheta)(nil),                           // 27: aalyria.spacetime.api.common.PhiTheta
	(*Motion)(nil),                             // 28: aalyria.spacetime.api.common.Motion
	(*CcsdsOrbitEphemerisMessage)(nil),         // 29: aalyria.spacetime.api.common.CcsdsOrbitEphemerisMessage
	(*timestamppb.Timestamp)(nil),              // 30: google.protobuf.Timestamp
	(*GpsTime)(nil),                            // 31: aalyria.spacetime.api.common.GpsTime
	(*DateTime)(nil),                           // 32: aalyria.spacetime.api.common.DateTime
	(*interval.Interval)(nil),                  // 33: google.type.Interval
}
var file_api_common_coordinates_proto_depIdxs = []int32{
	2,  // 0: aalyria.spacetime.api.common.Geodetic.vertical_datum:type_name -> aalyria.spacetime.api.common.Geodetic.VerticalDatum
	6,  // 1: aalyria.spacetime.api.common.GeodeticWgs84Temporal.point:type_name -> aalyria.spacetime.api.common.GeodeticWgs84
	30, // 2: aalyria.spacetime.api.common.GeodeticWgs84Temporal.time:type_name -> google.protobuf.Timestamp
	8,  // 3: aalyria.spacetime.api.common.GeodeticTemporal.point:type_name -> aalyria.spacetime.api.common.Geodetic
	30, // 4: aalyria.spacetime.api.common.GeodeticTemporal.time:type_name -> google.protobuf.Timestamp
	11, // 5: aalyria.spacetime.api.common.PointAxes.point:type_name -> aalyria.spacetime.api.common.Cartesian
	12, // 6: aalyria.spacetime.api.common.PointAxes.axes:type_name -> aalyria.spacetime.api.common.Quaternion
	11, // 7: aalyria.spacetime.api.common.PointAxesTemporal.point:type_name -> aalyria.spacetime.api.common.Cartesian
	12, // 8: aalyria.spacetime.api.common.PointAxesTemporal.axes:type_name -> aalyria.spacetime.api.common.Quaternion
	31, // 9: aalyria.spacetime.api.common.PointAxesTemporal.gps_time:type_name -> aalyria.spacetime.api.common.GpsTime
	30, // 10: aalyria.spacetime.api.common.PointAxesTemporal.time:type_name -> google.protobuf.Timestamp
	15, // 11: aalyria.spacetime.api.common.PointAxesTemporalInterpolation.locations_orientations_over_time:type_name -> aalyria.spacetime.api.common.PointAxesTemporal
	0,  // 12: aalyria.spacetime.api.common.PointAxesTemporalInterpolation.interpolation_method:type_name -> aalyria.spacetime.api.common.InterpolationMethod
	9,  // 13: aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.locations_over_time:type_name -> aalyria.spacetime.api.common.GeodeticWgs84Temporal
	0,  // 14: aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation.interpolation_method:type_name -> aalyria.spacetime.api.common.InterpolationMethod
	10, // 15: aalyria.spacetime.api.common.GeodeticTemporalInterpolation.locations_over_time:type_name -> aalyria.spacetime.api.common.GeodeticTemporal
	0,  // 16: aalyria.spacetime.api.common.GeodeticTemporalInterpolation.interpolation_method:type_name -> aalyria.spacetime.api.common.InterpolationMethod
	32, // 17: aalyria.spacetime.api.common.KeplerianElements.epoch:type_name -> aalyria.spacetime.api.common.DateTime
	1,  // 18: aalyria.spacetime.api.common.KeplerianElements.central_body:type_name -> aalyria.spacetime.api.common.CentralBody
	30, // 19: aalyria.spacetime.api.common.StateVector.epoch:type_name -> google.protobuf.Timestamp
	3,  // 20: aalyria.spacetime.api.common.StateVector.coordinate_frame:type_name -> aalyria.spacetime.api.common.StateVector.CoordinateFrame
	11, // 21: aalyria.spacetime.api.common.StateVector.position:type_name -> aalyria.spacetime.api.common.Cartesian
	21, // 22: aalyria.spacetime.api.common.StateVector.velocity:type_name -> aalyria.spacetime.api.common.CartesianDot
	4,  // 23: aalyria.spacetime.api.common.StateVector.propagation_algorithm:type_name -> aalyria.spacetime.api.common.StateVector.PropagationAlgorithm
	33, // 24: aalyria.spacetime.api.common.Motion.interval:type_name -> google.type.Interval
	7,  // 25: aalyria.spacetime.api.common.Motion.geodetic_msl:type_name -> aalyria.spacetime.api.common.GeodeticMsl
	6,  // 26: aalyria.spacetime.api.common.Motion.geodetic_wgs84:type_name -> aalyria.spacetime.api.common.GeodeticWgs84
	14, // 27: aalyria.spacetime.api.common.Motion.ecef_fixed:type_name -> aalyria.spacetime.api.common.PointAxes
	16, // 28: aalyria.spacetime.api.common.Motion.ecef_interpolation:type_name -> aalyria.spacetime.api.common.PointAxesTemporalInterpolation
	17, // 29: aalyria.spacetime.api.common.Motion.cartographic_waypoints:type_name -> aalyria.spacetime.api.common.GeodeticWgs84TemporalInterpolation
	18, // 30: aalyria.spacetime.api.common.Motion.geodetic_waypoints:type_name -> aalyria.spacetime.api.common.GeodeticTemporalInterpolation
	19, // 31: aalyria.spacetime.api.common.Motion.tle:type_name -> aalyria.spacetime.api.common.TwoLineElementSet
	20, // 32: aalyria.spacetime.api.common.Motion.keplerian_elements:type_name -> aalyria.spacetime.api.common.KeplerianElements
	22, // 33: aalyria.spacetime.api.common.Motion.state_vector:type_name -> aalyria.spacetime.api.common.StateVector
	23, // 34: aalyria.spacetime.api.common.Motion.selenographic_mlr:type_name -> aalyria.spacetime.api.common.SelenographicMlr
	24, // 35: aalyria.spacetime.api.common.Motion.stk_ephem_and_attitude_file:type_name -> aalyria.spacetime.api.common.StkEphemAndAttitudeFile
	29, // 36: aalyria.spacetime.api.common.Motion.ccsds_orbit_ephemeris_message:type_name -> aalyria.spacetime.api.common.CcsdsOrbitEphemerisMessage
	37, // [37:37] is the sub-list for method output_type
	37, // [37:37] is the sub-list for method input_type
	37, // [37:37] is the sub-list for extension type_name
	37, // [37:37] is the sub-list for extension extendee
	0,  // [0:37] is the sub-list for field type_name
}

func init() { file_api_common_coordinates_proto_init() }
func file_api_common_coordinates_proto_init() {
	if File_api_common_coordinates_proto != nil {
		return
	}
	file_api_common_time_proto_init()
	file_api_common_coordinates_proto_msgTypes[22].OneofWrappers = []any{
		(*Motion_GeodeticMsl)(nil),
		(*Motion_GeodeticWgs84)(nil),
		(*Motion_EcefFixed)(nil),
		(*Motion_EcefInterpolation)(nil),
		(*Motion_CartographicWaypoints)(nil),
		(*Motion_GeodeticWaypoints)(nil),
		(*Motion_Tle)(nil),
		(*Motion_KeplerianElements)(nil),
		(*Motion_StateVector)(nil),
		(*Motion_SelenographicMlr)(nil),
		(*Motion_StkEphemAndAttitudeFile)(nil),
		(*Motion_CcsdsOrbitEphemerisMessage)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_common_coordinates_proto_rawDesc), len(file_api_common_coordinates_proto_rawDesc)),
			NumEnums:      6,
			NumMessages:   24,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_api_common_coordinates_proto_goTypes,
		DependencyIndexes: file_api_common_coordinates_proto_depIdxs,
		EnumInfos:         file_api_common_coordinates_proto_enumTypes,
		MessageInfos:      file_api_common_coordinates_proto_msgTypes,
	}.Build()
	File_api_common_coordinates_proto = out.File
	file_api_common_coordinates_proto_goTypes = nil
	file_api_common_coordinates_proto_depIdxs = nil
}
