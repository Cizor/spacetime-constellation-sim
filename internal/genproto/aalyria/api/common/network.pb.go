// Copyright 2023 Aalyria Technologies, Inc., and its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: api/common/network.proto

package common

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Uniquely identifies a network interface.
type NetworkInterfaceId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The unique ID of the node on which the interface is installed.
	NodeId *string `protobuf:"bytes,1,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// The node-unique interface ID.
	InterfaceId   *string `protobuf:"bytes,2,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkInterfaceId) Reset() {
	*x = NetworkInterfaceId{}
	mi := &file_api_common_network_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkInterfaceId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkInterfaceId) ProtoMessage() {}

func (x *NetworkInterfaceId) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkInterfaceId.ProtoReflect.Descriptor instead.
func (*NetworkInterfaceId) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{0}
}

func (x *NetworkInterfaceId) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *NetworkInterfaceId) GetInterfaceId() string {
	if x != nil && x.InterfaceId != nil {
		return *x.InterfaceId
	}
	return ""
}

// Defines rules for classifying a packet.
type PacketClassifier struct {
	state               protoimpl.MessageState                `protogen:"open.v1"`
	IpHeader            *PacketClassifier_IpHeader            `protobuf:"bytes,1,opt,name=ip_header,json=ipHeader" json:"ip_header,omitempty"`
	L4Header            *PacketClassifier_GenericLayer4Header `protobuf:"bytes,2,opt,name=l4_header,json=l4Header" json:"l4_header,omitempty"`
	EthernetHeader      *PacketClassifier_EthernetHeader      `protobuf:"bytes,3,opt,name=ethernet_header,json=ethernetHeader" json:"ethernet_header,omitempty"`
	MplsLabelStackEntry *PacketClassifier_MplsLabelStackEntry `protobuf:"bytes,4,opt,name=mpls_label_stack_entry,json=mplsLabelStackEntry" json:"mpls_label_stack_entry,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *PacketClassifier) Reset() {
	*x = PacketClassifier{}
	mi := &file_api_common_network_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketClassifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketClassifier) ProtoMessage() {}

func (x *PacketClassifier) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketClassifier.ProtoReflect.Descriptor instead.
func (*PacketClassifier) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{1}
}

func (x *PacketClassifier) GetIpHeader() *PacketClassifier_IpHeader {
	if x != nil {
		return x.IpHeader
	}
	return nil
}

func (x *PacketClassifier) GetL4Header() *PacketClassifier_GenericLayer4Header {
	if x != nil {
		return x.L4Header
	}
	return nil
}

func (x *PacketClassifier) GetEthernetHeader() *PacketClassifier_EthernetHeader {
	if x != nil {
		return x.EthernetHeader
	}
	return nil
}

func (x *PacketClassifier) GetMplsLabelStackEntry() *PacketClassifier_MplsLabelStackEntry {
	if x != nil {
		return x.MplsLabelStackEntry
	}
	return nil
}

// A subnet that can be expressed explicitly as an IP range, as a node ID, or as
// an interface ID. In the case of a node ID, the intent compiler will resolve
// the node ID to all the address ranges that the node represents. In the case
// of an interface ID, the intent compiler will resolve the interface ID to an
// address range of only the interface address.
type Subnet struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Subnet:
	//
	//	*Subnet_IpRange
	//	*Subnet_NodeId
	//	*Subnet_InterfaceId
	Subnet        isSubnet_Subnet `protobuf_oneof:"subnet"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Subnet) Reset() {
	*x = Subnet{}
	mi := &file_api_common_network_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Subnet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Subnet) ProtoMessage() {}

func (x *Subnet) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Subnet.ProtoReflect.Descriptor instead.
func (*Subnet) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{2}
}

func (x *Subnet) GetSubnet() isSubnet_Subnet {
	if x != nil {
		return x.Subnet
	}
	return nil
}

func (x *Subnet) GetIpRange() string {
	if x != nil {
		if x, ok := x.Subnet.(*Subnet_IpRange); ok {
			return x.IpRange
		}
	}
	return ""
}

func (x *Subnet) GetNodeId() string {
	if x != nil {
		if x, ok := x.Subnet.(*Subnet_NodeId); ok {
			return x.NodeId
		}
	}
	return ""
}

func (x *Subnet) GetInterfaceId() *NetworkInterfaceId {
	if x != nil {
		if x, ok := x.Subnet.(*Subnet_InterfaceId); ok {
			return x.InterfaceId
		}
	}
	return nil
}

type isSubnet_Subnet interface {
	isSubnet_Subnet()
}

type Subnet_IpRange struct {
	IpRange string `protobuf:"bytes,1,opt,name=ip_range,json=ipRange,oneof"`
}

type Subnet_NodeId struct {
	NodeId string `protobuf:"bytes,2,opt,name=node_id,json=nodeId,oneof"`
}

type Subnet_InterfaceId struct {
	// TODO: Remove when we can more cleanly specify a tunnel packet
	// classifier with node ID when multiple subnets are associated with a node.
	InterfaceId *NetworkInterfaceId `protobuf:"bytes,3,opt,name=interface_id,json=interfaceId,oneof"`
}

func (*Subnet_IpRange) isSubnet_Subnet() {}

func (*Subnet_NodeId) isSubnet_Subnet() {}

func (*Subnet_InterfaceId) isSubnet_Subnet() {}

// Classifier for IPv4 or IPv6 flows.
type IpFlowClassifier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Src   *Subnet                `protobuf:"bytes,1,opt,name=src" json:"src,omitempty"`
	Dst   *Subnet                `protobuf:"bytes,2,opt,name=dst" json:"dst,omitempty"`
	// IP protocol number.
	Protocol      *uint32 `protobuf:"varint,3,opt,name=protocol" json:"protocol,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IpFlowClassifier) Reset() {
	*x = IpFlowClassifier{}
	mi := &file_api_common_network_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IpFlowClassifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpFlowClassifier) ProtoMessage() {}

func (x *IpFlowClassifier) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpFlowClassifier.ProtoReflect.Descriptor instead.
func (*IpFlowClassifier) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{3}
}

func (x *IpFlowClassifier) GetSrc() *Subnet {
	if x != nil {
		return x.Src
	}
	return nil
}

func (x *IpFlowClassifier) GetDst() *Subnet {
	if x != nil {
		return x.Dst
	}
	return nil
}

func (x *IpFlowClassifier) GetProtocol() uint32 {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return 0
}

// MEF EVC E-Line Flow Classifier
//
// Suitable for describing a MEF 10.4 section 8.3.1 Point-to-Point EVC,
// specifically:
//
//   - "Ethernet Private Line Service (EPL)
//     Point-to-Point EVC, all to one bundling"
//
//     See also: MEF 6.3 Section 9.1, MEF 7.4 Section 11.1
//
//   - "Ethernet Virtual Private Line (EVPL)
//     Point-to-Point EVC, bundling and/or multiplexing"
//
//     See also: MEF 6.3 Section 9.2, MEF 7.4 Section 11.2
type EvcElineFlowClassifier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A locally meaningful name for traffic described by this classifier.
	//
	// Possible examples include:
	//   - the MEF 10.4 section 10.1 EVC EP ID service attribute that
	//     corresponds to the UNI and Map service attributes below, or
	//   - an identifier for an SR Policy or a specific pseudowire that
	//     will carry this traffic.
	//
	// This does not appear anywhere in the data plane and the value is
	// opaque to rest of the system.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// E.g., MEF 10.4 section 10.2 EVC EP UNI service attribute.
	// Node-local interface name; node MUST be inferred from additional
	// context (e.g. ServiceRequest or ScheduledControlUpdate).
	Uni *string `protobuf:"bytes,2,opt,name=uni" json:"uni,omitempty"`
	// MEF 10.4 section 10.4 EVC EP Map service attribute.
	//
	// For section 10.4.1 "EVC EP Map Service Attribute = List", add
	// all applicable non-zero, non-4095 Customer Edge VLAN IDs.
	//
	// For section 10.4.2 "EVC EP Map service attribute = All", leave
	// this list empty.
	//
	// For section 10.4.3 "EVC EP Map service attribute = UT/PT", use
	// only a single VLAN ID, either 0 (zero) or the value of the UNI's
	// Default CE-VLAN ID attribute (MEF 10.3 and earlier), whichever
	// has local meaning.
	VlanIds []uint32 `protobuf:"varint,3,rep,name=vlan_ids,json=vlanIds" json:"vlan_ids,omitempty"`
	// For use if Ethernet service frames are classified by another
	// network element and encapsulated inside an MPLS label stack
	// that uniquely identifies the flow.
	MplsStack     []*PacketClassifier_MplsLabelStackEntry `protobuf:"bytes,4,rep,name=mpls_stack,json=mplsStack" json:"mpls_stack,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EvcElineFlowClassifier) Reset() {
	*x = EvcElineFlowClassifier{}
	mi := &file_api_common_network_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EvcElineFlowClassifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EvcElineFlowClassifier) ProtoMessage() {}

func (x *EvcElineFlowClassifier) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EvcElineFlowClassifier.ProtoReflect.Descriptor instead.
func (*EvcElineFlowClassifier) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{4}
}

func (x *EvcElineFlowClassifier) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *EvcElineFlowClassifier) GetUni() string {
	if x != nil && x.Uni != nil {
		return *x.Uni
	}
	return ""
}

func (x *EvcElineFlowClassifier) GetVlanIds() []uint32 {
	if x != nil {
		return x.VlanIds
	}
	return nil
}

func (x *EvcElineFlowClassifier) GetMplsStack() []*PacketClassifier_MplsLabelStackEntry {
	if x != nil {
		return x.MplsStack
	}
	return nil
}

// Rules for matching a network flow.
type FlowClassifier struct {
	state              protoimpl.MessageState                `protogen:"open.v1"`
	IpClassifier       *IpFlowClassifier                     `protobuf:"bytes,1,opt,name=ip_classifier,json=ipClassifier" json:"ip_classifier,omitempty"`
	L4Classifier       *PacketClassifier_GenericLayer4Header `protobuf:"bytes,2,opt,name=l4_classifier,json=l4Classifier" json:"l4_classifier,omitempty"`
	EthernetClassifier *PacketClassifier_EthernetHeader      `protobuf:"bytes,3,opt,name=ethernet_classifier,json=ethernetClassifier" json:"ethernet_classifier,omitempty"`
	EvcElineClassifier *EvcElineFlowClassifier               `protobuf:"bytes,4,opt,name=evc_eline_classifier,json=evcElineClassifier" json:"evc_eline_classifier,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *FlowClassifier) Reset() {
	*x = FlowClassifier{}
	mi := &file_api_common_network_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowClassifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowClassifier) ProtoMessage() {}

func (x *FlowClassifier) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowClassifier.ProtoReflect.Descriptor instead.
func (*FlowClassifier) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{5}
}

func (x *FlowClassifier) GetIpClassifier() *IpFlowClassifier {
	if x != nil {
		return x.IpClassifier
	}
	return nil
}

func (x *FlowClassifier) GetL4Classifier() *PacketClassifier_GenericLayer4Header {
	if x != nil {
		return x.L4Classifier
	}
	return nil
}

func (x *FlowClassifier) GetEthernetClassifier() *PacketClassifier_EthernetHeader {
	if x != nil {
		return x.EthernetClassifier
	}
	return nil
}

func (x *FlowClassifier) GetEvcElineClassifier() *EvcElineFlowClassifier {
	if x != nil {
		return x.EvcElineClassifier
	}
	return nil
}

// If high is not specified, the range contains a single value, specified by
// low. If low and high are both specified, the range is [low, high]; the high
// value is part of the range. If low == high, it represents the single value
// of low (same as not providing a high value).
type PacketClassifier_ValueRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Low           *uint32                `protobuf:"varint,1,opt,name=low" json:"low,omitempty"`
	High          *uint32                `protobuf:"varint,2,opt,name=high" json:"high,omitempty"` // default is same value as "low"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PacketClassifier_ValueRange) Reset() {
	*x = PacketClassifier_ValueRange{}
	mi := &file_api_common_network_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketClassifier_ValueRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketClassifier_ValueRange) ProtoMessage() {}

func (x *PacketClassifier_ValueRange) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketClassifier_ValueRange.ProtoReflect.Descriptor instead.
func (*PacketClassifier_ValueRange) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{1, 0}
}

func (x *PacketClassifier_ValueRange) GetLow() uint32 {
	if x != nil && x.Low != nil {
		return *x.Low
	}
	return 0
}

func (x *PacketClassifier_ValueRange) GetHigh() uint32 {
	if x != nil && x.High != nil {
		return *x.High
	}
	return 0
}

// Classifier for IPv4 or IPv6 packet headers.
type PacketClassifier_IpHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This field is represented as an ASCII IPRange.
	SrcIpRange *string `protobuf:"bytes,1,opt,name=src_ip_range,json=srcIpRange" json:"src_ip_range,omitempty"`
	// This field is represented as an ASCII IPRange.
	DstIpRange *string `protobuf:"bytes,2,opt,name=dst_ip_range,json=dstIpRange" json:"dst_ip_range,omitempty"`
	// IP protocol number.
	Protocol      *uint32 `protobuf:"varint,3,opt,name=protocol" json:"protocol,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PacketClassifier_IpHeader) Reset() {
	*x = PacketClassifier_IpHeader{}
	mi := &file_api_common_network_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketClassifier_IpHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketClassifier_IpHeader) ProtoMessage() {}

func (x *PacketClassifier_IpHeader) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketClassifier_IpHeader.ProtoReflect.Descriptor instead.
func (*PacketClassifier_IpHeader) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{1, 1}
}

func (x *PacketClassifier_IpHeader) GetSrcIpRange() string {
	if x != nil && x.SrcIpRange != nil {
		return *x.SrcIpRange
	}
	return ""
}

func (x *PacketClassifier_IpHeader) GetDstIpRange() string {
	if x != nil && x.DstIpRange != nil {
		return *x.DstIpRange
	}
	return ""
}

func (x *PacketClassifier_IpHeader) GetProtocol() uint32 {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return 0
}

// Used to match ports for protocols TCP, UDP, SCTP, etc.
type PacketClassifier_GenericLayer4Header struct {
	state           protoimpl.MessageState         `protogen:"open.v1"`
	SourcePort      []*PacketClassifier_ValueRange `protobuf:"bytes,1,rep,name=source_port,json=sourcePort" json:"source_port,omitempty"`
	DestinationPort []*PacketClassifier_ValueRange `protobuf:"bytes,2,rep,name=destination_port,json=destinationPort" json:"destination_port,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PacketClassifier_GenericLayer4Header) Reset() {
	*x = PacketClassifier_GenericLayer4Header{}
	mi := &file_api_common_network_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketClassifier_GenericLayer4Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketClassifier_GenericLayer4Header) ProtoMessage() {}

func (x *PacketClassifier_GenericLayer4Header) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketClassifier_GenericLayer4Header.ProtoReflect.Descriptor instead.
func (*PacketClassifier_GenericLayer4Header) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{1, 2}
}

func (x *PacketClassifier_GenericLayer4Header) GetSourcePort() []*PacketClassifier_ValueRange {
	if x != nil {
		return x.SourcePort
	}
	return nil
}

func (x *PacketClassifier_GenericLayer4Header) GetDestinationPort() []*PacketClassifier_ValueRange {
	if x != nil {
		return x.DestinationPort
	}
	return nil
}

type PacketClassifier_EthernetHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// To match a multicast address set the multicast field. Alternatively, set
	// the desired matching address in the address field.
	//
	// Types that are valid to be assigned to Destination:
	//
	//	*PacketClassifier_EthernetHeader_Multicast
	//	*PacketClassifier_EthernetHeader_Address
	Destination   isPacketClassifier_EthernetHeader_Destination `protobuf_oneof:"destination"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PacketClassifier_EthernetHeader) Reset() {
	*x = PacketClassifier_EthernetHeader{}
	mi := &file_api_common_network_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketClassifier_EthernetHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketClassifier_EthernetHeader) ProtoMessage() {}

func (x *PacketClassifier_EthernetHeader) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketClassifier_EthernetHeader.ProtoReflect.Descriptor instead.
func (*PacketClassifier_EthernetHeader) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{1, 3}
}

func (x *PacketClassifier_EthernetHeader) GetDestination() isPacketClassifier_EthernetHeader_Destination {
	if x != nil {
		return x.Destination
	}
	return nil
}

func (x *PacketClassifier_EthernetHeader) GetMulticast() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Destination.(*PacketClassifier_EthernetHeader_Multicast); ok {
			return x.Multicast
		}
	}
	return nil
}

func (x *PacketClassifier_EthernetHeader) GetAddress() string {
	if x != nil {
		if x, ok := x.Destination.(*PacketClassifier_EthernetHeader_Address); ok {
			return x.Address
		}
	}
	return ""
}

type isPacketClassifier_EthernetHeader_Destination interface {
	isPacketClassifier_EthernetHeader_Destination()
}

type PacketClassifier_EthernetHeader_Multicast struct {
	Multicast *emptypb.Empty `protobuf:"bytes,1,opt,name=multicast,oneof"`
}

type PacketClassifier_EthernetHeader_Address struct {
	// Ethernet address in readable colon separated format. e.g.
	// "1:23:45:67:89:ab" or "01:23:45:67:89:ab"
	Address string `protobuf:"bytes,2,opt,name=address,oneof"`
}

func (*PacketClassifier_EthernetHeader_Multicast) isPacketClassifier_EthernetHeader_Destination() {}

func (*PacketClassifier_EthernetHeader_Address) isPacketClassifier_EthernetHeader_Destination() {}

// [RFC 3032](https://rfc-editor.org/rfc/rfc3032)
type PacketClassifier_MplsLabelStackEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Label         *uint32                `protobuf:"varint,1,opt,name=label" json:"label,omitempty"` // restricted to unsigned 20-bit values
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PacketClassifier_MplsLabelStackEntry) Reset() {
	*x = PacketClassifier_MplsLabelStackEntry{}
	mi := &file_api_common_network_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketClassifier_MplsLabelStackEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketClassifier_MplsLabelStackEntry) ProtoMessage() {}

func (x *PacketClassifier_MplsLabelStackEntry) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_network_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketClassifier_MplsLabelStackEntry.ProtoReflect.Descriptor instead.
func (*PacketClassifier_MplsLabelStackEntry) Descriptor() ([]byte, []int) {
	return file_api_common_network_proto_rawDescGZIP(), []int{1, 4}
}

func (x *PacketClassifier_MplsLabelStackEntry) GetLabel() uint32 {
	if x != nil && x.Label != nil {
		return *x.Label
	}
	return 0
}

var File_api_common_network_proto protoreflect.FileDescriptor

const file_api_common_network_proto_rawDesc = "" +
	"\n" +
	"\x18api/common/network.proto\x12\x1caalyria.spacetime.api.common\x1a\x1bgoogle/protobuf/empty.proto\"P\n" +
	"\x12NetworkInterfaceId\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12!\n" +
	"\finterface_id\x18\x02 \x01(\tR\vinterfaceId\"\xf8\a\n" +
	"\x10PacketClassifier\x12T\n" +
	"\tip_header\x18\x01 \x01(\v27.aalyria.spacetime.api.common.PacketClassifier.IpHeaderR\bipHeader\x12_\n" +
	"\tl4_header\x18\x02 \x01(\v2B.aalyria.spacetime.api.common.PacketClassifier.GenericLayer4HeaderR\bl4Header\x12f\n" +
	"\x0fethernet_header\x18\x03 \x01(\v2=.aalyria.spacetime.api.common.PacketClassifier.EthernetHeaderR\x0eethernetHeader\x12w\n" +
	"\x16mpls_label_stack_entry\x18\x04 \x01(\v2B.aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntryR\x13mplsLabelStackEntry\x1a<\n" +
	"\n" +
	"ValueRange\x12\x10\n" +
	"\x03low\x18\x01 \x01(\rR\x03low\x12\x12\n" +
	"\x04high\x18\x02 \x01(\rR\x04highJ\b\b\x03\x10\x80\x80\x80\x80\x02\x1at\n" +
	"\bIpHeader\x12 \n" +
	"\fsrc_ip_range\x18\x01 \x01(\tR\n" +
	"srcIpRange\x12 \n" +
	"\fdst_ip_range\x18\x02 \x01(\tR\n" +
	"dstIpRange\x12\x1a\n" +
	"\bprotocol\x18\x03 \x01(\rR\bprotocolJ\b\b\x04\x10\x80\x80\x80\x80\x02\x1a\xe1\x01\n" +
	"\x13GenericLayer4Header\x12Z\n" +
	"\vsource_port\x18\x01 \x03(\v29.aalyria.spacetime.api.common.PacketClassifier.ValueRangeR\n" +
	"sourcePort\x12d\n" +
	"\x10destination_port\x18\x02 \x03(\v29.aalyria.spacetime.api.common.PacketClassifier.ValueRangeR\x0fdestinationPortJ\b\b\x03\x10\x80\x80\x80\x80\x02\x1a}\n" +
	"\x0eEthernetHeader\x126\n" +
	"\tmulticast\x18\x01 \x01(\v2\x16.google.protobuf.EmptyH\x00R\tmulticast\x12\x1a\n" +
	"\aaddress\x18\x02 \x01(\tH\x00R\aaddressB\r\n" +
	"\vdestinationJ\b\b\x03\x10\x80\x80\x80\x80\x02\x1a+\n" +
	"\x13MplsLabelStackEntry\x12\x14\n" +
	"\x05label\x18\x01 \x01(\rR\x05labelJ\b\b\x05\x10\x80\x80\x80\x80\x02\"\xab\x01\n" +
	"\x06Subnet\x12\x1b\n" +
	"\bip_range\x18\x01 \x01(\tH\x00R\aipRange\x12\x19\n" +
	"\anode_id\x18\x02 \x01(\tH\x00R\x06nodeId\x12U\n" +
	"\finterface_id\x18\x03 \x01(\v20.aalyria.spacetime.api.common.NetworkInterfaceIdH\x00R\vinterfaceIdB\b\n" +
	"\x06subnetJ\b\b\x04\x10\x80\x80\x80\x80\x02\"\xa8\x01\n" +
	"\x10IpFlowClassifier\x126\n" +
	"\x03src\x18\x01 \x01(\v2$.aalyria.spacetime.api.common.SubnetR\x03src\x126\n" +
	"\x03dst\x18\x02 \x01(\v2$.aalyria.spacetime.api.common.SubnetR\x03dst\x12\x1a\n" +
	"\bprotocol\x18\x03 \x01(\rR\bprotocolJ\b\b\x04\x10\x80\x80\x80\x80\x02\"\xb8\x01\n" +
	"\x16EvcElineFlowClassifier\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x10\n" +
	"\x03uni\x18\x02 \x01(\tR\x03uni\x12\x19\n" +
	"\bvlan_ids\x18\x03 \x03(\rR\avlanIds\x12a\n" +
	"\n" +
	"mpls_stack\x18\x04 \x03(\v2B.aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntryR\tmplsStack\"\xb0\x03\n" +
	"\x0eFlowClassifier\x12S\n" +
	"\rip_classifier\x18\x01 \x01(\v2..aalyria.spacetime.api.common.IpFlowClassifierR\fipClassifier\x12g\n" +
	"\rl4_classifier\x18\x02 \x01(\v2B.aalyria.spacetime.api.common.PacketClassifier.GenericLayer4HeaderR\fl4Classifier\x12n\n" +
	"\x13ethernet_classifier\x18\x03 \x01(\v2=.aalyria.spacetime.api.common.PacketClassifier.EthernetHeaderR\x12ethernetClassifier\x12f\n" +
	"\x14evc_eline_classifier\x18\x04 \x01(\v24.aalyria.spacetime.api.common.EvcElineFlowClassifierR\x12evcElineClassifierJ\b\b\x05\x10\x80\x80\x80\x80\x02BD\n" +
	" com.aalyria.spacetime.api.commonZ aalyria.com/spacetime/api/common"

var (
	file_api_common_network_proto_rawDescOnce sync.Once
	file_api_common_network_proto_rawDescData []byte
)

func file_api_common_network_proto_rawDescGZIP() []byte {
	file_api_common_network_proto_rawDescOnce.Do(func() {
		file_api_common_network_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_common_network_proto_rawDesc), len(file_api_common_network_proto_rawDesc)))
	})
	return file_api_common_network_proto_rawDescData
}

var file_api_common_network_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_api_common_network_proto_goTypes = []any{
	(*NetworkInterfaceId)(nil),                   // 0: aalyria.spacetime.api.common.NetworkInterfaceId
	(*PacketClassifier)(nil),                     // 1: aalyria.spacetime.api.common.PacketClassifier
	(*Subnet)(nil),                               // 2: aalyria.spacetime.api.common.Subnet
	(*IpFlowClassifier)(nil),                     // 3: aalyria.spacetime.api.common.IpFlowClassifier
	(*EvcElineFlowClassifier)(nil),               // 4: aalyria.spacetime.api.common.EvcElineFlowClassifier
	(*FlowClassifier)(nil),                       // 5: aalyria.spacetime.api.common.FlowClassifier
	(*PacketClassifier_ValueRange)(nil),          // 6: aalyria.spacetime.api.common.PacketClassifier.ValueRange
	(*PacketClassifier_IpHeader)(nil),            // 7: aalyria.spacetime.api.common.PacketClassifier.IpHeader
	(*PacketClassifier_GenericLayer4Header)(nil), // 8: aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header
	(*PacketClassifier_EthernetHeader)(nil),      // 9: aalyria.spacetime.api.common.PacketClassifier.EthernetHeader
	(*PacketClassifier_MplsLabelStackEntry)(nil), // 10: aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry
	(*emptypb.Empty)(nil),                        // 11: google.protobuf.Empty
}
var file_api_common_network_proto_depIdxs = []int32{
	7,  // 0: aalyria.spacetime.api.common.PacketClassifier.ip_header:type_name -> aalyria.spacetime.api.common.PacketClassifier.IpHeader
	8,  // 1: aalyria.spacetime.api.common.PacketClassifier.l4_header:type_name -> aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header
	9,  // 2: aalyria.spacetime.api.common.PacketClassifier.ethernet_header:type_name -> aalyria.spacetime.api.common.PacketClassifier.EthernetHeader
	10, // 3: aalyria.spacetime.api.common.PacketClassifier.mpls_label_stack_entry:type_name -> aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry
	0,  // 4: aalyria.spacetime.api.common.Subnet.interface_id:type_name -> aalyria.spacetime.api.common.NetworkInterfaceId
	2,  // 5: aalyria.spacetime.api.common.IpFlowClassifier.src:type_name -> aalyria.spacetime.api.common.Subnet
	2,  // 6: aalyria.spacetime.api.common.IpFlowClassifier.dst:type_name -> aalyria.spacetime.api.common.Subnet
	10, // 7: aalyria.spacetime.api.common.EvcElineFlowClassifier.mpls_stack:type_name -> aalyria.spacetime.api.common.PacketClassifier.MplsLabelStackEntry
	3,  // 8: aalyria.spacetime.api.common.FlowClassifier.ip_classifier:type_name -> aalyria.spacetime.api.common.IpFlowClassifier
	8,  // 9: aalyria.spacetime.api.common.FlowClassifier.l4_classifier:type_name -> aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header
	9,  // 10: aalyria.spacetime.api.common.FlowClassifier.ethernet_classifier:type_name -> aalyria.spacetime.api.common.PacketClassifier.EthernetHeader
	4,  // 11: aalyria.spacetime.api.common.FlowClassifier.evc_eline_classifier:type_name -> aalyria.spacetime.api.common.EvcElineFlowClassifier
	6,  // 12: aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.source_port:type_name -> aalyria.spacetime.api.common.PacketClassifier.ValueRange
	6,  // 13: aalyria.spacetime.api.common.PacketClassifier.GenericLayer4Header.destination_port:type_name -> aalyria.spacetime.api.common.PacketClassifier.ValueRange
	11, // 14: aalyria.spacetime.api.common.PacketClassifier.EthernetHeader.multicast:type_name -> google.protobuf.Empty
	15, // [15:15] is the sub-list for method output_type
	15, // [15:15] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_api_common_network_proto_init() }
func file_api_common_network_proto_init() {
	if File_api_common_network_proto != nil {
		return
	}
	file_api_common_network_proto_msgTypes[2].OneofWrappers = []any{
		(*Subnet_IpRange)(nil),
		(*Subnet_NodeId)(nil),
		(*Subnet_InterfaceId)(nil),
	}
	file_api_common_network_proto_msgTypes[9].OneofWrappers = []any{
		(*PacketClassifier_EthernetHeader_Multicast)(nil),
		(*PacketClassifier_EthernetHeader_Address)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_common_network_proto_rawDesc), len(file_api_common_network_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_api_common_network_proto_goTypes,
		DependencyIndexes: file_api_common_network_proto_depIdxs,
		MessageInfos:      file_api_common_network_proto_msgTypes,
	}.Build()
	File_api_common_network_proto = out.File
	file_api_common_network_proto_goTypes = nil
	file_api_common_network_proto_depIdxs = nil
}
