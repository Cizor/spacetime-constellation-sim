// Copyright 2023 Aalyria Technologies, Inc., and its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file contains Spacetime's abstraction for representing the modulation
// and coding (MODCOD) scheme that would be selected by the adaptive or fixed
// coding and modulation, based on a given received signal quality.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: api/common/wireless_modcod.proto

package common

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// A mapping between thresholds of various measurements of received signal
// quality to the effective Layer 2 data rate that the link could sustain at
// this received signal quality.
//
// As an example of how this message could be populated, consider the DVB-S2X
// standard. Table 1 of the standard relates MODCODs to their ideal Es/N0:
//
//	Canonical MODCOD  |    Spectral efficiency  |  Ideal Es/N0 [dB] for (AWGN
//	      name        |       [bit/symbol]      |  Linear Channel) (Normative)
//	-----------------------------------------------------------------------
//	     QPSK 2/9     |        0.43484          |          -2.85
//	     QPSK 13/45   |        0.567805         |          -2.03
//	     QPSK 9/20    |        0.889135         |           0.22
//	     QPSK 11/20   |        1.088581         |           1.45
//
// ...
// For reference, see ETSI TR 102 376-2 V1.2.1 (2021-01) which is accessible
// from http://www.etsi.org/standards-search.
//
// This table can be used to define the carrier_to_noise_plus_interference_steps
// of an AdaptiveDataRateTable.
//  1. To compute the C/N values, note that:
//     C/N = (Es / N0) + (symbol_rate / bandwidth)     [using dB math]
//
// Suppose (symbol_rate / bandwidth) = 1 / 1.1 = 0.9091 = -0.4139 dB.
//  2. To compute the achievable data rate, note that:
//     Data rate = (spectral_efficiency) * (symbol_rate)
//
// Suppose symbol_rate = 100Msps = 100_000_000 symbols/second.
//
// Using these relationships, a CarrierToNoisePlusInterferenceDataRateMapping
// can be defined. For QPSK 2/9:
//  1. To calculate C/N:
//     C/N = (-2.85 dB) + (-0.4139 dB) = -3.2639 dB
//  2. To calculate the achievable data rate:
//     Data rate = (0.43484 bits/symbol) * (100_000_000 symbols/second)
//     = 43_484_000 bits/second = 43.484Mbps
//
// The following rows could be converted similarly to populate all
// carrier_to_noise_plus_interference_steps.
// This approach can be tuned based on the actual modems and their measured
// implementation loss and supported set of MODCODs, etc.
//
// Also, in many modems' Adaptive Coding and Modulation configuration, there is
// often a table that relates some measurement of received signal quality to the
// MODCOD that the system will choose. A similar approach as the preceding
// example can be used to define an AdaptiveDataRateTable from these tables.
type AdaptiveDataRateTable struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// WARNING: This ID is unused.
	//
	// Deprecated: Marked as deprecated in api/common/wireless_modcod.proto.
	Id *string `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
	// The elements should be sorted by min_carrier_to_noise_plus_interference_db
	// in ascending order.
	CarrierToNoisePlusInterferenceSteps []*AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping `protobuf:"bytes,2,rep,name=carrier_to_noise_plus_interference_steps,json=carrierToNoisePlusInterferenceSteps" json:"carrier_to_noise_plus_interference_steps,omitempty"`
	// The elements should be sorted by min_received_signal_power_dbw in ascending
	// order.
	ReceivedSignalPowerSteps []*AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping `protobuf:"bytes,1,rep,name=received_signal_power_steps,json=receivedSignalPowerSteps" json:"received_signal_power_steps,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *AdaptiveDataRateTable) Reset() {
	*x = AdaptiveDataRateTable{}
	mi := &file_api_common_wireless_modcod_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdaptiveDataRateTable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveDataRateTable) ProtoMessage() {}

func (x *AdaptiveDataRateTable) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_wireless_modcod_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveDataRateTable.ProtoReflect.Descriptor instead.
func (*AdaptiveDataRateTable) Descriptor() ([]byte, []int) {
	return file_api_common_wireless_modcod_proto_rawDescGZIP(), []int{0}
}

// Deprecated: Marked as deprecated in api/common/wireless_modcod.proto.
func (x *AdaptiveDataRateTable) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *AdaptiveDataRateTable) GetCarrierToNoisePlusInterferenceSteps() []*AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping {
	if x != nil {
		return x.CarrierToNoisePlusInterferenceSteps
	}
	return nil
}

func (x *AdaptiveDataRateTable) GetReceivedSignalPowerSteps() []*AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping {
	if x != nil {
		return x.ReceivedSignalPowerSteps
	}
	return nil
}

// A mapping between thresholds of Carrier-to-(Noise + Interference)
// (C/(N+I)) to the Layer 2 data rate that the link could sustain at this
// C/(N+I).
type AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ratio of the power of the carrier (or signal) at the demod input to
	// the noise power of the signal plus the power of the interfering signals,
	// in dB.
	// Required.
	MinCarrierToNoisePlusInterferenceDb *float64 `protobuf:"fixed64,1,opt,name=min_carrier_to_noise_plus_interference_db,json=minCarrierToNoisePlusInterferenceDb" json:"min_carrier_to_noise_plus_interference_db,omitempty"`
	// The layer 2 data rate achievable, in bits per second, provided the
	// receiver receives at least the min_carrier_to_noise_plus_interference_db.
	// Required.
	TxDataRateBps *float64 `protobuf:"fixed64,2,opt,name=tx_data_rate_bps,json=txDataRateBps" json:"tx_data_rate_bps,omitempty"`
	// A human readable name (e.g. "QPSK-LDPC-2-3") describing the modulation
	// and coding scheme associated with the Carrier-to-(Noise + Interference)
	// to data rate mapping.
	// This name is not used in any logic. This is purely for human operators to
	// associate a specific C/(N+I) threshold with a MODCOD.
	ModCodSchemeName *string `protobuf:"bytes,3,opt,name=mod_cod_scheme_name,json=modCodSchemeName" json:"mod_cod_scheme_name,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping) Reset() {
	*x = AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping{}
	mi := &file_api_common_wireless_modcod_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping) ProtoMessage() {}

func (x *AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_wireless_modcod_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping.ProtoReflect.Descriptor instead.
func (*AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping) Descriptor() ([]byte, []int) {
	return file_api_common_wireless_modcod_proto_rawDescGZIP(), []int{0, 0}
}

func (x *AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping) GetMinCarrierToNoisePlusInterferenceDb() float64 {
	if x != nil && x.MinCarrierToNoisePlusInterferenceDb != nil {
		return *x.MinCarrierToNoisePlusInterferenceDb
	}
	return 0
}

func (x *AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping) GetTxDataRateBps() float64 {
	if x != nil && x.TxDataRateBps != nil {
		return *x.TxDataRateBps
	}
	return 0
}

func (x *AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping) GetModCodSchemeName() string {
	if x != nil && x.ModCodSchemeName != nil {
		return *x.ModCodSchemeName
	}
	return ""
}

// A mapping between thresholds of received signal power to the Layer 2 data
// rate that the link could sustain at this received power.
type AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The power of the intended signal at the receiver output, in dBW.
	// Required.
	MinReceivedSignalPowerDbw *float64 `protobuf:"fixed64,1,opt,name=min_received_signal_power_dbw,json=minReceivedSignalPowerDbw" json:"min_received_signal_power_dbw,omitempty"`
	// The layer 2 data rate achievable, in bits per second, provided the
	// receiver receives at least the min_received_signal_power_dbw.
	// Required.
	TxDataRateBps *float64 `protobuf:"fixed64,2,opt,name=tx_data_rate_bps,json=txDataRateBps" json:"tx_data_rate_bps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping) Reset() {
	*x = AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping{}
	mi := &file_api_common_wireless_modcod_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping) ProtoMessage() {}

func (x *AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_wireless_modcod_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping.ProtoReflect.Descriptor instead.
func (*AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping) Descriptor() ([]byte, []int) {
	return file_api_common_wireless_modcod_proto_rawDescGZIP(), []int{0, 1}
}

func (x *AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping) GetMinReceivedSignalPowerDbw() float64 {
	if x != nil && x.MinReceivedSignalPowerDbw != nil {
		return *x.MinReceivedSignalPowerDbw
	}
	return 0
}

func (x *AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping) GetTxDataRateBps() float64 {
	if x != nil && x.TxDataRateBps != nil {
		return *x.TxDataRateBps
	}
	return 0
}

var File_api_common_wireless_modcod_proto protoreflect.FileDescriptor

const file_api_common_wireless_modcod_proto_rawDesc = "" +
	"\n" +
	" api/common/wireless_modcod.proto\x12\x1caalyria.spacetime.api.common\"\xf2\x05\n" +
	"\x15AdaptiveDataRateTable\x12\x12\n" +
	"\x02id\x18\x03 \x01(\tB\x02\x18\x01R\x02id\x12\xb8\x01\n" +
	"(carrier_to_noise_plus_interference_steps\x18\x02 \x03(\v2a.aalyria.spacetime.api.common.AdaptiveDataRateTable.CarrierToNoisePlusInterferenceDataRateMappingR#carrierToNoisePlusInterferenceSteps\x12\x95\x01\n" +
	"\x1breceived_signal_power_steps\x18\x01 \x03(\v2V.aalyria.spacetime.api.common.AdaptiveDataRateTable.ReceivedSignalPowerDataRateMappingR\x18receivedSignalPowerSteps\x1a\xdf\x01\n" +
	"-CarrierToNoisePlusInterferenceDataRateMapping\x12V\n" +
	")min_carrier_to_noise_plus_interference_db\x18\x01 \x01(\x01R#minCarrierToNoisePlusInterferenceDb\x12'\n" +
	"\x10tx_data_rate_bps\x18\x02 \x01(\x01R\rtxDataRateBps\x12-\n" +
	"\x13mod_cod_scheme_name\x18\x03 \x01(\tR\x10modCodSchemeName\x1a\x8f\x01\n" +
	"\"ReceivedSignalPowerDataRateMapping\x12@\n" +
	"\x1dmin_received_signal_power_dbw\x18\x01 \x01(\x01R\x19minReceivedSignalPowerDbw\x12'\n" +
	"\x10tx_data_rate_bps\x18\x02 \x01(\x01R\rtxDataRateBpsBD\n" +
	" com.aalyria.spacetime.api.commonZ aalyria.com/spacetime/api/common"

var (
	file_api_common_wireless_modcod_proto_rawDescOnce sync.Once
	file_api_common_wireless_modcod_proto_rawDescData []byte
)

func file_api_common_wireless_modcod_proto_rawDescGZIP() []byte {
	file_api_common_wireless_modcod_proto_rawDescOnce.Do(func() {
		file_api_common_wireless_modcod_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_common_wireless_modcod_proto_rawDesc), len(file_api_common_wireless_modcod_proto_rawDesc)))
	})
	return file_api_common_wireless_modcod_proto_rawDescData
}

var file_api_common_wireless_modcod_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_api_common_wireless_modcod_proto_goTypes = []any{
	(*AdaptiveDataRateTable)(nil), // 0: aalyria.spacetime.api.common.AdaptiveDataRateTable
	(*AdaptiveDataRateTable_CarrierToNoisePlusInterferenceDataRateMapping)(nil), // 1: aalyria.spacetime.api.common.AdaptiveDataRateTable.CarrierToNoisePlusInterferenceDataRateMapping
	(*AdaptiveDataRateTable_ReceivedSignalPowerDataRateMapping)(nil),            // 2: aalyria.spacetime.api.common.AdaptiveDataRateTable.ReceivedSignalPowerDataRateMapping
}
var file_api_common_wireless_modcod_proto_depIdxs = []int32{
	1, // 0: aalyria.spacetime.api.common.AdaptiveDataRateTable.carrier_to_noise_plus_interference_steps:type_name -> aalyria.spacetime.api.common.AdaptiveDataRateTable.CarrierToNoisePlusInterferenceDataRateMapping
	2, // 1: aalyria.spacetime.api.common.AdaptiveDataRateTable.received_signal_power_steps:type_name -> aalyria.spacetime.api.common.AdaptiveDataRateTable.ReceivedSignalPowerDataRateMapping
	2, // [2:2] is the sub-list for method output_type
	2, // [2:2] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

func init() { file_api_common_wireless_modcod_proto_init() }
func file_api_common_wireless_modcod_proto_init() {
	if File_api_common_wireless_modcod_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_common_wireless_modcod_proto_rawDesc), len(file_api_common_wireless_modcod_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_api_common_wireless_modcod_proto_goTypes,
		DependencyIndexes: file_api_common_wireless_modcod_proto_depIdxs,
		MessageInfos:      file_api_common_wireless_modcod_proto_msgTypes,
	}.Build()
	File_api_common_wireless_modcod_proto = out.File
	file_api_common_wireless_modcod_proto_goTypes = nil
	file_api_common_wireless_modcod_proto_depIdxs = nil
}
