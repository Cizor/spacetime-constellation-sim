// Copyright 2023 Aalyria Technologies, Inc., and its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Protobuf messages used to model antennas and optical pointing elements.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: api/common/platform_antenna.proto

package common

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Models an aperture (RF or optical) with a certain signal gain pattern.
// It may optionally be oriented independently of its platform to track objects.
type AntennaDefinition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// An optional friendly, human-readable string.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Antenna coordinates may be specified using a fixed offset from their
	// parent platform.  If this field is not used, the antenna will share the
	// coordinates of its parent platform.
	FixedCoordinateOffset *PointAxes `protobuf:"bytes,3,opt,name=fixed_coordinate_offset,json=fixedCoordinateOffset" json:"fixed_coordinate_offset,omitempty"`
	// Parameters relevant to antenna steering and target acquisition.
	// This field should be omitted when modeling a non-steerable beam.
	Targeting *Targeting `protobuf:"bytes,18,opt,name=targeting" json:"targeting,omitempty"`
	// Identifies the antenna's gain pattern.
	AntennaPatternId *string `protobuf:"bytes,10,opt,name=antenna_pattern_id,json=antennaPatternId" json:"antenna_pattern_id,omitempty"`
	// Defines the polarization over time, if any. This field is optional.
	Polarization *Polarization `protobuf:"bytes,17,opt,name=polarization" json:"polarization,omitempty"`
	// Optional. Defines the unobstructed field of regard (FOR) for steerable
	// antennas. If this field is set for a fixed antenna, it will instead act to
	// further constrain the field of view (FOV) that is otherwise defined by the
	// antenna gain pattern.
	FieldOfRegard *Projection `protobuf:"bytes,11,opt,name=field_of_regard,json=fieldOfRegard" json:"field_of_regard,omitempty"`
	// Specifies obstructions that subtract from the accessible field-of-regard.
	Obstructions         []*Projection                      `protobuf:"bytes,12,rep,name=obstructions" json:"obstructions,omitempty"`
	AzimuthElevationMask []*AntennaDefinition_ElevationMask `protobuf:"bytes,9,rep,name=azimuth_elevation_mask,json=azimuthElevationMask" json:"azimuth_elevation_mask,omitempty"`
	// Factors that constrain the accessibility of links that use the antenna.
	Constraints   *AntennaConstraints `protobuf:"bytes,6,opt,name=constraints" json:"constraints,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AntennaDefinition) Reset() {
	*x = AntennaDefinition{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AntennaDefinition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AntennaDefinition) ProtoMessage() {}

func (x *AntennaDefinition) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AntennaDefinition.ProtoReflect.Descriptor instead.
func (*AntennaDefinition) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{0}
}

func (x *AntennaDefinition) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *AntennaDefinition) GetFixedCoordinateOffset() *PointAxes {
	if x != nil {
		return x.FixedCoordinateOffset
	}
	return nil
}

func (x *AntennaDefinition) GetTargeting() *Targeting {
	if x != nil {
		return x.Targeting
	}
	return nil
}

func (x *AntennaDefinition) GetAntennaPatternId() string {
	if x != nil && x.AntennaPatternId != nil {
		return *x.AntennaPatternId
	}
	return ""
}

func (x *AntennaDefinition) GetPolarization() *Polarization {
	if x != nil {
		return x.Polarization
	}
	return nil
}

func (x *AntennaDefinition) GetFieldOfRegard() *Projection {
	if x != nil {
		return x.FieldOfRegard
	}
	return nil
}

func (x *AntennaDefinition) GetObstructions() []*Projection {
	if x != nil {
		return x.Obstructions
	}
	return nil
}

func (x *AntennaDefinition) GetAzimuthElevationMask() []*AntennaDefinition_ElevationMask {
	if x != nil {
		return x.AzimuthElevationMask
	}
	return nil
}

func (x *AntennaDefinition) GetConstraints() *AntennaConstraints {
	if x != nil {
		return x.Constraints
	}
	return nil
}

type AntennaConstraints struct {
	state              protoimpl.MessageState                           `protogen:"open.v1"`
	LinkRange          *AntennaConstraints_LinkRangeConstraint          `protobuf:"bytes,1,opt,name=link_range,json=linkRange" json:"link_range,omitempty"`
	AzimuthAngleRate   *AntennaConstraints_AzimuthAngleRateConstraint   `protobuf:"bytes,3,opt,name=azimuth_angle_rate,json=azimuthAngleRate" json:"azimuth_angle_rate,omitempty"`
	ElevationAngleRate *AntennaConstraints_ElevationAngleRateConstraint `protobuf:"bytes,4,opt,name=elevation_angle_rate,json=elevationAngleRate" json:"elevation_angle_rate,omitempty"`
	TotalAngularRate   *AntennaConstraints_TotalAngularRateConstraint   `protobuf:"bytes,5,opt,name=total_angular_rate,json=totalAngularRate" json:"total_angular_rate,omitempty"`
	// Link accessibility will be constrained when the angle between the sun's
	// center of mass and a receiving antenna's boresight is less than this
	// threshold (in degrees).
	// The sun is ~32 arcminutes in diameter when viewed from the Earth's surface,
	// and margin for that should be built into the configured value, if it is
	// significant to the user.
	MinimumSunAngleDeg *float64 `protobuf:"fixed64,6,opt,name=minimum_sun_angle_deg,json=minimumSunAngleDeg" json:"minimum_sun_angle_deg,omitempty"`
	// Link accessibility will be constrained when the angle between the boresight
	// and any AzimuthElevationMask associated with the antenna is less than this
	// threshold (in degrees). The is measured as the angular separation in the
	// positive (vertical) direction from the maximum obscured elevation in the
	// azimuth direction of the link vector.
	MinimumAzimuthElevationMaskSeparationDeg *float64 `protobuf:"fixed64,7,opt,name=minimum_azimuth_elevation_mask_separation_deg,json=minimumAzimuthElevationMaskSeparationDeg" json:"minimum_azimuth_elevation_mask_separation_deg,omitempty"`
	unknownFields                            protoimpl.UnknownFields
	sizeCache                                protoimpl.SizeCache
}

func (x *AntennaConstraints) Reset() {
	*x = AntennaConstraints{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AntennaConstraints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AntennaConstraints) ProtoMessage() {}

func (x *AntennaConstraints) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AntennaConstraints.ProtoReflect.Descriptor instead.
func (*AntennaConstraints) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{1}
}

func (x *AntennaConstraints) GetLinkRange() *AntennaConstraints_LinkRangeConstraint {
	if x != nil {
		return x.LinkRange
	}
	return nil
}

func (x *AntennaConstraints) GetAzimuthAngleRate() *AntennaConstraints_AzimuthAngleRateConstraint {
	if x != nil {
		return x.AzimuthAngleRate
	}
	return nil
}

func (x *AntennaConstraints) GetElevationAngleRate() *AntennaConstraints_ElevationAngleRateConstraint {
	if x != nil {
		return x.ElevationAngleRate
	}
	return nil
}

func (x *AntennaConstraints) GetTotalAngularRate() *AntennaConstraints_TotalAngularRateConstraint {
	if x != nil {
		return x.TotalAngularRate
	}
	return nil
}

func (x *AntennaConstraints) GetMinimumSunAngleDeg() float64 {
	if x != nil && x.MinimumSunAngleDeg != nil {
		return *x.MinimumSunAngleDeg
	}
	return 0
}

func (x *AntennaConstraints) GetMinimumAzimuthElevationMaskSeparationDeg() float64 {
	if x != nil && x.MinimumAzimuthElevationMaskSeparationDeg != nil {
		return *x.MinimumAzimuthElevationMaskSeparationDeg
	}
	return 0
}

type Projection struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ShapeType:
	//
	//	*Projection_Conic_
	//	*Projection_Rectangular_
	//	*Projection_Custom_
	ShapeType     isProjection_ShapeType `protobuf_oneof:"shape_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Projection) Reset() {
	*x = Projection{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Projection) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Projection) ProtoMessage() {}

func (x *Projection) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Projection.ProtoReflect.Descriptor instead.
func (*Projection) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{2}
}

func (x *Projection) GetShapeType() isProjection_ShapeType {
	if x != nil {
		return x.ShapeType
	}
	return nil
}

func (x *Projection) GetConic() *Projection_Conic {
	if x != nil {
		if x, ok := x.ShapeType.(*Projection_Conic_); ok {
			return x.Conic
		}
	}
	return nil
}

func (x *Projection) GetRectangular() *Projection_Rectangular {
	if x != nil {
		if x, ok := x.ShapeType.(*Projection_Rectangular_); ok {
			return x.Rectangular
		}
	}
	return nil
}

func (x *Projection) GetCustom() *Projection_Custom {
	if x != nil {
		if x, ok := x.ShapeType.(*Projection_Custom_); ok {
			return x.Custom
		}
	}
	return nil
}

type isProjection_ShapeType interface {
	isProjection_ShapeType()
}

type Projection_Conic_ struct {
	Conic *Projection_Conic `protobuf:"bytes,1,opt,name=conic,oneof"`
}

type Projection_Rectangular_ struct {
	Rectangular *Projection_Rectangular `protobuf:"bytes,2,opt,name=rectangular,oneof"`
}

type Projection_Custom_ struct {
	Custom *Projection_Custom `protobuf:"bytes,3,opt,name=custom,oneof"`
}

func (*Projection_Conic_) isProjection_ShapeType() {}

func (*Projection_Rectangular_) isProjection_ShapeType() {}

func (*Projection_Custom_) isProjection_ShapeType() {}

type Polarization struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*Polarization_Constant_
	Source        isPolarization_Source `protobuf_oneof:"source"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Polarization) Reset() {
	*x = Polarization{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Polarization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Polarization) ProtoMessage() {}

func (x *Polarization) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Polarization.ProtoReflect.Descriptor instead.
func (*Polarization) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{3}
}

func (x *Polarization) GetSource() isPolarization_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *Polarization) GetConstant() *Polarization_Constant {
	if x != nil {
		if x, ok := x.Source.(*Polarization_Constant_); ok {
			return x.Constant
		}
	}
	return nil
}

type isPolarization_Source interface {
	isPolarization_Source()
}

type Polarization_Constant_ struct {
	Constant *Polarization_Constant `protobuf:"bytes,1,opt,name=constant,oneof"`
}

func (*Polarization_Constant_) isPolarization_Source() {}

type Targeting struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The format to use when providing the antenna with target acquisition info.
	MotionFormat  *Motion_Type `protobuf:"varint,1,opt,name=motion_format,json=motionFormat,enum=aalyria.spacetime.api.common.Motion_Type" json:"motion_format,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting) Reset() {
	*x = Targeting{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting) ProtoMessage() {}

func (x *Targeting) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting.ProtoReflect.Descriptor instead.
func (*Targeting) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{4}
}

func (x *Targeting) GetMotionFormat() Motion_Type {
	if x != nil && x.MotionFormat != nil {
		return *x.MotionFormat
	}
	return Motion_MOTION_UNSPECIFIED
}

// An Azimuth-Elevation Mask describes how the horizon looks to a steerable
// antenna or aperature that is fixed on the surface of a planet.  It
// specifies the maximum obscured elevation angle in each sampled direction
// from the stationary object. Note that the definition of an azimuth
// elevation mask does not constrain link accessibility unless the
// minimum_azimuth_elevation_mask_separation_deg constraint is also set.
type AntennaDefinition_ElevationMask struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The azimuth angle in degrees measured from North toward East.
	AzimuthDeg *float64 `protobuf:"fixed64,1,opt,name=azimuth_deg,json=azimuthDeg" json:"azimuth_deg,omitempty"`
	// The maximum obscured elevation angle, in degrees.
	// Set to 90 deg if links in this azimuth direction are always inaccessible.
	// Negative values are also allowed (for antennas above terrain).
	MaximumObscuredElevationDeg *float64                                         `protobuf:"fixed64,2,opt,name=maximum_obscured_elevation_deg,json=maximumObscuredElevationDeg" json:"maximum_obscured_elevation_deg,omitempty"`
	ElevationRise               []*AntennaDefinition_ElevationMask_ElevationRise `protobuf:"bytes,3,rep,name=elevation_rise,json=elevationRise" json:"elevation_rise,omitempty"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *AntennaDefinition_ElevationMask) Reset() {
	*x = AntennaDefinition_ElevationMask{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AntennaDefinition_ElevationMask) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AntennaDefinition_ElevationMask) ProtoMessage() {}

func (x *AntennaDefinition_ElevationMask) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AntennaDefinition_ElevationMask.ProtoReflect.Descriptor instead.
func (*AntennaDefinition_ElevationMask) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{0, 0}
}

func (x *AntennaDefinition_ElevationMask) GetAzimuthDeg() float64 {
	if x != nil && x.AzimuthDeg != nil {
		return *x.AzimuthDeg
	}
	return 0
}

func (x *AntennaDefinition_ElevationMask) GetMaximumObscuredElevationDeg() float64 {
	if x != nil && x.MaximumObscuredElevationDeg != nil {
		return *x.MaximumObscuredElevationDeg
	}
	return 0
}

func (x *AntennaDefinition_ElevationMask) GetElevationRise() []*AntennaDefinition_ElevationMask_ElevationRise {
	if x != nil {
		return x.ElevationRise
	}
	return nil
}

// When needing to describe a richer variation in obscured elevation angle
// along a given azimuth than may be permitted by the "maximum obscured
// elevation angle" alone, a sequence of ElevationRise elements may be used.
// Taken together in order of increasing distance they describe how the
// angle of obscuration changes as a function of distance along the ray
// indicated by the azimuth.
//
// Nonsensical values are silently discarded: negative distances as well as
// elevation angles lower than -90 degrees or higher than 90 degrees.
//
// Additionally, elements may be inserted at distance = 0.0m or appended to
// the end to complete the described curve from the origin point up to the
// above specified maximum_obscured_elevation_deg value.
type AntennaDefinition_ElevationMask_ElevationRise struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Distance from the fixed antenna/aperature to the start of obscuration,
	// in meters. If this field is absent the obscured_elevation_deg is used
	// to create an ElevationRise at 0.0m distance.
	Distance *float64 `protobuf:"fixed64,1,opt,name=distance" json:"distance,omitempty"`
	// The obscured elevation angle, in degrees, at this distance.
	// Negative values are also allowed (for antennas above terrain).
	ObscuredElevationDeg *float64 `protobuf:"fixed64,2,opt,name=obscured_elevation_deg,json=obscuredElevationDeg" json:"obscured_elevation_deg,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *AntennaDefinition_ElevationMask_ElevationRise) Reset() {
	*x = AntennaDefinition_ElevationMask_ElevationRise{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AntennaDefinition_ElevationMask_ElevationRise) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AntennaDefinition_ElevationMask_ElevationRise) ProtoMessage() {}

func (x *AntennaDefinition_ElevationMask_ElevationRise) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AntennaDefinition_ElevationMask_ElevationRise.ProtoReflect.Descriptor instead.
func (*AntennaDefinition_ElevationMask_ElevationRise) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{0, 0, 0}
}

func (x *AntennaDefinition_ElevationMask_ElevationRise) GetDistance() float64 {
	if x != nil && x.Distance != nil {
		return *x.Distance
	}
	return 0
}

func (x *AntennaDefinition_ElevationMask_ElevationRise) GetObscuredElevationDeg() float64 {
	if x != nil && x.ObscuredElevationDeg != nil {
		return *x.ObscuredElevationDeg
	}
	return 0
}

type AntennaConstraints_LinkRangeConstraint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinimumRange  *float64               `protobuf:"fixed64,1,opt,name=minimum_range,json=minimumRange" json:"minimum_range,omitempty"`
	MaximumRange  *float64               `protobuf:"fixed64,2,opt,name=maximum_range,json=maximumRange" json:"maximum_range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AntennaConstraints_LinkRangeConstraint) Reset() {
	*x = AntennaConstraints_LinkRangeConstraint{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AntennaConstraints_LinkRangeConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AntennaConstraints_LinkRangeConstraint) ProtoMessage() {}

func (x *AntennaConstraints_LinkRangeConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AntennaConstraints_LinkRangeConstraint.ProtoReflect.Descriptor instead.
func (*AntennaConstraints_LinkRangeConstraint) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{1, 0}
}

func (x *AntennaConstraints_LinkRangeConstraint) GetMinimumRange() float64 {
	if x != nil && x.MinimumRange != nil {
		return *x.MinimumRange
	}
	return 0
}

func (x *AntennaConstraints_LinkRangeConstraint) GetMaximumRange() float64 {
	if x != nil && x.MaximumRange != nil {
		return *x.MaximumRange
	}
	return 0
}

// AzimuthAngleRateConstraint is relative to the plane tangent to the surface
// of the central body (Earth).  This is appropriate for ground stations or
// other vehicles on the surface of the central body; but, for aerospace
// platforms, it's usually better to use the TotalAngularRateConstraint.
type AntennaConstraints_AzimuthAngleRateConstraint struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	MinimumRateDegPerSec *float64               `protobuf:"fixed64,1,opt,name=minimum_rate_deg_per_sec,json=minimumRateDegPerSec" json:"minimum_rate_deg_per_sec,omitempty"`
	MaximumRateDegPerSec *float64               `protobuf:"fixed64,2,opt,name=maximum_rate_deg_per_sec,json=maximumRateDegPerSec" json:"maximum_rate_deg_per_sec,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *AntennaConstraints_AzimuthAngleRateConstraint) Reset() {
	*x = AntennaConstraints_AzimuthAngleRateConstraint{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AntennaConstraints_AzimuthAngleRateConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AntennaConstraints_AzimuthAngleRateConstraint) ProtoMessage() {}

func (x *AntennaConstraints_AzimuthAngleRateConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AntennaConstraints_AzimuthAngleRateConstraint.ProtoReflect.Descriptor instead.
func (*AntennaConstraints_AzimuthAngleRateConstraint) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{1, 1}
}

func (x *AntennaConstraints_AzimuthAngleRateConstraint) GetMinimumRateDegPerSec() float64 {
	if x != nil && x.MinimumRateDegPerSec != nil {
		return *x.MinimumRateDegPerSec
	}
	return 0
}

func (x *AntennaConstraints_AzimuthAngleRateConstraint) GetMaximumRateDegPerSec() float64 {
	if x != nil && x.MaximumRateDegPerSec != nil {
		return *x.MaximumRateDegPerSec
	}
	return 0
}

type AntennaConstraints_ElevationAngleRateConstraint struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	MinimumRateDegPerSec *float64               `protobuf:"fixed64,1,opt,name=minimum_rate_deg_per_sec,json=minimumRateDegPerSec" json:"minimum_rate_deg_per_sec,omitempty"`
	MaximumRateDegPerSec *float64               `protobuf:"fixed64,2,opt,name=maximum_rate_deg_per_sec,json=maximumRateDegPerSec" json:"maximum_rate_deg_per_sec,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *AntennaConstraints_ElevationAngleRateConstraint) Reset() {
	*x = AntennaConstraints_ElevationAngleRateConstraint{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AntennaConstraints_ElevationAngleRateConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AntennaConstraints_ElevationAngleRateConstraint) ProtoMessage() {}

func (x *AntennaConstraints_ElevationAngleRateConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AntennaConstraints_ElevationAngleRateConstraint.ProtoReflect.Descriptor instead.
func (*AntennaConstraints_ElevationAngleRateConstraint) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{1, 2}
}

func (x *AntennaConstraints_ElevationAngleRateConstraint) GetMinimumRateDegPerSec() float64 {
	if x != nil && x.MinimumRateDegPerSec != nil {
		return *x.MinimumRateDegPerSec
	}
	return 0
}

func (x *AntennaConstraints_ElevationAngleRateConstraint) GetMaximumRateDegPerSec() float64 {
	if x != nil && x.MaximumRateDegPerSec != nil {
		return *x.MaximumRateDegPerSec
	}
	return 0
}

type AntennaConstraints_TotalAngularRateConstraint struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	MinimumRateDegPerSec *float64               `protobuf:"fixed64,1,opt,name=minimum_rate_deg_per_sec,json=minimumRateDegPerSec" json:"minimum_rate_deg_per_sec,omitempty"`
	MaximumRateDegPerSec *float64               `protobuf:"fixed64,2,opt,name=maximum_rate_deg_per_sec,json=maximumRateDegPerSec" json:"maximum_rate_deg_per_sec,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *AntennaConstraints_TotalAngularRateConstraint) Reset() {
	*x = AntennaConstraints_TotalAngularRateConstraint{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AntennaConstraints_TotalAngularRateConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AntennaConstraints_TotalAngularRateConstraint) ProtoMessage() {}

func (x *AntennaConstraints_TotalAngularRateConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AntennaConstraints_TotalAngularRateConstraint.ProtoReflect.Descriptor instead.
func (*AntennaConstraints_TotalAngularRateConstraint) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{1, 3}
}

func (x *AntennaConstraints_TotalAngularRateConstraint) GetMinimumRateDegPerSec() float64 {
	if x != nil && x.MinimumRateDegPerSec != nil {
		return *x.MinimumRateDegPerSec
	}
	return 0
}

func (x *AntennaConstraints_TotalAngularRateConstraint) GetMaximumRateDegPerSec() float64 {
	if x != nil && x.MaximumRateDegPerSec != nil {
		return *x.MaximumRateDegPerSec
	}
	return 0
}

// Defines a conical projection.
type Projection_Conic struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Angle between the positive Z-axis and the external boundary of the
	// volume. If omitted, the volume is a sphere less any interior exclusion.
	OuterHalfAngleDeg *float64 `protobuf:"fixed64,1,opt,name=outer_half_angle_deg,json=outerHalfAngleDeg" json:"outer_half_angle_deg,omitempty"`
	// Angle between the positive Z-axis and an optional, interior conical
	// volume of exclusion. Used to optionally restrict the volume.
	InnerHalfAngleDeg *float64 `protobuf:"fixed64,2,opt,name=inner_half_angle_deg,json=innerHalfAngleDeg" json:"inner_half_angle_deg,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Projection_Conic) Reset() {
	*x = Projection_Conic{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Projection_Conic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Projection_Conic) ProtoMessage() {}

func (x *Projection_Conic) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Projection_Conic.ProtoReflect.Descriptor instead.
func (*Projection_Conic) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{2, 0}
}

func (x *Projection_Conic) GetOuterHalfAngleDeg() float64 {
	if x != nil && x.OuterHalfAngleDeg != nil {
		return *x.OuterHalfAngleDeg
	}
	return 0
}

func (x *Projection_Conic) GetInnerHalfAngleDeg() float64 {
	if x != nil && x.InnerHalfAngleDeg != nil {
		return *x.InnerHalfAngleDeg
	}
	return 0
}

// Defines a rectangular projection
type Projection_Rectangular struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Measured from the principal direction and in the direction of the X-axis.
	XHalfAngleDeg *float64 `protobuf:"fixed64,1,opt,name=x_half_angle_deg,json=xHalfAngleDeg" json:"x_half_angle_deg,omitempty"`
	// Measured from the principal direction and in the direction of the Y-axis.
	YHalfAngleDeg *float64 `protobuf:"fixed64,2,opt,name=y_half_angle_deg,json=yHalfAngleDeg" json:"y_half_angle_deg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Projection_Rectangular) Reset() {
	*x = Projection_Rectangular{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Projection_Rectangular) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Projection_Rectangular) ProtoMessage() {}

func (x *Projection_Rectangular) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Projection_Rectangular.ProtoReflect.Descriptor instead.
func (*Projection_Rectangular) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{2, 1}
}

func (x *Projection_Rectangular) GetXHalfAngleDeg() float64 {
	if x != nil && x.XHalfAngleDeg != nil {
		return *x.XHalfAngleDeg
	}
	return 0
}

func (x *Projection_Rectangular) GetYHalfAngleDeg() float64 {
	if x != nil && x.YHalfAngleDeg != nil {
		return *x.YHalfAngleDeg
	}
	return 0
}

// Defines a custom projection.
type Projection_Custom struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of directions defining the outer perimeter of the projection.
	// Azimuth is the angle in the XY plane measured from the positive X-axis
	// towards the positive Y-axes. Elevation is measured from the XY-plane
	// and toward the negative z-axis.
	Directions    []*PointingVector `protobuf:"bytes,1,rep,name=directions" json:"directions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Projection_Custom) Reset() {
	*x = Projection_Custom{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Projection_Custom) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Projection_Custom) ProtoMessage() {}

func (x *Projection_Custom) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Projection_Custom.ProtoReflect.Descriptor instead.
func (*Projection_Custom) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{2, 2}
}

func (x *Projection_Custom) GetDirections() []*PointingVector {
	if x != nil {
		return x.Directions
	}
	return nil
}

// Constant polarization over time.
type Polarization_Constant struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Polarization:
	//
	//	*Polarization_Constant_LeftHandCircular
	//	*Polarization_Constant_RightHandCircular
	//	*Polarization_Constant_Linear_
	Polarization  isPolarization_Constant_Polarization `protobuf_oneof:"polarization"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Polarization_Constant) Reset() {
	*x = Polarization_Constant{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Polarization_Constant) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Polarization_Constant) ProtoMessage() {}

func (x *Polarization_Constant) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Polarization_Constant.ProtoReflect.Descriptor instead.
func (*Polarization_Constant) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{3, 0}
}

func (x *Polarization_Constant) GetPolarization() isPolarization_Constant_Polarization {
	if x != nil {
		return x.Polarization
	}
	return nil
}

func (x *Polarization_Constant) GetLeftHandCircular() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Polarization.(*Polarization_Constant_LeftHandCircular); ok {
			return x.LeftHandCircular
		}
	}
	return nil
}

func (x *Polarization_Constant) GetRightHandCircular() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Polarization.(*Polarization_Constant_RightHandCircular); ok {
			return x.RightHandCircular
		}
	}
	return nil
}

func (x *Polarization_Constant) GetLinear() *Polarization_Constant_Linear {
	if x != nil {
		if x, ok := x.Polarization.(*Polarization_Constant_Linear_); ok {
			return x.Linear
		}
	}
	return nil
}

type isPolarization_Constant_Polarization interface {
	isPolarization_Constant_Polarization()
}

type Polarization_Constant_LeftHandCircular struct {
	LeftHandCircular *emptypb.Empty `protobuf:"bytes,1,opt,name=left_hand_circular,json=leftHandCircular,oneof"`
}

type Polarization_Constant_RightHandCircular struct {
	RightHandCircular *emptypb.Empty `protobuf:"bytes,2,opt,name=right_hand_circular,json=rightHandCircular,oneof"`
}

type Polarization_Constant_Linear_ struct {
	Linear *Polarization_Constant_Linear `protobuf:"bytes,3,opt,name=linear,oneof"`
}

func (*Polarization_Constant_LeftHandCircular) isPolarization_Constant_Polarization() {}

func (*Polarization_Constant_RightHandCircular) isPolarization_Constant_Polarization() {}

func (*Polarization_Constant_Linear_) isPolarization_Constant_Polarization() {}

type Polarization_Constant_Linear struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The tilt angle, in degrees, relative to the X axis.
	TiltAngleDeg  *float64 `protobuf:"fixed64,1,opt,name=tilt_angle_deg,json=tiltAngleDeg" json:"tilt_angle_deg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Polarization_Constant_Linear) Reset() {
	*x = Polarization_Constant_Linear{}
	mi := &file_api_common_platform_antenna_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Polarization_Constant_Linear) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Polarization_Constant_Linear) ProtoMessage() {}

func (x *Polarization_Constant_Linear) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_platform_antenna_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Polarization_Constant_Linear.ProtoReflect.Descriptor instead.
func (*Polarization_Constant_Linear) Descriptor() ([]byte, []int) {
	return file_api_common_platform_antenna_proto_rawDescGZIP(), []int{3, 0, 0}
}

func (x *Polarization_Constant_Linear) GetTiltAngleDeg() float64 {
	if x != nil && x.TiltAngleDeg != nil {
		return *x.TiltAngleDeg
	}
	return 0
}

var File_api_common_platform_antenna_proto protoreflect.FileDescriptor

const file_api_common_platform_antenna_proto_rawDesc = "" +
	"\n" +
	"!api/common/platform_antenna.proto\x12\x1caalyria.spacetime.api.common\x1a\x1capi/common/coordinates.proto\x1a\x1bgoogle/protobuf/empty.proto\"\xad\b\n" +
	"\x11AntennaDefinition\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12_\n" +
	"\x17fixed_coordinate_offset\x18\x03 \x01(\v2'.aalyria.spacetime.api.common.PointAxesR\x15fixedCoordinateOffset\x12E\n" +
	"\ttargeting\x18\x12 \x01(\v2'.aalyria.spacetime.api.common.TargetingR\ttargeting\x12,\n" +
	"\x12antenna_pattern_id\x18\n" +
	" \x01(\tR\x10antennaPatternId\x12N\n" +
	"\fpolarization\x18\x11 \x01(\v2*.aalyria.spacetime.api.common.PolarizationR\fpolarization\x12P\n" +
	"\x0ffield_of_regard\x18\v \x01(\v2(.aalyria.spacetime.api.common.ProjectionR\rfieldOfRegard\x12L\n" +
	"\fobstructions\x18\f \x03(\v2(.aalyria.spacetime.api.common.ProjectionR\fobstructions\x12s\n" +
	"\x16azimuth_elevation_mask\x18\t \x03(\v2=.aalyria.spacetime.api.common.AntennaDefinition.ElevationMaskR\x14azimuthElevationMask\x12R\n" +
	"\vconstraints\x18\x06 \x01(\v20.aalyria.spacetime.api.common.AntennaConstraintsR\vconstraints\x1a\xcc\x02\n" +
	"\rElevationMask\x12\x1f\n" +
	"\vazimuth_deg\x18\x01 \x01(\x01R\n" +
	"azimuthDeg\x12C\n" +
	"\x1emaximum_obscured_elevation_deg\x18\x02 \x01(\x01R\x1bmaximumObscuredElevationDeg\x12r\n" +
	"\x0eelevation_rise\x18\x03 \x03(\v2K.aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRiseR\relevationRise\x1aa\n" +
	"\rElevationRise\x12\x1a\n" +
	"\bdistance\x18\x01 \x01(\x01R\bdistance\x124\n" +
	"\x16obscured_elevation_deg\x18\x02 \x01(\x01R\x14obscuredElevationDegJ\x04\b\x01\x10\x02J\x04\b\x04\x10\x05J\x04\b\x05\x10\x06J\x04\b\a\x10\bJ\x04\b\b\x10\tJ\b\b\x13\x10\x80\x80\x80\x80\x02\"\x9e\t\n" +
	"\x12AntennaConstraints\x12c\n" +
	"\n" +
	"link_range\x18\x01 \x01(\v2D.aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraintR\tlinkRange\x12y\n" +
	"\x12azimuth_angle_rate\x18\x03 \x01(\v2K.aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraintR\x10azimuthAngleRate\x12\x7f\n" +
	"\x14elevation_angle_rate\x18\x04 \x01(\v2M.aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraintR\x12elevationAngleRate\x12y\n" +
	"\x12total_angular_rate\x18\x05 \x01(\v2K.aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraintR\x10totalAngularRate\x121\n" +
	"\x15minimum_sun_angle_deg\x18\x06 \x01(\x01R\x12minimumSunAngleDeg\x12_\n" +
	"-minimum_azimuth_elevation_mask_separation_deg\x18\a \x01(\x01R(minimumAzimuthElevationMaskSeparationDeg\x1a_\n" +
	"\x13LinkRangeConstraint\x12#\n" +
	"\rminimum_range\x18\x01 \x01(\x01R\fminimumRange\x12#\n" +
	"\rmaximum_range\x18\x02 \x01(\x01R\fmaximumRange\x1a\x8c\x01\n" +
	"\x1aAzimuthAngleRateConstraint\x126\n" +
	"\x18minimum_rate_deg_per_sec\x18\x01 \x01(\x01R\x14minimumRateDegPerSec\x126\n" +
	"\x18maximum_rate_deg_per_sec\x18\x02 \x01(\x01R\x14maximumRateDegPerSec\x1a\x8e\x01\n" +
	"\x1cElevationAngleRateConstraint\x126\n" +
	"\x18minimum_rate_deg_per_sec\x18\x01 \x01(\x01R\x14minimumRateDegPerSec\x126\n" +
	"\x18maximum_rate_deg_per_sec\x18\x02 \x01(\x01R\x14maximumRateDegPerSec\x1a\x8c\x01\n" +
	"\x1aTotalAngularRateConstraint\x126\n" +
	"\x18minimum_rate_deg_per_sec\x18\x01 \x01(\x01R\x14minimumRateDegPerSec\x126\n" +
	"\x18maximum_rate_deg_per_sec\x18\x02 \x01(\x01R\x14maximumRateDegPerSecJ\b\b\b\x10\x80\x80\x80\x80\x02\"\xab\x04\n" +
	"\n" +
	"Projection\x12F\n" +
	"\x05conic\x18\x01 \x01(\v2..aalyria.spacetime.api.common.Projection.ConicH\x00R\x05conic\x12X\n" +
	"\vrectangular\x18\x02 \x01(\v24.aalyria.spacetime.api.common.Projection.RectangularH\x00R\vrectangular\x12I\n" +
	"\x06custom\x18\x03 \x01(\v2/.aalyria.spacetime.api.common.Projection.CustomH\x00R\x06custom\x1ai\n" +
	"\x05Conic\x12/\n" +
	"\x14outer_half_angle_deg\x18\x01 \x01(\x01R\x11outerHalfAngleDeg\x12/\n" +
	"\x14inner_half_angle_deg\x18\x02 \x01(\x01R\x11innerHalfAngleDeg\x1a_\n" +
	"\vRectangular\x12'\n" +
	"\x10x_half_angle_deg\x18\x01 \x01(\x01R\rxHalfAngleDeg\x12'\n" +
	"\x10y_half_angle_deg\x18\x02 \x01(\x01R\ryHalfAngleDeg\x1aV\n" +
	"\x06Custom\x12L\n" +
	"\n" +
	"directions\x18\x01 \x03(\v2,.aalyria.spacetime.api.common.PointingVectorR\n" +
	"directionsB\f\n" +
	"\n" +
	"shape_type\"\xa0\x03\n" +
	"\fPolarization\x12Q\n" +
	"\bconstant\x18\x01 \x01(\v23.aalyria.spacetime.api.common.Polarization.ConstantH\x00R\bconstant\x1a\xb2\x02\n" +
	"\bConstant\x12F\n" +
	"\x12left_hand_circular\x18\x01 \x01(\v2\x16.google.protobuf.EmptyH\x00R\x10leftHandCircular\x12H\n" +
	"\x13right_hand_circular\x18\x02 \x01(\v2\x16.google.protobuf.EmptyH\x00R\x11rightHandCircular\x12T\n" +
	"\x06linear\x18\x03 \x01(\v2:.aalyria.spacetime.api.common.Polarization.Constant.LinearH\x00R\x06linear\x1a.\n" +
	"\x06Linear\x12$\n" +
	"\x0etilt_angle_deg\x18\x01 \x01(\x01R\ftiltAngleDegB\x0e\n" +
	"\fpolarizationB\b\n" +
	"\x06source\"[\n" +
	"\tTargeting\x12N\n" +
	"\rmotion_format\x18\x01 \x01(\x0e2).aalyria.spacetime.api.common.Motion.TypeR\fmotionFormatBD\n" +
	" com.aalyria.spacetime.api.commonZ aalyria.com/spacetime/api/common"

var (
	file_api_common_platform_antenna_proto_rawDescOnce sync.Once
	file_api_common_platform_antenna_proto_rawDescData []byte
)

func file_api_common_platform_antenna_proto_rawDescGZIP() []byte {
	file_api_common_platform_antenna_proto_rawDescOnce.Do(func() {
		file_api_common_platform_antenna_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_common_platform_antenna_proto_rawDesc), len(file_api_common_platform_antenna_proto_rawDesc)))
	})
	return file_api_common_platform_antenna_proto_rawDescData
}

var file_api_common_platform_antenna_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_api_common_platform_antenna_proto_goTypes = []any{
	(*AntennaDefinition)(nil),                               // 0: aalyria.spacetime.api.common.AntennaDefinition
	(*AntennaConstraints)(nil),                              // 1: aalyria.spacetime.api.common.AntennaConstraints
	(*Projection)(nil),                                      // 2: aalyria.spacetime.api.common.Projection
	(*Polarization)(nil),                                    // 3: aalyria.spacetime.api.common.Polarization
	(*Targeting)(nil),                                       // 4: aalyria.spacetime.api.common.Targeting
	(*AntennaDefinition_ElevationMask)(nil),                 // 5: aalyria.spacetime.api.common.AntennaDefinition.ElevationMask
	(*AntennaDefinition_ElevationMask_ElevationRise)(nil),   // 6: aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise
	(*AntennaConstraints_LinkRangeConstraint)(nil),          // 7: aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint
	(*AntennaConstraints_AzimuthAngleRateConstraint)(nil),   // 8: aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint
	(*AntennaConstraints_ElevationAngleRateConstraint)(nil), // 9: aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint
	(*AntennaConstraints_TotalAngularRateConstraint)(nil),   // 10: aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint
	(*Projection_Conic)(nil),                                // 11: aalyria.spacetime.api.common.Projection.Conic
	(*Projection_Rectangular)(nil),                          // 12: aalyria.spacetime.api.common.Projection.Rectangular
	(*Projection_Custom)(nil),                               // 13: aalyria.spacetime.api.common.Projection.Custom
	(*Polarization_Constant)(nil),                           // 14: aalyria.spacetime.api.common.Polarization.Constant
	(*Polarization_Constant_Linear)(nil),                    // 15: aalyria.spacetime.api.common.Polarization.Constant.Linear
	(*PointAxes)(nil),                                       // 16: aalyria.spacetime.api.common.PointAxes
	(Motion_Type)(0),                                        // 17: aalyria.spacetime.api.common.Motion.Type
	(*PointingVector)(nil),                                  // 18: aalyria.spacetime.api.common.PointingVector
	(*emptypb.Empty)(nil),                                   // 19: google.protobuf.Empty
}
var file_api_common_platform_antenna_proto_depIdxs = []int32{
	16, // 0: aalyria.spacetime.api.common.AntennaDefinition.fixed_coordinate_offset:type_name -> aalyria.spacetime.api.common.PointAxes
	4,  // 1: aalyria.spacetime.api.common.AntennaDefinition.targeting:type_name -> aalyria.spacetime.api.common.Targeting
	3,  // 2: aalyria.spacetime.api.common.AntennaDefinition.polarization:type_name -> aalyria.spacetime.api.common.Polarization
	2,  // 3: aalyria.spacetime.api.common.AntennaDefinition.field_of_regard:type_name -> aalyria.spacetime.api.common.Projection
	2,  // 4: aalyria.spacetime.api.common.AntennaDefinition.obstructions:type_name -> aalyria.spacetime.api.common.Projection
	5,  // 5: aalyria.spacetime.api.common.AntennaDefinition.azimuth_elevation_mask:type_name -> aalyria.spacetime.api.common.AntennaDefinition.ElevationMask
	1,  // 6: aalyria.spacetime.api.common.AntennaDefinition.constraints:type_name -> aalyria.spacetime.api.common.AntennaConstraints
	7,  // 7: aalyria.spacetime.api.common.AntennaConstraints.link_range:type_name -> aalyria.spacetime.api.common.AntennaConstraints.LinkRangeConstraint
	8,  // 8: aalyria.spacetime.api.common.AntennaConstraints.azimuth_angle_rate:type_name -> aalyria.spacetime.api.common.AntennaConstraints.AzimuthAngleRateConstraint
	9,  // 9: aalyria.spacetime.api.common.AntennaConstraints.elevation_angle_rate:type_name -> aalyria.spacetime.api.common.AntennaConstraints.ElevationAngleRateConstraint
	10, // 10: aalyria.spacetime.api.common.AntennaConstraints.total_angular_rate:type_name -> aalyria.spacetime.api.common.AntennaConstraints.TotalAngularRateConstraint
	11, // 11: aalyria.spacetime.api.common.Projection.conic:type_name -> aalyria.spacetime.api.common.Projection.Conic
	12, // 12: aalyria.spacetime.api.common.Projection.rectangular:type_name -> aalyria.spacetime.api.common.Projection.Rectangular
	13, // 13: aalyria.spacetime.api.common.Projection.custom:type_name -> aalyria.spacetime.api.common.Projection.Custom
	14, // 14: aalyria.spacetime.api.common.Polarization.constant:type_name -> aalyria.spacetime.api.common.Polarization.Constant
	17, // 15: aalyria.spacetime.api.common.Targeting.motion_format:type_name -> aalyria.spacetime.api.common.Motion.Type
	6,  // 16: aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.elevation_rise:type_name -> aalyria.spacetime.api.common.AntennaDefinition.ElevationMask.ElevationRise
	18, // 17: aalyria.spacetime.api.common.Projection.Custom.directions:type_name -> aalyria.spacetime.api.common.PointingVector
	19, // 18: aalyria.spacetime.api.common.Polarization.Constant.left_hand_circular:type_name -> google.protobuf.Empty
	19, // 19: aalyria.spacetime.api.common.Polarization.Constant.right_hand_circular:type_name -> google.protobuf.Empty
	15, // 20: aalyria.spacetime.api.common.Polarization.Constant.linear:type_name -> aalyria.spacetime.api.common.Polarization.Constant.Linear
	21, // [21:21] is the sub-list for method output_type
	21, // [21:21] is the sub-list for method input_type
	21, // [21:21] is the sub-list for extension type_name
	21, // [21:21] is the sub-list for extension extendee
	0,  // [0:21] is the sub-list for field type_name
}

func init() { file_api_common_platform_antenna_proto_init() }
func file_api_common_platform_antenna_proto_init() {
	if File_api_common_platform_antenna_proto != nil {
		return
	}
	file_api_common_coordinates_proto_init()
	file_api_common_platform_antenna_proto_msgTypes[2].OneofWrappers = []any{
		(*Projection_Conic_)(nil),
		(*Projection_Rectangular_)(nil),
		(*Projection_Custom_)(nil),
	}
	file_api_common_platform_antenna_proto_msgTypes[3].OneofWrappers = []any{
		(*Polarization_Constant_)(nil),
	}
	file_api_common_platform_antenna_proto_msgTypes[14].OneofWrappers = []any{
		(*Polarization_Constant_LeftHandCircular)(nil),
		(*Polarization_Constant_RightHandCircular)(nil),
		(*Polarization_Constant_Linear_)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_common_platform_antenna_proto_rawDesc), len(file_api_common_platform_antenna_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_api_common_platform_antenna_proto_goTypes,
		DependencyIndexes: file_api_common_platform_antenna_proto_depIdxs,
		MessageInfos:      file_api_common_platform_antenna_proto_msgTypes,
	}.Build()
	File_api_common_platform_antenna_proto = out.File
	file_api_common_platform_antenna_proto_goTypes = nil
	file_api_common_platform_antenna_proto_depIdxs = nil
}
