// Copyright 2023 Aalyria Technologies, Inc., and its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: api/common/telemetry.proto

package common

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type BeamStats_TargetingStats_ConnectionStatus int32

const (
	BeamStats_TargetingStats_UNKNOWN BeamStats_TargetingStats_ConnectionStatus = 0
	BeamStats_TargetingStats_SEEKING BeamStats_TargetingStats_ConnectionStatus = 1
	BeamStats_TargetingStats_LOCKED  BeamStats_TargetingStats_ConnectionStatus = 2
)

// Enum value maps for BeamStats_TargetingStats_ConnectionStatus.
var (
	BeamStats_TargetingStats_ConnectionStatus_name = map[int32]string{
		0: "UNKNOWN",
		1: "SEEKING",
		2: "LOCKED",
	}
	BeamStats_TargetingStats_ConnectionStatus_value = map[string]int32{
		"UNKNOWN": 0,
		"SEEKING": 1,
		"LOCKED":  2,
	}
)

func (x BeamStats_TargetingStats_ConnectionStatus) Enum() *BeamStats_TargetingStats_ConnectionStatus {
	p := new(BeamStats_TargetingStats_ConnectionStatus)
	*p = x
	return p
}

func (x BeamStats_TargetingStats_ConnectionStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BeamStats_TargetingStats_ConnectionStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_telemetry_proto_enumTypes[0].Descriptor()
}

func (BeamStats_TargetingStats_ConnectionStatus) Type() protoreflect.EnumType {
	return &file_api_common_telemetry_proto_enumTypes[0]
}

func (x BeamStats_TargetingStats_ConnectionStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *BeamStats_TargetingStats_ConnectionStatus) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = BeamStats_TargetingStats_ConnectionStatus(num)
	return nil
}

// Deprecated: Use BeamStats_TargetingStats_ConnectionStatus.Descriptor instead.
func (BeamStats_TargetingStats_ConnectionStatus) EnumDescriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{1, 0, 0}
}

type RadioEvent_LinkStatus int32

const (
	RadioEvent_UNKNOWN RadioEvent_LinkStatus = 0
	RadioEvent_DOWN    RadioEvent_LinkStatus = 1
	RadioEvent_UP      RadioEvent_LinkStatus = 2
)

// Enum value maps for RadioEvent_LinkStatus.
var (
	RadioEvent_LinkStatus_name = map[int32]string{
		0: "UNKNOWN",
		1: "DOWN",
		2: "UP",
	}
	RadioEvent_LinkStatus_value = map[string]int32{
		"UNKNOWN": 0,
		"DOWN":    1,
		"UP":      2,
	}
)

func (x RadioEvent_LinkStatus) Enum() *RadioEvent_LinkStatus {
	p := new(RadioEvent_LinkStatus)
	*p = x
	return p
}

func (x RadioEvent_LinkStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RadioEvent_LinkStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_telemetry_proto_enumTypes[1].Descriptor()
}

func (RadioEvent_LinkStatus) Type() protoreflect.EnumType {
	return &file_api_common_telemetry_proto_enumTypes[1]
}

func (x RadioEvent_LinkStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *RadioEvent_LinkStatus) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = RadioEvent_LinkStatus(num)
	return nil
}

// Deprecated: Use RadioEvent_LinkStatus.Descriptor instead.
func (RadioEvent_LinkStatus) EnumDescriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{8, 0}
}

type PortEvent_PortStatus int32

const (
	PortEvent_UNKNOWN PortEvent_PortStatus = 0
	PortEvent_DOWN    PortEvent_PortStatus = 1
	PortEvent_UP      PortEvent_PortStatus = 2
)

// Enum value maps for PortEvent_PortStatus.
var (
	PortEvent_PortStatus_name = map[int32]string{
		0: "UNKNOWN",
		1: "DOWN",
		2: "UP",
	}
	PortEvent_PortStatus_value = map[string]int32{
		"UNKNOWN": 0,
		"DOWN":    1,
		"UP":      2,
	}
)

func (x PortEvent_PortStatus) Enum() *PortEvent_PortStatus {
	p := new(PortEvent_PortStatus)
	*p = x
	return p
}

func (x PortEvent_PortStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PortEvent_PortStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_telemetry_proto_enumTypes[2].Descriptor()
}

func (PortEvent_PortStatus) Type() protoreflect.EnumType {
	return &file_api_common_telemetry_proto_enumTypes[2]
}

func (x PortEvent_PortStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *PortEvent_PortStatus) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = PortEvent_PortStatus(num)
	return nil
}

// Deprecated: Use PortEvent_PortStatus.Descriptor instead.
func (PortEvent_PortStatus) EnumDescriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{9, 0}
}

type InterfaceEvent_InterfaceStatus int32

const (
	InterfaceEvent_UNKNOWN  InterfaceEvent_InterfaceStatus = 0
	InterfaceEvent_DISABLED InterfaceEvent_InterfaceStatus = 1
	InterfaceEvent_ENABLED  InterfaceEvent_InterfaceStatus = 2
)

// Enum value maps for InterfaceEvent_InterfaceStatus.
var (
	InterfaceEvent_InterfaceStatus_name = map[int32]string{
		0: "UNKNOWN",
		1: "DISABLED",
		2: "ENABLED",
	}
	InterfaceEvent_InterfaceStatus_value = map[string]int32{
		"UNKNOWN":  0,
		"DISABLED": 1,
		"ENABLED":  2,
	}
)

func (x InterfaceEvent_InterfaceStatus) Enum() *InterfaceEvent_InterfaceStatus {
	p := new(InterfaceEvent_InterfaceStatus)
	*p = x
	return p
}

func (x InterfaceEvent_InterfaceStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InterfaceEvent_InterfaceStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_api_common_telemetry_proto_enumTypes[3].Descriptor()
}

func (InterfaceEvent_InterfaceStatus) Type() protoreflect.EnumType {
	return &file_api_common_telemetry_proto_enumTypes[3]
}

func (x InterfaceEvent_InterfaceStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *InterfaceEvent_InterfaceStatus) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = InterfaceEvent_InterfaceStatus(num)
	return nil
}

// Deprecated: Use InterfaceEvent_InterfaceStatus.Descriptor instead.
func (InterfaceEvent_InterfaceStatus) EnumDescriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{10, 0}
}

type NetworkStatsReport struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Uniquely identifies the network node/element.
	NodeId *string `protobuf:"bytes,7,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// Time at which the report was sent. This field is optional.
	Timestamp *DateTime `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// These maps are keyed on the network interface ID.
	RadioStatsByInterfaceId map[string]*RadioStats     `protobuf:"bytes,4,rep,name=radio_stats_by_interface_id,json=radioStatsByInterfaceId" json:"radio_stats_by_interface_id,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	InterfaceStatsById      map[string]*InterfaceStats `protobuf:"bytes,3,rep,name=interface_stats_by_id,json=interfaceStatsById" json:"interface_stats_by_id,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// This map is keyed on the antenna ID.
	BeamStatsByAntennaId map[string]*BeamStats `protobuf:"bytes,5,rep,name=beam_stats_by_antenna_id,json=beamStatsByAntennaId" json:"beam_stats_by_antenna_id,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Producers: use the flow_rule_id as the key in this map.
	// Consumers: assume that the key is the PathIntent ID.
	// The SDN controller is responsible for remapping the key before publishing.
	FlowStatsById map[string]*FlowStats `protobuf:"bytes,6,rep,name=flow_stats_by_id,json=flowStatsById" json:"flow_stats_by_id,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkStatsReport) Reset() {
	*x = NetworkStatsReport{}
	mi := &file_api_common_telemetry_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkStatsReport) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkStatsReport) ProtoMessage() {}

func (x *NetworkStatsReport) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkStatsReport.ProtoReflect.Descriptor instead.
func (*NetworkStatsReport) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{0}
}

func (x *NetworkStatsReport) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *NetworkStatsReport) GetTimestamp() *DateTime {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *NetworkStatsReport) GetRadioStatsByInterfaceId() map[string]*RadioStats {
	if x != nil {
		return x.RadioStatsByInterfaceId
	}
	return nil
}

func (x *NetworkStatsReport) GetInterfaceStatsById() map[string]*InterfaceStats {
	if x != nil {
		return x.InterfaceStatsById
	}
	return nil
}

func (x *NetworkStatsReport) GetBeamStatsByAntennaId() map[string]*BeamStats {
	if x != nil {
		return x.BeamStatsByAntennaId
	}
	return nil
}

func (x *NetworkStatsReport) GetFlowStatsById() map[string]*FlowStats {
	if x != nil {
		return x.FlowStatsById
	}
	return nil
}

type BeamStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time at which the statistics were captured by the network element.
	Timestamp *DateTime `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// Information about the current target. If no current target exists, leave
	// this blank.
	Targeting *BeamStats_TargetingStats `protobuf:"bytes,2,opt,name=targeting" json:"targeting,omitempty"`
	// Information about the gimbal. If the beam is not gimbaled, leave this
	// blank.
	Gimbal        *BeamStats_GimbalStats `protobuf:"bytes,3,opt,name=gimbal" json:"gimbal,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BeamStats) Reset() {
	*x = BeamStats{}
	mi := &file_api_common_telemetry_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BeamStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BeamStats) ProtoMessage() {}

func (x *BeamStats) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BeamStats.ProtoReflect.Descriptor instead.
func (*BeamStats) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{1}
}

func (x *BeamStats) GetTimestamp() *DateTime {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *BeamStats) GetTargeting() *BeamStats_TargetingStats {
	if x != nil {
		return x.Targeting
	}
	return nil
}

func (x *BeamStats) GetGimbal() *BeamStats_GimbalStats {
	if x != nil {
		return x.Gimbal
	}
	return nil
}

// Measured statistics obtained from a transmitter.
type TransmitterStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time at which the statistics were captured by the network element.
	Timestamp *DateTime `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
	// Optionally specifies the physical address of the receiver.
	// This is only applicable for radios that employ a MAC protocol, like WiFi.
	ReceiverPhysicalAddress *string `protobuf:"bytes,5,opt,name=receiver_physical_address,json=receiverPhysicalAddress" json:"receiver_physical_address,omitempty"`
	// The physical-layer data rate in use by the transmitter, in bits per
	// second. This may vary dynamically based on an adaptive coding and
	// modulation scheme.
	DataRateBps *float64 `protobuf:"fixed64,2,opt,name=data_rate_bps,json=dataRateBps" json:"data_rate_bps,omitempty"`
	// The transmit packet error rate averaged over the last 5 seconds.
	// This is a ratio of number of packets that did not receive positive
	// acknowledgement from the receiver, to the total number of packets
	// transmitted.
	TxPacketErrorRate *float64 `protobuf:"fixed64,3,opt,name=tx_packet_error_rate,json=txPacketErrorRate" json:"tx_packet_error_rate,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *TransmitterStats) Reset() {
	*x = TransmitterStats{}
	mi := &file_api_common_telemetry_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TransmitterStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TransmitterStats) ProtoMessage() {}

func (x *TransmitterStats) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TransmitterStats.ProtoReflect.Descriptor instead.
func (*TransmitterStats) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{2}
}

func (x *TransmitterStats) GetTimestamp() *DateTime {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *TransmitterStats) GetReceiverPhysicalAddress() string {
	if x != nil && x.ReceiverPhysicalAddress != nil {
		return *x.ReceiverPhysicalAddress
	}
	return ""
}

func (x *TransmitterStats) GetDataRateBps() float64 {
	if x != nil && x.DataRateBps != nil {
		return *x.DataRateBps
	}
	return 0
}

func (x *TransmitterStats) GetTxPacketErrorRate() float64 {
	if x != nil && x.TxPacketErrorRate != nil {
		return *x.TxPacketErrorRate
	}
	return 0
}

// Measured statistics obtained from a receiver.
type ReceiverStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time at which the statistics were captured by the network element.
	Timestamp *DateTime `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp,omitempty"`
	// Optionally specifies the physical address of the transmitter.
	// This is only applicable for radios that employ a MAC protocol, like WiFi.
	TransmitterPhysicalAddress *string `protobuf:"bytes,4,opt,name=transmitter_physical_address,json=transmitterPhysicalAddress" json:"transmitter_physical_address,omitempty"`
	// The power, in dBW, of the signal at the output of the receiver, prior to
	// demodulating the signal into data. This includes the effects of the
	// receiving antenna gain, signal filter, and/or amplifier.
	PowerAtReceiverOutputDbw *float64 `protobuf:"fixed64,2,opt,name=power_at_receiver_output_dbw,json=powerAtReceiverOutputDbw" json:"power_at_receiver_output_dbw,omitempty"`
	// Similar to power_at_receiver_output_dbw, but broken down by chain.
	// The order of elements in this field should be consistent with the
	// canonical ordering of the chains.
	PowerAtReceiverOutputByChainDbw []float64 `protobuf:"fixed64,5,rep,name=power_at_receiver_output_by_chain_dbw,json=powerAtReceiverOutputByChainDbw" json:"power_at_receiver_output_by_chain_dbw,omitempty"`
	// The mean squared error, in dB, of the signal processed by the receiver.
	MseDb *float64 `protobuf:"fixed64,6,opt,name=mse_db,json=mseDb" json:"mse_db,omitempty"`
	// The carrier to noise plus interference ratio (CINR), in dB, measured
	// by the receiver.
	CarrierToNoisePlusInterferenceDb *float64 `protobuf:"fixed64,7,opt,name=carrier_to_noise_plus_interference_db,json=carrierToNoisePlusInterferenceDb" json:"carrier_to_noise_plus_interference_db,omitempty"`
	unknownFields                    protoimpl.UnknownFields
	sizeCache                        protoimpl.SizeCache
}

func (x *ReceiverStats) Reset() {
	*x = ReceiverStats{}
	mi := &file_api_common_telemetry_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReceiverStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReceiverStats) ProtoMessage() {}

func (x *ReceiverStats) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReceiverStats.ProtoReflect.Descriptor instead.
func (*ReceiverStats) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{3}
}

func (x *ReceiverStats) GetTimestamp() *DateTime {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *ReceiverStats) GetTransmitterPhysicalAddress() string {
	if x != nil && x.TransmitterPhysicalAddress != nil {
		return *x.TransmitterPhysicalAddress
	}
	return ""
}

func (x *ReceiverStats) GetPowerAtReceiverOutputDbw() float64 {
	if x != nil && x.PowerAtReceiverOutputDbw != nil {
		return *x.PowerAtReceiverOutputDbw
	}
	return 0
}

func (x *ReceiverStats) GetPowerAtReceiverOutputByChainDbw() []float64 {
	if x != nil {
		return x.PowerAtReceiverOutputByChainDbw
	}
	return nil
}

func (x *ReceiverStats) GetMseDb() float64 {
	if x != nil && x.MseDb != nil {
		return *x.MseDb
	}
	return 0
}

func (x *ReceiverStats) GetCarrierToNoisePlusInterferenceDb() float64 {
	if x != nil && x.CarrierToNoisePlusInterferenceDb != nil {
		return *x.CarrierToNoisePlusInterferenceDb
	}
	return 0
}

type RadioStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IDs to identify the local interface for this radio
	InterfaceId      *string             `protobuf:"bytes,5,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	TransmitterStats []*TransmitterStats `protobuf:"bytes,3,rep,name=transmitter_stats,json=transmitterStats" json:"transmitter_stats,omitempty"`
	ReceiverStats    []*ReceiverStats    `protobuf:"bytes,4,rep,name=receiver_stats,json=receiverStats" json:"receiver_stats,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RadioStats) Reset() {
	*x = RadioStats{}
	mi := &file_api_common_telemetry_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RadioStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RadioStats) ProtoMessage() {}

func (x *RadioStats) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RadioStats.ProtoReflect.Descriptor instead.
func (*RadioStats) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{4}
}

func (x *RadioStats) GetInterfaceId() string {
	if x != nil && x.InterfaceId != nil {
		return *x.InterfaceId
	}
	return ""
}

func (x *RadioStats) GetTransmitterStats() []*TransmitterStats {
	if x != nil {
		return x.TransmitterStats
	}
	return nil
}

func (x *RadioStats) GetReceiverStats() []*ReceiverStats {
	if x != nil {
		return x.ReceiverStats
	}
	return nil
}

// Summary interface statistics, with the time observed.
//
// Modeled after RFC 8343 `ietf-interfaces` module `statistics`
// entry, slightly simplified:
//
//	+--ro statistics
//	   +--ro in-octets?            yang:counter64
//	   +--ro in-unicast-pkts?      yang:counter64
//	   +--ro in-discards?          yang:counter32
//	   +--ro in-errors?            yang:counter32
//	   +--ro out-octets?           yang:counter64
//	   +--ro out-unicast-pkts?     yang:counter64
//	   +--ro out-discards?         yang:counter32
//	   +--ro out-errors?           yang:counter32
//
// Field names inspired by Linux RT_NETLINK structures.
type InterfaceStats struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Timestamp *DateTime              `protobuf:"bytes,9,opt,name=timestamp" json:"timestamp,omitempty"`
	// Number of packets transmitted and received.
	TxPackets *int64 `protobuf:"varint,1,opt,name=tx_packets,json=txPackets" json:"tx_packets,omitempty"`
	RxPackets *int64 `protobuf:"varint,2,opt,name=rx_packets,json=rxPackets" json:"rx_packets,omitempty"`
	// Number of bytes transmitted and received.
	TxBytes *int64 `protobuf:"varint,3,opt,name=tx_bytes,json=txBytes" json:"tx_bytes,omitempty"`
	RxBytes *int64 `protobuf:"varint,4,opt,name=rx_bytes,json=rxBytes" json:"rx_bytes,omitempty"`
	// Number of packets dropped.
	TxDropped *int64 `protobuf:"varint,5,opt,name=tx_dropped,json=txDropped" json:"tx_dropped,omitempty"`
	RxDropped *int64 `protobuf:"varint,6,opt,name=rx_dropped,json=rxDropped" json:"rx_dropped,omitempty"`
	// Number of packet errors (i.e., frame alignment errors, rx overruns,
	// CRC errors, packet collisions, etc.
	RxErrors      *int64 `protobuf:"varint,7,opt,name=rx_errors,json=rxErrors" json:"rx_errors,omitempty"`
	TxErrors      *int64 `protobuf:"varint,8,opt,name=tx_errors,json=txErrors" json:"tx_errors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InterfaceStats) Reset() {
	*x = InterfaceStats{}
	mi := &file_api_common_telemetry_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InterfaceStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InterfaceStats) ProtoMessage() {}

func (x *InterfaceStats) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InterfaceStats.ProtoReflect.Descriptor instead.
func (*InterfaceStats) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{5}
}

func (x *InterfaceStats) GetTimestamp() *DateTime {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *InterfaceStats) GetTxPackets() int64 {
	if x != nil && x.TxPackets != nil {
		return *x.TxPackets
	}
	return 0
}

func (x *InterfaceStats) GetRxPackets() int64 {
	if x != nil && x.RxPackets != nil {
		return *x.RxPackets
	}
	return 0
}

func (x *InterfaceStats) GetTxBytes() int64 {
	if x != nil && x.TxBytes != nil {
		return *x.TxBytes
	}
	return 0
}

func (x *InterfaceStats) GetRxBytes() int64 {
	if x != nil && x.RxBytes != nil {
		return *x.RxBytes
	}
	return 0
}

func (x *InterfaceStats) GetTxDropped() int64 {
	if x != nil && x.TxDropped != nil {
		return *x.TxDropped
	}
	return 0
}

func (x *InterfaceStats) GetRxDropped() int64 {
	if x != nil && x.RxDropped != nil {
		return *x.RxDropped
	}
	return 0
}

func (x *InterfaceStats) GetRxErrors() int64 {
	if x != nil && x.RxErrors != nil {
		return *x.RxErrors
	}
	return 0
}

func (x *InterfaceStats) GetTxErrors() int64 {
	if x != nil && x.TxErrors != nil {
		return *x.TxErrors
	}
	return 0
}

type FlowStats struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Timestamp *DateTime              `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// Number of packets transmitted and received.
	TxPackets *int64 `protobuf:"varint,2,opt,name=tx_packets,json=txPackets" json:"tx_packets,omitempty"`
	RxPackets *int64 `protobuf:"varint,3,opt,name=rx_packets,json=rxPackets" json:"rx_packets,omitempty"`
	// Number of bytes transmitted and received.
	TxBytes       *int64 `protobuf:"varint,4,opt,name=tx_bytes,json=txBytes" json:"tx_bytes,omitempty"`
	RxBytes       *int64 `protobuf:"varint,5,opt,name=rx_bytes,json=rxBytes" json:"rx_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowStats) Reset() {
	*x = FlowStats{}
	mi := &file_api_common_telemetry_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowStats) ProtoMessage() {}

func (x *FlowStats) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowStats.ProtoReflect.Descriptor instead.
func (*FlowStats) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{6}
}

func (x *FlowStats) GetTimestamp() *DateTime {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *FlowStats) GetTxPackets() int64 {
	if x != nil && x.TxPackets != nil {
		return *x.TxPackets
	}
	return 0
}

func (x *FlowStats) GetRxPackets() int64 {
	if x != nil && x.RxPackets != nil {
		return *x.RxPackets
	}
	return 0
}

func (x *FlowStats) GetTxBytes() int64 {
	if x != nil && x.TxBytes != nil {
		return *x.TxBytes
	}
	return 0
}

func (x *FlowStats) GetRxBytes() int64 {
	if x != nil && x.RxBytes != nil {
		return *x.RxBytes
	}
	return 0
}

// Asynchronous network telemetry event reports
type NetworkEventReport struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Uniquely identifies the network node/element.
	NodeId *string `protobuf:"bytes,5,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// Time at which the event occurred.
	Timestamp *DateTime `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// Types that are valid to be assigned to SourceType:
	//
	//	*NetworkEventReport_RadioEvent
	//	*NetworkEventReport_PortEvent
	//	*NetworkEventReport_InterfaceEvent
	SourceType    isNetworkEventReport_SourceType `protobuf_oneof:"source_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkEventReport) Reset() {
	*x = NetworkEventReport{}
	mi := &file_api_common_telemetry_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkEventReport) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkEventReport) ProtoMessage() {}

func (x *NetworkEventReport) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkEventReport.ProtoReflect.Descriptor instead.
func (*NetworkEventReport) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{7}
}

func (x *NetworkEventReport) GetNodeId() string {
	if x != nil && x.NodeId != nil {
		return *x.NodeId
	}
	return ""
}

func (x *NetworkEventReport) GetTimestamp() *DateTime {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *NetworkEventReport) GetSourceType() isNetworkEventReport_SourceType {
	if x != nil {
		return x.SourceType
	}
	return nil
}

func (x *NetworkEventReport) GetRadioEvent() *RadioEvent {
	if x != nil {
		if x, ok := x.SourceType.(*NetworkEventReport_RadioEvent); ok {
			return x.RadioEvent
		}
	}
	return nil
}

func (x *NetworkEventReport) GetPortEvent() *PortEvent {
	if x != nil {
		if x, ok := x.SourceType.(*NetworkEventReport_PortEvent); ok {
			return x.PortEvent
		}
	}
	return nil
}

func (x *NetworkEventReport) GetInterfaceEvent() *InterfaceEvent {
	if x != nil {
		if x, ok := x.SourceType.(*NetworkEventReport_InterfaceEvent); ok {
			return x.InterfaceEvent
		}
	}
	return nil
}

type isNetworkEventReport_SourceType interface {
	isNetworkEventReport_SourceType()
}

type NetworkEventReport_RadioEvent struct {
	RadioEvent *RadioEvent `protobuf:"bytes,2,opt,name=radio_event,json=radioEvent,oneof"`
}

type NetworkEventReport_PortEvent struct {
	PortEvent *PortEvent `protobuf:"bytes,3,opt,name=port_event,json=portEvent,oneof"`
}

type NetworkEventReport_InterfaceEvent struct {
	InterfaceEvent *InterfaceEvent `protobuf:"bytes,4,opt,name=interface_event,json=interfaceEvent,oneof"`
}

func (*NetworkEventReport_RadioEvent) isNetworkEventReport_SourceType() {}

func (*NetworkEventReport_PortEvent) isNetworkEventReport_SourceType() {}

func (*NetworkEventReport_InterfaceEvent) isNetworkEventReport_SourceType() {}

// Asynchronous radio events
type RadioEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to RadioId:
	//
	//	*RadioEvent_TransmitterId
	//	*RadioEvent_ReceiverId
	RadioId isRadioEvent_RadioId `protobuf_oneof:"radio_id"`
	// Types that are valid to be assigned to Event:
	//
	//	*RadioEvent_LinkStatus_
	Event         isRadioEvent_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RadioEvent) Reset() {
	*x = RadioEvent{}
	mi := &file_api_common_telemetry_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RadioEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RadioEvent) ProtoMessage() {}

func (x *RadioEvent) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RadioEvent.ProtoReflect.Descriptor instead.
func (*RadioEvent) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{8}
}

func (x *RadioEvent) GetRadioId() isRadioEvent_RadioId {
	if x != nil {
		return x.RadioId
	}
	return nil
}

func (x *RadioEvent) GetTransmitterId() string {
	if x != nil {
		if x, ok := x.RadioId.(*RadioEvent_TransmitterId); ok {
			return x.TransmitterId
		}
	}
	return ""
}

func (x *RadioEvent) GetReceiverId() string {
	if x != nil {
		if x, ok := x.RadioId.(*RadioEvent_ReceiverId); ok {
			return x.ReceiverId
		}
	}
	return ""
}

func (x *RadioEvent) GetEvent() isRadioEvent_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *RadioEvent) GetLinkStatus() RadioEvent_LinkStatus {
	if x != nil {
		if x, ok := x.Event.(*RadioEvent_LinkStatus_); ok {
			return x.LinkStatus
		}
	}
	return RadioEvent_UNKNOWN
}

type isRadioEvent_RadioId interface {
	isRadioEvent_RadioId()
}

type RadioEvent_TransmitterId struct {
	TransmitterId string `protobuf:"bytes,1,opt,name=transmitter_id,json=transmitterId,oneof"`
}

type RadioEvent_ReceiverId struct {
	ReceiverId string `protobuf:"bytes,2,opt,name=receiver_id,json=receiverId,oneof"`
}

func (*RadioEvent_TransmitterId) isRadioEvent_RadioId() {}

func (*RadioEvent_ReceiverId) isRadioEvent_RadioId() {}

type isRadioEvent_Event interface {
	isRadioEvent_Event()
}

type RadioEvent_LinkStatus_ struct {
	LinkStatus RadioEvent_LinkStatus `protobuf:"varint,3,opt,name=link_status,json=linkStatus,enum=aalyria.spacetime.api.common.RadioEvent_LinkStatus,oneof"`
}

func (*RadioEvent_LinkStatus_) isRadioEvent_Event() {}

// Asynchronous (wired) port events
type PortEvent struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	PortId *string                `protobuf:"bytes,1,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	// Types that are valid to be assigned to Event:
	//
	//	*PortEvent_PortStatus_
	Event         isPortEvent_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PortEvent) Reset() {
	*x = PortEvent{}
	mi := &file_api_common_telemetry_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortEvent) ProtoMessage() {}

func (x *PortEvent) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortEvent.ProtoReflect.Descriptor instead.
func (*PortEvent) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{9}
}

func (x *PortEvent) GetPortId() string {
	if x != nil && x.PortId != nil {
		return *x.PortId
	}
	return ""
}

func (x *PortEvent) GetEvent() isPortEvent_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *PortEvent) GetPortStatus() PortEvent_PortStatus {
	if x != nil {
		if x, ok := x.Event.(*PortEvent_PortStatus_); ok {
			return x.PortStatus
		}
	}
	return PortEvent_UNKNOWN
}

type isPortEvent_Event interface {
	isPortEvent_Event()
}

type PortEvent_PortStatus_ struct {
	PortStatus PortEvent_PortStatus `protobuf:"varint,2,opt,name=port_status,json=portStatus,enum=aalyria.spacetime.api.common.PortEvent_PortStatus,oneof"`
}

func (*PortEvent_PortStatus_) isPortEvent_Event() {}

// Asynchronous logical network interface events
type InterfaceEvent struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	InterfaceId *string                `protobuf:"bytes,1,opt,name=interface_id,json=interfaceId" json:"interface_id,omitempty"`
	// Types that are valid to be assigned to Event:
	//
	//	*InterfaceEvent_InterfaceStatus_
	//	*InterfaceEvent_IpAddress
	Event         isInterfaceEvent_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InterfaceEvent) Reset() {
	*x = InterfaceEvent{}
	mi := &file_api_common_telemetry_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InterfaceEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InterfaceEvent) ProtoMessage() {}

func (x *InterfaceEvent) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InterfaceEvent.ProtoReflect.Descriptor instead.
func (*InterfaceEvent) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{10}
}

func (x *InterfaceEvent) GetInterfaceId() string {
	if x != nil && x.InterfaceId != nil {
		return *x.InterfaceId
	}
	return ""
}

func (x *InterfaceEvent) GetEvent() isInterfaceEvent_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *InterfaceEvent) GetInterfaceStatus() InterfaceEvent_InterfaceStatus {
	if x != nil {
		if x, ok := x.Event.(*InterfaceEvent_InterfaceStatus_); ok {
			return x.InterfaceStatus
		}
	}
	return InterfaceEvent_UNKNOWN
}

func (x *InterfaceEvent) GetIpAddress() string {
	if x != nil {
		if x, ok := x.Event.(*InterfaceEvent_IpAddress); ok {
			return x.IpAddress
		}
	}
	return ""
}

type isInterfaceEvent_Event interface {
	isInterfaceEvent_Event()
}

type InterfaceEvent_InterfaceStatus_ struct {
	InterfaceStatus InterfaceEvent_InterfaceStatus `protobuf:"varint,2,opt,name=interface_status,json=interfaceStatus,enum=aalyria.spacetime.api.common.InterfaceEvent_InterfaceStatus,oneof"`
}

type InterfaceEvent_IpAddress struct {
	IpAddress string `protobuf:"bytes,3,opt,name=ip_address,json=ipAddress,oneof"`
}

func (*InterfaceEvent_InterfaceStatus_) isInterfaceEvent_Event() {}

func (*InterfaceEvent_IpAddress) isInterfaceEvent_Event() {}

type BeamStats_TargetingStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The latest location that the beam is trying to target.
	TargetLocation *GeodeticWgs84 `protobuf:"bytes,1,opt,name=target_location,json=targetLocation" json:"target_location,omitempty"`
	// The progress of establishing a connection with the target specified in
	// current_beam_update.
	ConnectionStatus *BeamStats_TargetingStats_ConnectionStatus `protobuf:"varint,2,opt,name=connection_status,json=connectionStatus,enum=aalyria.spacetime.api.common.BeamStats_TargetingStats_ConnectionStatus" json:"connection_status,omitempty"`
	// The latest beam task ID
	BeamTaskId *string `protobuf:"bytes,3,opt,name=beam_task_id,json=beamTaskId" json:"beam_task_id,omitempty"`
	// An ID used to identify the target. For example, this can be the 48-bit
	// MAC address of the remote target's network interface.
	TargetIdentifier *string `protobuf:"bytes,4,opt,name=target_identifier,json=targetIdentifier" json:"target_identifier,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *BeamStats_TargetingStats) Reset() {
	*x = BeamStats_TargetingStats{}
	mi := &file_api_common_telemetry_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BeamStats_TargetingStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BeamStats_TargetingStats) ProtoMessage() {}

func (x *BeamStats_TargetingStats) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BeamStats_TargetingStats.ProtoReflect.Descriptor instead.
func (*BeamStats_TargetingStats) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{1, 0}
}

func (x *BeamStats_TargetingStats) GetTargetLocation() *GeodeticWgs84 {
	if x != nil {
		return x.TargetLocation
	}
	return nil
}

func (x *BeamStats_TargetingStats) GetConnectionStatus() BeamStats_TargetingStats_ConnectionStatus {
	if x != nil && x.ConnectionStatus != nil {
		return *x.ConnectionStatus
	}
	return BeamStats_TargetingStats_UNKNOWN
}

func (x *BeamStats_TargetingStats) GetBeamTaskId() string {
	if x != nil && x.BeamTaskId != nil {
		return *x.BeamTaskId
	}
	return ""
}

func (x *BeamStats_TargetingStats) GetTargetIdentifier() string {
	if x != nil && x.TargetIdentifier != nil {
		return *x.TargetIdentifier
	}
	return ""
}

type BeamStats_GimbalStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The current location of the gimbal.
	Location *GeodeticWgs84 `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// Types that are valid to be assigned to SiteOrientation:
	//
	//	*BeamStats_GimbalStats_OrientationQuaternion
	//	*BeamStats_GimbalStats_OrientationYpr
	SiteOrientation isBeamStats_GimbalStats_SiteOrientation `protobuf_oneof:"site_orientation"`
	// The direction at which the gimbal is pointing the center of its beam.
	// These coordinates are relative to the site_orientation.
	PointingVector *PointingVector `protobuf:"bytes,4,opt,name=pointing_vector,json=pointingVector" json:"pointing_vector,omitempty"`
	// Whether this gimbal is fully initialized and should be able to perform
	// tasks.
	Initialized   *bool `protobuf:"varint,5,opt,name=initialized" json:"initialized,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BeamStats_GimbalStats) Reset() {
	*x = BeamStats_GimbalStats{}
	mi := &file_api_common_telemetry_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BeamStats_GimbalStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BeamStats_GimbalStats) ProtoMessage() {}

func (x *BeamStats_GimbalStats) ProtoReflect() protoreflect.Message {
	mi := &file_api_common_telemetry_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BeamStats_GimbalStats.ProtoReflect.Descriptor instead.
func (*BeamStats_GimbalStats) Descriptor() ([]byte, []int) {
	return file_api_common_telemetry_proto_rawDescGZIP(), []int{1, 1}
}

func (x *BeamStats_GimbalStats) GetLocation() *GeodeticWgs84 {
	if x != nil {
		return x.Location
	}
	return nil
}

func (x *BeamStats_GimbalStats) GetSiteOrientation() isBeamStats_GimbalStats_SiteOrientation {
	if x != nil {
		return x.SiteOrientation
	}
	return nil
}

func (x *BeamStats_GimbalStats) GetOrientationQuaternion() *Quaternion {
	if x != nil {
		if x, ok := x.SiteOrientation.(*BeamStats_GimbalStats_OrientationQuaternion); ok {
			return x.OrientationQuaternion
		}
	}
	return nil
}

func (x *BeamStats_GimbalStats) GetOrientationYpr() *YawPitchRoll {
	if x != nil {
		if x, ok := x.SiteOrientation.(*BeamStats_GimbalStats_OrientationYpr); ok {
			return x.OrientationYpr
		}
	}
	return nil
}

func (x *BeamStats_GimbalStats) GetPointingVector() *PointingVector {
	if x != nil {
		return x.PointingVector
	}
	return nil
}

func (x *BeamStats_GimbalStats) GetInitialized() bool {
	if x != nil && x.Initialized != nil {
		return *x.Initialized
	}
	return false
}

type isBeamStats_GimbalStats_SiteOrientation interface {
	isBeamStats_GimbalStats_SiteOrientation()
}

type BeamStats_GimbalStats_OrientationQuaternion struct {
	// The rotational offset relative to the ECEF frame.
	OrientationQuaternion *Quaternion `protobuf:"bytes,2,opt,name=orientation_quaternion,json=orientationQuaternion,oneof"`
}

type BeamStats_GimbalStats_OrientationYpr struct {
	// The rotational offset from the North-East-Down (NED) frame to the
	// gimbal's local reference frame.
	OrientationYpr *YawPitchRoll `protobuf:"bytes,3,opt,name=orientation_ypr,json=orientationYpr,oneof"`
}

func (*BeamStats_GimbalStats_OrientationQuaternion) isBeamStats_GimbalStats_SiteOrientation() {}

func (*BeamStats_GimbalStats_OrientationYpr) isBeamStats_GimbalStats_SiteOrientation() {}

var File_api_common_telemetry_proto protoreflect.FileDescriptor

const file_api_common_telemetry_proto_rawDesc = "" +
	"\n" +
	"\x1aapi/common/telemetry.proto\x12\x1caalyria.spacetime.api.common\x1a\x1capi/common/coordinates.proto\x1a\x15api/common/time.proto\"\xbf\b\n" +
	"\x12NetworkStatsReport\x12\x17\n" +
	"\anode_id\x18\a \x01(\tR\x06nodeId\x12D\n" +
	"\ttimestamp\x18\x01 \x01(\v2&.aalyria.spacetime.api.common.DateTimeR\ttimestamp\x12\x8b\x01\n" +
	"\x1bradio_stats_by_interface_id\x18\x04 \x03(\v2M.aalyria.spacetime.api.common.NetworkStatsReport.RadioStatsByInterfaceIdEntryR\x17radioStatsByInterfaceId\x12{\n" +
	"\x15interface_stats_by_id\x18\x03 \x03(\v2H.aalyria.spacetime.api.common.NetworkStatsReport.InterfaceStatsByIdEntryR\x12interfaceStatsById\x12\x82\x01\n" +
	"\x18beam_stats_by_antenna_id\x18\x05 \x03(\v2J.aalyria.spacetime.api.common.NetworkStatsReport.BeamStatsByAntennaIdEntryR\x14beamStatsByAntennaId\x12l\n" +
	"\x10flow_stats_by_id\x18\x06 \x03(\v2C.aalyria.spacetime.api.common.NetworkStatsReport.FlowStatsByIdEntryR\rflowStatsById\x1at\n" +
	"\x1cRadioStatsByInterfaceIdEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12>\n" +
	"\x05value\x18\x02 \x01(\v2(.aalyria.spacetime.api.common.RadioStatsR\x05value:\x028\x01\x1as\n" +
	"\x17InterfaceStatsByIdEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12B\n" +
	"\x05value\x18\x02 \x01(\v2,.aalyria.spacetime.api.common.InterfaceStatsR\x05value:\x028\x01\x1ap\n" +
	"\x19BeamStatsByAntennaIdEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12=\n" +
	"\x05value\x18\x02 \x01(\v2'.aalyria.spacetime.api.common.BeamStatsR\x05value:\x028\x01\x1ai\n" +
	"\x12FlowStatsByIdEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12=\n" +
	"\x05value\x18\x02 \x01(\v2'.aalyria.spacetime.api.common.FlowStatsR\x05value:\x028\x01J\x04\b\x02\x10\x03\"\xfc\a\n" +
	"\tBeamStats\x12D\n" +
	"\ttimestamp\x18\x01 \x01(\v2&.aalyria.spacetime.api.common.DateTimeR\ttimestamp\x12T\n" +
	"\ttargeting\x18\x02 \x01(\v26.aalyria.spacetime.api.common.BeamStats.TargetingStatsR\ttargeting\x12K\n" +
	"\x06gimbal\x18\x03 \x01(\v23.aalyria.spacetime.api.common.BeamStats.GimbalStatsR\x06gimbal\x1a\xe5\x02\n" +
	"\x0eTargetingStats\x12T\n" +
	"\x0ftarget_location\x18\x01 \x01(\v2+.aalyria.spacetime.api.common.GeodeticWgs84R\x0etargetLocation\x12t\n" +
	"\x11connection_status\x18\x02 \x01(\x0e2G.aalyria.spacetime.api.common.BeamStats.TargetingStats.ConnectionStatusR\x10connectionStatus\x12 \n" +
	"\fbeam_task_id\x18\x03 \x01(\tR\n" +
	"beamTaskId\x12+\n" +
	"\x11target_identifier\x18\x04 \x01(\tR\x10targetIdentifier\"8\n" +
	"\x10ConnectionStatus\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aSEEKING\x10\x01\x12\n" +
	"\n" +
	"\x06LOCKED\x10\x02\x1a\x9d\x03\n" +
	"\vGimbalStats\x12G\n" +
	"\blocation\x18\x01 \x01(\v2+.aalyria.spacetime.api.common.GeodeticWgs84R\blocation\x12a\n" +
	"\x16orientation_quaternion\x18\x02 \x01(\v2(.aalyria.spacetime.api.common.QuaternionH\x00R\x15orientationQuaternion\x12U\n" +
	"\x0forientation_ypr\x18\x03 \x01(\v2*.aalyria.spacetime.api.common.YawPitchRollH\x00R\x0eorientationYpr\x12U\n" +
	"\x0fpointing_vector\x18\x04 \x01(\v2,.aalyria.spacetime.api.common.PointingVectorR\x0epointingVector\x12 \n" +
	"\vinitialized\x18\x05 \x01(\bR\vinitializedB\x12\n" +
	"\x10site_orientation\"\xef\x01\n" +
	"\x10TransmitterStats\x12D\n" +
	"\ttimestamp\x18\x04 \x01(\v2&.aalyria.spacetime.api.common.DateTimeR\ttimestamp\x12:\n" +
	"\x19receiver_physical_address\x18\x05 \x01(\tR\x17receiverPhysicalAddress\x12\"\n" +
	"\rdata_rate_bps\x18\x02 \x01(\x01R\vdataRateBps\x12/\n" +
	"\x14tx_packet_error_rate\x18\x03 \x01(\x01R\x11txPacketErrorRateJ\x04\b\x01\x10\x02\"\x95\x03\n" +
	"\rReceiverStats\x12D\n" +
	"\ttimestamp\x18\x03 \x01(\v2&.aalyria.spacetime.api.common.DateTimeR\ttimestamp\x12@\n" +
	"\x1ctransmitter_physical_address\x18\x04 \x01(\tR\x1atransmitterPhysicalAddress\x12>\n" +
	"\x1cpower_at_receiver_output_dbw\x18\x02 \x01(\x01R\x18powerAtReceiverOutputDbw\x12N\n" +
	"%power_at_receiver_output_by_chain_dbw\x18\x05 \x03(\x01R\x1fpowerAtReceiverOutputByChainDbw\x12\x15\n" +
	"\x06mse_db\x18\x06 \x01(\x01R\x05mseDb\x12O\n" +
	"%carrier_to_noise_plus_interference_db\x18\a \x01(\x01R carrierToNoisePlusInterferenceDbJ\x04\b\x01\x10\x02\"\xec\x01\n" +
	"\n" +
	"RadioStats\x12!\n" +
	"\finterface_id\x18\x05 \x01(\tR\vinterfaceId\x12[\n" +
	"\x11transmitter_stats\x18\x03 \x03(\v2..aalyria.spacetime.api.common.TransmitterStatsR\x10transmitterStats\x12R\n" +
	"\x0ereceiver_stats\x18\x04 \x03(\v2+.aalyria.spacetime.api.common.ReceiverStatsR\rreceiverStatsJ\x04\b\x01\x10\x02J\x04\b\x02\x10\x03\"\xc2\x02\n" +
	"\x0eInterfaceStats\x12D\n" +
	"\ttimestamp\x18\t \x01(\v2&.aalyria.spacetime.api.common.DateTimeR\ttimestamp\x12\x1d\n" +
	"\n" +
	"tx_packets\x18\x01 \x01(\x03R\ttxPackets\x12\x1d\n" +
	"\n" +
	"rx_packets\x18\x02 \x01(\x03R\trxPackets\x12\x19\n" +
	"\btx_bytes\x18\x03 \x01(\x03R\atxBytes\x12\x19\n" +
	"\brx_bytes\x18\x04 \x01(\x03R\arxBytes\x12\x1d\n" +
	"\n" +
	"tx_dropped\x18\x05 \x01(\x03R\ttxDropped\x12\x1d\n" +
	"\n" +
	"rx_dropped\x18\x06 \x01(\x03R\trxDropped\x12\x1b\n" +
	"\trx_errors\x18\a \x01(\x03R\brxErrors\x12\x1b\n" +
	"\ttx_errors\x18\b \x01(\x03R\btxErrors\"\xc5\x01\n" +
	"\tFlowStats\x12D\n" +
	"\ttimestamp\x18\x01 \x01(\v2&.aalyria.spacetime.api.common.DateTimeR\ttimestamp\x12\x1d\n" +
	"\n" +
	"tx_packets\x18\x02 \x01(\x03R\ttxPackets\x12\x1d\n" +
	"\n" +
	"rx_packets\x18\x03 \x01(\x03R\trxPackets\x12\x19\n" +
	"\btx_bytes\x18\x04 \x01(\x03R\atxBytes\x12\x19\n" +
	"\brx_bytes\x18\x05 \x01(\x03R\arxBytes\"\xf2\x02\n" +
	"\x12NetworkEventReport\x12\x17\n" +
	"\anode_id\x18\x05 \x01(\tR\x06nodeId\x12D\n" +
	"\ttimestamp\x18\x01 \x01(\v2&.aalyria.spacetime.api.common.DateTimeR\ttimestamp\x12K\n" +
	"\vradio_event\x18\x02 \x01(\v2(.aalyria.spacetime.api.common.RadioEventH\x00R\n" +
	"radioEvent\x12H\n" +
	"\n" +
	"port_event\x18\x03 \x01(\v2'.aalyria.spacetime.api.common.PortEventH\x00R\tportEvent\x12W\n" +
	"\x0finterface_event\x18\x04 \x01(\v2,.aalyria.spacetime.api.common.InterfaceEventH\x00R\x0einterfaceEventB\r\n" +
	"\vsource_type\"\xf2\x01\n" +
	"\n" +
	"RadioEvent\x12'\n" +
	"\x0etransmitter_id\x18\x01 \x01(\tH\x00R\rtransmitterId\x12!\n" +
	"\vreceiver_id\x18\x02 \x01(\tH\x00R\n" +
	"receiverId\x12V\n" +
	"\vlink_status\x18\x03 \x01(\x0e23.aalyria.spacetime.api.common.RadioEvent.LinkStatusH\x01R\n" +
	"linkStatus\"+\n" +
	"\n" +
	"LinkStatus\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\b\n" +
	"\x04DOWN\x10\x01\x12\x06\n" +
	"\x02UP\x10\x02B\n" +
	"\n" +
	"\bradio_idB\a\n" +
	"\x05event\"\xb1\x01\n" +
	"\tPortEvent\x12\x17\n" +
	"\aport_id\x18\x01 \x01(\tR\x06portId\x12U\n" +
	"\vport_status\x18\x02 \x01(\x0e22.aalyria.spacetime.api.common.PortEvent.PortStatusH\x00R\n" +
	"portStatus\"+\n" +
	"\n" +
	"PortStatus\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\b\n" +
	"\x04DOWN\x10\x01\x12\x06\n" +
	"\x02UP\x10\x02B\a\n" +
	"\x05event\"\x83\x02\n" +
	"\x0eInterfaceEvent\x12!\n" +
	"\finterface_id\x18\x01 \x01(\tR\vinterfaceId\x12i\n" +
	"\x10interface_status\x18\x02 \x01(\x0e2<.aalyria.spacetime.api.common.InterfaceEvent.InterfaceStatusH\x00R\x0finterfaceStatus\x12\x1f\n" +
	"\n" +
	"ip_address\x18\x03 \x01(\tH\x00R\tipAddress\"9\n" +
	"\x0fInterfaceStatus\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\f\n" +
	"\bDISABLED\x10\x01\x12\v\n" +
	"\aENABLED\x10\x02B\a\n" +
	"\x05eventBD\n" +
	" com.aalyria.spacetime.api.commonZ aalyria.com/spacetime/api/common"

var (
	file_api_common_telemetry_proto_rawDescOnce sync.Once
	file_api_common_telemetry_proto_rawDescData []byte
)

func file_api_common_telemetry_proto_rawDescGZIP() []byte {
	file_api_common_telemetry_proto_rawDescOnce.Do(func() {
		file_api_common_telemetry_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_common_telemetry_proto_rawDesc), len(file_api_common_telemetry_proto_rawDesc)))
	})
	return file_api_common_telemetry_proto_rawDescData
}

var file_api_common_telemetry_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_api_common_telemetry_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_api_common_telemetry_proto_goTypes = []any{
	(BeamStats_TargetingStats_ConnectionStatus)(0), // 0: aalyria.spacetime.api.common.BeamStats.TargetingStats.ConnectionStatus
	(RadioEvent_LinkStatus)(0),                     // 1: aalyria.spacetime.api.common.RadioEvent.LinkStatus
	(PortEvent_PortStatus)(0),                      // 2: aalyria.spacetime.api.common.PortEvent.PortStatus
	(InterfaceEvent_InterfaceStatus)(0),            // 3: aalyria.spacetime.api.common.InterfaceEvent.InterfaceStatus
	(*NetworkStatsReport)(nil),                     // 4: aalyria.spacetime.api.common.NetworkStatsReport
	(*BeamStats)(nil),                              // 5: aalyria.spacetime.api.common.BeamStats
	(*TransmitterStats)(nil),                       // 6: aalyria.spacetime.api.common.TransmitterStats
	(*ReceiverStats)(nil),                          // 7: aalyria.spacetime.api.common.ReceiverStats
	(*RadioStats)(nil),                             // 8: aalyria.spacetime.api.common.RadioStats
	(*InterfaceStats)(nil),                         // 9: aalyria.spacetime.api.common.InterfaceStats
	(*FlowStats)(nil),                              // 10: aalyria.spacetime.api.common.FlowStats
	(*NetworkEventReport)(nil),                     // 11: aalyria.spacetime.api.common.NetworkEventReport
	(*RadioEvent)(nil),                             // 12: aalyria.spacetime.api.common.RadioEvent
	(*PortEvent)(nil),                              // 13: aalyria.spacetime.api.common.PortEvent
	(*InterfaceEvent)(nil),                         // 14: aalyria.spacetime.api.common.InterfaceEvent
	nil,                                            // 15: aalyria.spacetime.api.common.NetworkStatsReport.RadioStatsByInterfaceIdEntry
	nil,                                            // 16: aalyria.spacetime.api.common.NetworkStatsReport.InterfaceStatsByIdEntry
	nil,                                            // 17: aalyria.spacetime.api.common.NetworkStatsReport.BeamStatsByAntennaIdEntry
	nil,                                            // 18: aalyria.spacetime.api.common.NetworkStatsReport.FlowStatsByIdEntry
	(*BeamStats_TargetingStats)(nil),               // 19: aalyria.spacetime.api.common.BeamStats.TargetingStats
	(*BeamStats_GimbalStats)(nil),                  // 20: aalyria.spacetime.api.common.BeamStats.GimbalStats
	(*DateTime)(nil),                               // 21: aalyria.spacetime.api.common.DateTime
	(*GeodeticWgs84)(nil),                          // 22: aalyria.spacetime.api.common.GeodeticWgs84
	(*Quaternion)(nil),                             // 23: aalyria.spacetime.api.common.Quaternion
	(*YawPitchRoll)(nil),                           // 24: aalyria.spacetime.api.common.YawPitchRoll
	(*PointingVector)(nil),                         // 25: aalyria.spacetime.api.common.PointingVector
}
var file_api_common_telemetry_proto_depIdxs = []int32{
	21, // 0: aalyria.spacetime.api.common.NetworkStatsReport.timestamp:type_name -> aalyria.spacetime.api.common.DateTime
	15, // 1: aalyria.spacetime.api.common.NetworkStatsReport.radio_stats_by_interface_id:type_name -> aalyria.spacetime.api.common.NetworkStatsReport.RadioStatsByInterfaceIdEntry
	16, // 2: aalyria.spacetime.api.common.NetworkStatsReport.interface_stats_by_id:type_name -> aalyria.spacetime.api.common.NetworkStatsReport.InterfaceStatsByIdEntry
	17, // 3: aalyria.spacetime.api.common.NetworkStatsReport.beam_stats_by_antenna_id:type_name -> aalyria.spacetime.api.common.NetworkStatsReport.BeamStatsByAntennaIdEntry
	18, // 4: aalyria.spacetime.api.common.NetworkStatsReport.flow_stats_by_id:type_name -> aalyria.spacetime.api.common.NetworkStatsReport.FlowStatsByIdEntry
	21, // 5: aalyria.spacetime.api.common.BeamStats.timestamp:type_name -> aalyria.spacetime.api.common.DateTime
	19, // 6: aalyria.spacetime.api.common.BeamStats.targeting:type_name -> aalyria.spacetime.api.common.BeamStats.TargetingStats
	20, // 7: aalyria.spacetime.api.common.BeamStats.gimbal:type_name -> aalyria.spacetime.api.common.BeamStats.GimbalStats
	21, // 8: aalyria.spacetime.api.common.TransmitterStats.timestamp:type_name -> aalyria.spacetime.api.common.DateTime
	21, // 9: aalyria.spacetime.api.common.ReceiverStats.timestamp:type_name -> aalyria.spacetime.api.common.DateTime
	6,  // 10: aalyria.spacetime.api.common.RadioStats.transmitter_stats:type_name -> aalyria.spacetime.api.common.TransmitterStats
	7,  // 11: aalyria.spacetime.api.common.RadioStats.receiver_stats:type_name -> aalyria.spacetime.api.common.ReceiverStats
	21, // 12: aalyria.spacetime.api.common.InterfaceStats.timestamp:type_name -> aalyria.spacetime.api.common.DateTime
	21, // 13: aalyria.spacetime.api.common.FlowStats.timestamp:type_name -> aalyria.spacetime.api.common.DateTime
	21, // 14: aalyria.spacetime.api.common.NetworkEventReport.timestamp:type_name -> aalyria.spacetime.api.common.DateTime
	12, // 15: aalyria.spacetime.api.common.NetworkEventReport.radio_event:type_name -> aalyria.spacetime.api.common.RadioEvent
	13, // 16: aalyria.spacetime.api.common.NetworkEventReport.port_event:type_name -> aalyria.spacetime.api.common.PortEvent
	14, // 17: aalyria.spacetime.api.common.NetworkEventReport.interface_event:type_name -> aalyria.spacetime.api.common.InterfaceEvent
	1,  // 18: aalyria.spacetime.api.common.RadioEvent.link_status:type_name -> aalyria.spacetime.api.common.RadioEvent.LinkStatus
	2,  // 19: aalyria.spacetime.api.common.PortEvent.port_status:type_name -> aalyria.spacetime.api.common.PortEvent.PortStatus
	3,  // 20: aalyria.spacetime.api.common.InterfaceEvent.interface_status:type_name -> aalyria.spacetime.api.common.InterfaceEvent.InterfaceStatus
	8,  // 21: aalyria.spacetime.api.common.NetworkStatsReport.RadioStatsByInterfaceIdEntry.value:type_name -> aalyria.spacetime.api.common.RadioStats
	9,  // 22: aalyria.spacetime.api.common.NetworkStatsReport.InterfaceStatsByIdEntry.value:type_name -> aalyria.spacetime.api.common.InterfaceStats
	5,  // 23: aalyria.spacetime.api.common.NetworkStatsReport.BeamStatsByAntennaIdEntry.value:type_name -> aalyria.spacetime.api.common.BeamStats
	10, // 24: aalyria.spacetime.api.common.NetworkStatsReport.FlowStatsByIdEntry.value:type_name -> aalyria.spacetime.api.common.FlowStats
	22, // 25: aalyria.spacetime.api.common.BeamStats.TargetingStats.target_location:type_name -> aalyria.spacetime.api.common.GeodeticWgs84
	0,  // 26: aalyria.spacetime.api.common.BeamStats.TargetingStats.connection_status:type_name -> aalyria.spacetime.api.common.BeamStats.TargetingStats.ConnectionStatus
	22, // 27: aalyria.spacetime.api.common.BeamStats.GimbalStats.location:type_name -> aalyria.spacetime.api.common.GeodeticWgs84
	23, // 28: aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_quaternion:type_name -> aalyria.spacetime.api.common.Quaternion
	24, // 29: aalyria.spacetime.api.common.BeamStats.GimbalStats.orientation_ypr:type_name -> aalyria.spacetime.api.common.YawPitchRoll
	25, // 30: aalyria.spacetime.api.common.BeamStats.GimbalStats.pointing_vector:type_name -> aalyria.spacetime.api.common.PointingVector
	31, // [31:31] is the sub-list for method output_type
	31, // [31:31] is the sub-list for method input_type
	31, // [31:31] is the sub-list for extension type_name
	31, // [31:31] is the sub-list for extension extendee
	0,  // [0:31] is the sub-list for field type_name
}

func init() { file_api_common_telemetry_proto_init() }
func file_api_common_telemetry_proto_init() {
	if File_api_common_telemetry_proto != nil {
		return
	}
	file_api_common_coordinates_proto_init()
	file_api_common_time_proto_init()
	file_api_common_telemetry_proto_msgTypes[7].OneofWrappers = []any{
		(*NetworkEventReport_RadioEvent)(nil),
		(*NetworkEventReport_PortEvent)(nil),
		(*NetworkEventReport_InterfaceEvent)(nil),
	}
	file_api_common_telemetry_proto_msgTypes[8].OneofWrappers = []any{
		(*RadioEvent_TransmitterId)(nil),
		(*RadioEvent_ReceiverId)(nil),
		(*RadioEvent_LinkStatus_)(nil),
	}
	file_api_common_telemetry_proto_msgTypes[9].OneofWrappers = []any{
		(*PortEvent_PortStatus_)(nil),
	}
	file_api_common_telemetry_proto_msgTypes[10].OneofWrappers = []any{
		(*InterfaceEvent_InterfaceStatus_)(nil),
		(*InterfaceEvent_IpAddress)(nil),
	}
	file_api_common_telemetry_proto_msgTypes[16].OneofWrappers = []any{
		(*BeamStats_GimbalStats_OrientationQuaternion)(nil),
		(*BeamStats_GimbalStats_OrientationYpr)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_common_telemetry_proto_rawDesc), len(file_api_common_telemetry_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_api_common_telemetry_proto_goTypes,
		DependencyIndexes: file_api_common_telemetry_proto_depIdxs,
		EnumInfos:         file_api_common_telemetry_proto_enumTypes,
		MessageInfos:      file_api_common_telemetry_proto_msgTypes,
	}.Build()
	File_api_common_telemetry_proto = out.File
	file_api_common_telemetry_proto_goTypes = nil
	file_api_common_telemetry_proto_depIdxs = nil
}
