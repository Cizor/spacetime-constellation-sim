[
    {
        "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174",
        "repository_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
        "labels_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/labels{/name}",
        "comments_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/comments",
        "events_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/events",
        "html_url":  "https://github.com/Cizor/spacetime-constellation-sim/issues/174",
        "id":  3715148345,
        "node_id":  "I_kwDOQfMfks7dcKo5",
        "number":  174,
        "title":  "[Scope 4][Chunk 11] Epic – In-process gRPC SBI \u0026 Telemetry tests",
        "user":  {
                     "login":  "Cizor",
                     "id":  11782718,
                     "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                     "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                     "gravatar_id":  "",
                     "url":  "https://api.github.com/users/Cizor",
                     "html_url":  "https://github.com/Cizor",
                     "followers_url":  "https://api.github.com/users/Cizor/followers",
                     "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                     "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                     "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                     "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                     "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                     "repos_url":  "https://api.github.com/users/Cizor/repos",
                     "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                     "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                     "type":  "User",
                     "user_view_type":  "public",
                     "site_admin":  false
                 },
        "labels":  [
                       {
                           "id":  9738572054,
                           "node_id":  "LA_kwDOQfMfks8AAAACRHbRFg",
                           "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:tracking",
                           "name":  "type:tracking",
                           "color":  "4eaa16",
                           "default":  false,
                           "description":  ""
                       },
                       {
                           "id":  9782134341,
                           "node_id":  "LA_kwDOQfMfks8AAAACRw-GRQ",
                           "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
                           "name":  "scope:4-sbi",
                           "color":  "5a2e28",
                           "default":  false,
                           "description":  ""
                       },
                       {
                           "id":  9782141836,
                           "node_id":  "LA_kwDOQfMfks8AAAACRw-jjA",
                           "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:11-sbi-e2e",
                           "name":  "chunk:11-sbi-e2e",
                           "color":  "d68358",
                           "default":  false,
                           "description":  ""
                       }
                   ],
        "state":  "open",
        "locked":  false,
        "assignee":  {
                         "login":  "Cizor",
                         "id":  11782718,
                         "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                         "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                         "gravatar_id":  "",
                         "url":  "https://api.github.com/users/Cizor",
                         "html_url":  "https://github.com/Cizor",
                         "followers_url":  "https://api.github.com/users/Cizor/followers",
                         "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                         "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                         "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                         "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                         "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                         "repos_url":  "https://api.github.com/users/Cizor/repos",
                         "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                         "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                         "type":  "User",
                         "user_view_type":  "public",
                         "site_admin":  false
                     },
        "assignees":  [
                          {
                              "login":  "Cizor",
                              "id":  11782718,
                              "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                              "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                              "gravatar_id":  "",
                              "url":  "https://api.github.com/users/Cizor",
                              "html_url":  "https://github.com/Cizor",
                              "followers_url":  "https://api.github.com/users/Cizor/followers",
                              "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                              "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                              "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                              "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                              "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                              "repos_url":  "https://api.github.com/users/Cizor/repos",
                              "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                              "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                              "type":  "User",
                              "user_view_type":  "public",
                              "site_admin":  false
                          }
                      ],
        "milestone":  {
                          "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
                          "html_url":  "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
                          "labels_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
                          "id":  14244293,
                          "node_id":  "MI_kwDOQfMfks4A2VnF",
                          "number":  4,
                          "title":  "Scope 4 – Planning \u0026 Scheduling",
                          "description":  "",
                          "creator":  {
                                          "login":  "Cizor",
                                          "id":  11782718,
                                          "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                                          "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                                          "gravatar_id":  "",
                                          "url":  "https://api.github.com/users/Cizor",
                                          "html_url":  "https://github.com/Cizor",
                                          "followers_url":  "https://api.github.com/users/Cizor/followers",
                                          "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                                          "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                                          "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                                          "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                                          "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                                          "repos_url":  "https://api.github.com/users/Cizor/repos",
                                          "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                                          "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                                          "type":  "User",
                                          "user_view_type":  "public",
                                          "site_admin":  false
                                      },
                          "open_issues":  73,
                          "closed_issues":  0,
                          "state":  "open",
                          "created_at":  "2025-11-29T09:54:27Z",
                          "updated_at":  "2025-12-10T17:09:37Z",
                          "due_on":  null,
                          "closed_at":  null
                      },
        "comments":  0,
        "created_at":  "2025-12-10T13:11:02Z",
        "updated_at":  "2025-12-10T13:11:02Z",
        "closed_at":  null,
        "author_association":  "OWNER",
        "active_lock_reason":  null,
        "sub_issues_summary":  {
                                   "total":  2,
                                   "completed":  0,
                                   "percent_completed":  0
                               },
        "issue_dependencies_summary":  {
                                           "blocked_by":  0,
                                           "total_blocked_by":  0,
                                           "blocking":  0,
                                           "total_blocking":  0
                                       },
        "body":  "## Background\n\nBy the end of **Chunk 10**, you should have:\n\n- Core SBI / CDPI implementation:\n  - Controller-side `CDPIServer` implementing `ControlDataPlaneInterface.ReceiveRequests`.\n  - Simulated `Agent` implementation handling:\n    - `Hello`, `Reset`, `CreateEntry`, `DeleteEntry`, `Finalize`, (stubbed) `SetSrPolicy` / `DeleteSrPolicy`.\n  - Local per-agent schedule execution wired to `EventScheduler` + `ScenarioState`.\n- Telemetry path:\n  - `TelemetryServer` implementing `TelemetryService.ExportMetrics`.\n  - `TelemetryState` storing `InterfaceMetrics`.\n  - Agent-side telemetry loop using sim-time and `TelemetryServiceClient`.\n- Unit tests (Chunk 10) for:\n  - Agent schedule execution against fake schedulers / fake state.\n  - Scheduler logic (beam + route scheduling) in isolation.\n  - Telemetry model + agent telemetry loop behavior.\n\nWhat you **don’t** yet have is an end-to-end test that exercises:\n\n- Real gRPC plumbing (no fakes for CDPI / Telemetry services).\n- Real generated stubs on both sides (client + server).\n- The actual message flows:\n  - Agent → Controller:\n    - `Hello`, `Reset`, `Response`, `ExportMetrics`.\n  - Controller → Agent:\n    - `CreateEntryRequest`, `DeleteEntryRequest`, `FinalizeRequest`.\n\nChunk 11 focuses on **in-process gRPC integration tests** that:\n\n- Use the real generated SBI stubs.\n- Spin up a gRPC server in-process.\n- Register the **real** `CDPIServer` and `TelemetryServer`.\n- Drive a “test agent” built from the same agent implementation (or a thin wrapper).\n- Assert that:\n  - Schedule commands traverse CDPI correctly and cause expected KB changes.\n  - Telemetry metrics sent by the agent land in `TelemetryState`.\n\nThis provides a high-confidence, end-to-end “SBI+Telemetry smoke suite” before wiring into the full simulator CLI / scenario lifecycle in Chunk 9.\n\n## Goal\n\nDeliver a small but robust set of **in-process gRPC tests** that:\n\n- Bring up:\n  - A gRPC server with registered `CDPIServer` and `TelemetryServer`.\n  - One or more real `Agent` instances (or thin test harnesses) using generated SBI clients.\n- Exercise:\n  - The CDPI `ReceiveRequests` bidi stream end-to-end.\n  - A minimal schedule (e.g., `UpdateBeam` + `DeleteBeam`) executed via sim clock.\n  - Telemetry emission from the agent and storage in `TelemetryState`.\n- Assert:\n  - Correct association of `agent_id` ↔ `NodeID`.\n  - Proper `CreateEntry` → scheduled action → KB state change.\n  - Correct `Response` messages back to controller.\n  - Telemetry metrics appear in `TelemetryState` for the expected node/interface.\n\nThis epic tracks the **full Scope 4 SBI + telemetry integration tests**; individual sub-issues will focus on:\n\n- CDPI end-to-end tests.\n- Telemetry end-to-end tests.\n- Test harness / fixtures and any shared utilities.\n\n## Where to look\n\n- **CDPI implementation:**\n  - `internal/sbi/controller`:\n    - `cdpi_server.go` (or similar file implementing `ControlDataPlaneInterfaceServer`).\n    - Types:\n      - `CDPIServer`\n      - `AgentHandle`\n- **Agent implementation:**\n  - `internal/sbi/agent`:\n    - `agent.go` (core agent type + lifecycle).\n    - Fields:\n      - `State *simstate.ScenarioState`\n      - `Scheduler sbi.EventScheduler`\n      - `Stream scheduling.ControlDataPlaneInterface_ReceiveRequestsClient` (or equivalent).\n      - `TelemetryClient telemetry.TelemetryServiceClient` (for telemetry E2E).\n- **Telemetry server + state:**\n  - `internal/sbi/telemetry` / `sim/state` (depending on where you put them):\n    - `TelemetryState` with `UpdateMetrics` / `GetMetrics`.\n    - `TelemetryServer` implementing `TelemetryServiceServer`.\n- **Generated SBI stubs:**\n  - `internal/genproto/scheduling/v1alpha`\n  - `internal/genproto/telemetry/v1alpha`\n- **Time / scheduler:**\n  - `internal/sbi`:\n    - `EventScheduler` interface.\n    - Fake scheduler used in Chunk 10 tests (for deterministic control of sim time).\n\nSearch terms:\n\n- `ControlDataPlaneInterfaceServer`\n- `TelemetryServiceServer`\n- `ReceiveRequests`\n- `ExportMetrics`\n- `Agent struct`\n- `TelemetryState`\n- `grpc.NewServer`\n\n## Tasks\n\n### 11.1 – Test harness: in-process gRPC server setup\n\n- Create a dedicated test file, e.g.:\n\n  - `internal/sbi/controller/sbi_e2e_test.go`\n\n- Implement a helper to spin up an in-process gRPC server:\n\n  - Create a `grpc.Server`.\n  - Create `ScenarioState` (in-memory, simple topology).\n  - Construct:\n    - A real `CDPIServer` instance wired to that `ScenarioState`.\n    - A real `TelemetryState` and `TelemetryServer`.\n  - Register services:\n\n    - `scheduling.RegisterControlDataPlaneInterfaceServer(grpcServer, cdpiServer)`\n    - `telemetry.RegisterTelemetryServiceServer(grpcServer, telemetryServer)`\n\n  - Listen on a random local port (e.g. `net.Listen(\"tcp\", \"127.0.0.1:0\")`) and start serving in a goroutine.\n  - Expose:\n    - The server address.\n    - Pointers to `ScenarioState`, `TelemetryState`, and `CDPIServer` for assertions.\n\n- Provide a teardown function that:\n\n  - Gracefully stops the gRPC server.\n  - Cleans up any background goroutines if needed.\n\n### 11.2 – CDPI in-process E2E test (single agent, single link)\n\n- Use the harness to:\n\n  - Create a minimal `ScenarioState` with:\n    - Two nodes: `nodeA`, `nodeB`.\n    - Interfaces on each node that form a single potential link (wired or wireless).\n    - A stable `LinkID` for that link.\n\n- Start gRPC server with `CDPIServer` and `ScenarioState`.\n\n- In the test, create a **real CDPI client**:\n\n  - `conn, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithBlock())` (or `WithTransportCredentials(insecure.NewCredentials())`).\n  - `cli := scheduling.NewControlDataPlaneInterfaceClient(conn)`.\n\n- Create a test agent using real agent logic (or a small wrapper):\n\n  - Construct `Agent` with:\n    - `AgentID` and `NodeID` matching `nodeA`.\n    - `State` = shared `ScenarioState`.\n    - `Scheduler` = test-friendly implementation (may be a fake or real scheduler integrated with test time).\n    - CDPI client stream:\n      - `Stream, err := cli.ReceiveRequests(ctx)`.\n\n  - Call `agent.Start(ctx)` (or an equivalent method) to:\n    - Send `Hello(agent_id)`.\n    - Begin reading/writing on the CDPI stream.\n\n- Controller-side behavior:\n\n  - Use `CDPIServer` to send a `CreateEntry` for an `UpdateBeam` (or simple action) at a known sim time `T`.\n    - E.g., `cdpiServer.SendCreateEntry(agentID, scheduledUpdateBeamAction)`.\n\n- Use the **event scheduler / fake clock** to:\n\n  - Advance time to `T`.\n  - Ensure the agent executes the scheduled action.\n\n- Assertions:\n\n  - The relevant link in `ScenarioState` is marked active (`Active` / `StatusActive`).\n  - `CDPIServer` has observed a `Response` from the agent for that `request_id` (OK status).\n  - No panics or stream errors.\n\n### 11.3 – Telemetry in-process E2E test\n\n- Reuse / extend the same harness to include `TelemetryServer`:\n\n  - Ensure `TelemetryState` is accessible in the test for inspection.\n\n- Start agent with:\n\n  - A real `TelemetryServiceClient` constructed from the same `conn`:\n    - `tcli := telemetry.NewTelemetryServiceClient(conn)`.\n  - `TelemetryClient` field set on `Agent`.\n  - `TelemetryInterval` configured to a small value (e.g. 1s sim time).\n  - Scheduler used to drive `startTelemetryLoop`.\n\n- Ensure `ScenarioState`:\n\n  - Has at least one interface for `Agent.NodeID`.\n  - Marks the link/interface as `up` with a known bandwidth (for deterministic metrics).\n\n- Test flow:\n\n  1. Start agent + telemetry loop.\n  2. Advance fake scheduler time by one interval so that:\n     - `telemetryTick` runs.\n     - Agent calls `ExportMetrics` via gRPC to `TelemetryServer`.\n  3. Wait briefly (or use sync hooks) for the RPC to complete.\n\n- Assertions:\n\n  - `TelemetryState.GetMetrics(nodeID, ifaceID)` returns non-nil.\n  - `Up == true` for that interface.\n  - `BytesTx` \u003e 0 and roughly matches the simple `bandwidth * delta / 8` model used in the agent loop.\n  - Further time advances cause `BytesTx` to increase monotonically.\n\n### 11.4 – Error / edge-case behavior\n\nAdd focused E2E tests for:\n\n- **Agent disconnect / reconnect:**\n\n  - Simulate agent stream closure (cancel context).\n  - Ensure `CDPIServer` cleans up the associated `AgentHandle` without panicking.\n  - Optionally, start a new agent instance with the same `agent_id` and confirm Hello works.\n\n- **Token mismatch (optional at E2E level):**\n\n  - Manually send a `CreateEntry` with an incorrect `schedule_manipulation_token` (if easy to inject).\n  - Assert the agent logs/ignores it and does not update `ScenarioState`.\n\n- **Telemetry failure tolerance:**\n\n  - Temporarily stop the gRPC server or cause `ExportMetrics` to fail (e.g., by using a context timeout).\n  - Verify that:\n    - Agent does not panic.\n    - Telemetry loop continues on subsequent ticks once connectivity is restored (if reconnected).\n\n### 11.5 – Shared test utilities \u0026 documentation\n\n- Factor out common helpers into internal test-only files, for example:\n\n  - `internal/sbi/testutil/grpc_harness.go`:\n    - Functions to start/stop in-process gRPC servers with SBI services.\n  - `internal/sbi/testutil/fake_scheduler.go`:\n    - Reuse or refine the fake `EventScheduler` from Chunk 10.\n\n- Add minimal developer docs (e.g. in `docs/testing/sbi_e2e.md`) describing:\n\n  - How to run only these E2E tests, e.g.:\n\n    - `go test ./internal/sbi/controller -run TestSBI*`\n\n  - What they cover at a high level (CDPI + Telemetry end-to-end).\n\n## Acceptance criteria\n\n- **In-process gRPC harness:**\n  - A reusable helper sets up:\n    - `grpc.Server` bound to a loopback address.\n    - Registered `CDPIServer` + `TelemetryServer`.\n    - Shared `ScenarioState` + `TelemetryState`.\n  - Clean teardown without goroutine leaks or panics.\n\n- **CDPI E2E test:**\n  - Test(s) demonstrate:\n    - A real agent connecting via `ReceiveRequests`.\n    - `Hello(agent_id)` is processed and associated with a `NodeID`.\n    - Controller sends a `CreateEntry` for a scheduled `UpdateBeam` (or similar).\n    - When sim time reaches the scheduled instant:\n      - `ScenarioState` reflects the expected link/beam activation.\n      - Controller receives a `Response` with OK status for the `request_id`.\n  - Tests run deterministically using a fake or well-controlled `EventScheduler`.\n\n- **Telemetry E2E test:**\n  - Agent uses a real `TelemetryServiceClient` to call `ExportMetrics`.\n  - `TelemetryState` stores at least one `InterfaceMetrics` entry for the agent’s node/interface.\n  - Metrics fields are sane:\n    - `Up` correctly reflects interface state.\n    - `BytesTx` increases monotonically over multiple telemetry ticks.\n  - No crashes when telemetry RPC fails; failures are tolerated as per design.\n\n- **Edge-case behavior:**\n  - Tests cover:\n    - Agent stream closure and controller cleanup.\n    - Basic token-mismatch behavior (if feasible).\n    - Telemetry RPC failure without agent collapse.\n  - All such tests pass reliably.\n\n- **Repository health:**\n  - `go test ./...` passes, including new E2E tests.\n  - E2E tests are reasonably fast (suitable for CI) or clearly marked and isolated (e.g. via test names or build tags).\n",
        "closed_by":  null,
        "reactions":  {
                          "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/reactions",
                          "total_count":  0,
                          "+1":  0,
                          "-1":  0,
                          "laugh":  0,
                          "hooray":  0,
                          "confused":  0,
                          "heart":  0,
                          "rocket":  0,
                          "eyes":  0
                      },
        "timeline_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174/timeline",
        "performed_via_github_app":  null,
        "state_reason":  null
    },
    {
        "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/176",
        "repository_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
        "labels_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/176/labels{/name}",
        "comments_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/176/comments",
        "events_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/176/events",
        "html_url":  "https://github.com/Cizor/spacetime-constellation-sim/issues/176",
        "id":  3715205191,
        "node_id":  "I_kwDOQfMfks7dcYhH",
        "number":  176,
        "title":  "[Scope 4][Chunk 11] In-process CDPI gRPC integration test (controller ↔ agent)",
        "user":  {
                     "login":  "Cizor",
                     "id":  11782718,
                     "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                     "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                     "gravatar_id":  "",
                     "url":  "https://api.github.com/users/Cizor",
                     "html_url":  "https://github.com/Cizor",
                     "followers_url":  "https://api.github.com/users/Cizor/followers",
                     "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                     "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                     "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                     "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                     "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                     "repos_url":  "https://api.github.com/users/Cizor/repos",
                     "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                     "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                     "type":  "User",
                     "user_view_type":  "public",
                     "site_admin":  false
                 },
        "labels":  [
                       {
                           "id":  9737891558,
                           "node_id":  "LA_kwDOQfMfks8AAAACRGxu5g",
                           "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
                           "name":  "type:test",
                           "color":  "3c874f",
                           "default":  false,
                           "description":  ""
                       },
                       {
                           "id":  9782134341,
                           "node_id":  "LA_kwDOQfMfks8AAAACRw-GRQ",
                           "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
                           "name":  "scope:4-sbi",
                           "color":  "5a2e28",
                           "default":  false,
                           "description":  ""
                       },
                       {
                           "id":  9782141836,
                           "node_id":  "LA_kwDOQfMfks8AAAACRw-jjA",
                           "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:11-sbi-e2e",
                           "name":  "chunk:11-sbi-e2e",
                           "color":  "d68358",
                           "default":  false,
                           "description":  ""
                       }
                   ],
        "state":  "open",
        "locked":  false,
        "assignee":  {
                         "login":  "Cizor",
                         "id":  11782718,
                         "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                         "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                         "gravatar_id":  "",
                         "url":  "https://api.github.com/users/Cizor",
                         "html_url":  "https://github.com/Cizor",
                         "followers_url":  "https://api.github.com/users/Cizor/followers",
                         "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                         "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                         "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                         "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                         "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                         "repos_url":  "https://api.github.com/users/Cizor/repos",
                         "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                         "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                         "type":  "User",
                         "user_view_type":  "public",
                         "site_admin":  false
                     },
        "assignees":  [
                          {
                              "login":  "Cizor",
                              "id":  11782718,
                              "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                              "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                              "gravatar_id":  "",
                              "url":  "https://api.github.com/users/Cizor",
                              "html_url":  "https://github.com/Cizor",
                              "followers_url":  "https://api.github.com/users/Cizor/followers",
                              "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                              "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                              "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                              "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                              "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                              "repos_url":  "https://api.github.com/users/Cizor/repos",
                              "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                              "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                              "type":  "User",
                              "user_view_type":  "public",
                              "site_admin":  false
                          }
                      ],
        "milestone":  {
                          "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
                          "html_url":  "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
                          "labels_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
                          "id":  14244293,
                          "node_id":  "MI_kwDOQfMfks4A2VnF",
                          "number":  4,
                          "title":  "Scope 4 – Planning \u0026 Scheduling",
                          "description":  "",
                          "creator":  {
                                          "login":  "Cizor",
                                          "id":  11782718,
                                          "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                                          "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                                          "gravatar_id":  "",
                                          "url":  "https://api.github.com/users/Cizor",
                                          "html_url":  "https://github.com/Cizor",
                                          "followers_url":  "https://api.github.com/users/Cizor/followers",
                                          "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                                          "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                                          "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                                          "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                                          "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                                          "repos_url":  "https://api.github.com/users/Cizor/repos",
                                          "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                                          "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                                          "type":  "User",
                                          "user_view_type":  "public",
                                          "site_admin":  false
                                      },
                          "open_issues":  73,
                          "closed_issues":  0,
                          "state":  "open",
                          "created_at":  "2025-11-29T09:54:27Z",
                          "updated_at":  "2025-12-10T17:09:37Z",
                          "due_on":  null,
                          "closed_at":  null
                      },
        "comments":  0,
        "created_at":  "2025-12-10T13:26:43Z",
        "updated_at":  "2025-12-10T13:26:48Z",
        "closed_at":  null,
        "author_association":  "OWNER",
        "active_lock_reason":  null,
        "sub_issues_summary":  {
                                   "total":  0,
                                   "completed":  0,
                                   "percent_completed":  0
                               },
        "parent_issue_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174",
        "issue_dependencies_summary":  {
                                           "blocked_by":  0,
                                           "total_blocked_by":  0,
                                           "blocking":  0,
                                           "total_blocking":  0
                                       },
        "body":  "## Background\n\nBy this point in **Scope 4** you should have:\n\n- A working **CDPI server** on the controller side:\n  - `ControlDataPlaneInterface.ReceiveRequests` implemented in something like `internal/sbi/controller/cdpi_server.go`.\n  - Per-agent tracking (`AgentHandle`) with:\n    - Agent ID / Node ID.\n    - A server-side gRPC stream.\n    - An outgoing channel for controller→agent messages.\n    - A `schedule_manipulation_token`.\n\n- A simulated **Agent** implementation:\n  - Connects to the CDPI server via the generated client stub.\n  - Sends:\n    - Initial `Hello` (with `agent_id`).\n    - `Reset` when (re)starting.\n    - `Response` messages when actions are executed.\n  - Receives:\n    - `CreateEntryRequest` / `DeleteEntryRequest`.\n    - `FinalizeRequest`.\n    - (Optionally) `SetSrPolicy` / `DeleteSrPolicy`.\n  - Maintains a local schedule using `EventScheduler` and executes:\n    - Beam actions (Update/Delete).\n    - Route actions (Set/Delete).\n  - Writes to `ScenarioState` via your helper methods.\n\n- A testable **EventScheduler**:\n  - Real implementation backed by the sim clock (Scope 4 core).\n  - A **fake** implementation for tests (manual time control, deterministic execution).\n\nThe earlier unit tests in **Chunk 10** focused on individual components:\n\n- Agent unit tests:\n  - Scheduling execution with fake scheduler and fake state.\n- Controller unit tests:\n  - CDPI server logic with fake agents.\n- Telemetry unit tests (separate epic).\n\nWhat is still missing is a **single in-process gRPC integration test** that:\n\n- Spins up a real gRPC server in memory.\n- Registers the **real CDPI server**.\n- Uses the **real generated CDPI client stub** on the agent side.\n- Wires an Agent to talk over that gRPC channel.\n- Drives a simple scenario end-to-end:\n  - Agent connects and sends `Hello`.\n  - Controller registers the agent.\n  - Controller sends a `CreateEntryRequest` for a scheduled action (e.g. `UpdateBeam`).\n  - Fake sim clock advances to the action time.\n  - Agent executes the action against a fake `ScenarioState`.\n  - Agent sends a `Response` back to the controller.\n  - Test asserts that:\n    - The KB state is updated as expected.\n    - The response reached the controller with correct metadata.\n\nThis issue builds confidence that **CDPI wiring, stream semantics, and schedule execution** all work together when using real gRPC stubs.\n\n## Goal\n\nImplement a **single in-process end-to-end test** for CDPI that:\n\n- Uses a real gRPC server and the generated CDPI stubs.\n- Instantiates:\n  - A real `CDPIServer` (controller side).\n  - A real `Agent` configured with:\n    - CDPI client.\n    - Fake `EventScheduler`.\n    - Fake `ScenarioState`.\n- Drives a minimal scenario:\n\n  - Agent connects and sends `Hello`.\n  - Controller registers the stream for that agent.\n  - Controller sends a `CreateEntryRequest` with an `UpdateBeam` scheduled at time `T`.\n  - Fake clock advances to `T`.\n  - Agent executes the action:\n    - Calls an `ApplyBeamUpdate`-like helper on `ScenarioState`.\n    - Sends back a `Response` with `Status = OK`.\n  - Controller receives the `Response`.\n\n- Asserts:\n\n  - `ScenarioState` recorded the expected beam/link update.\n  - `Response` has:\n    - Matching `request_id`.\n    - Matching `agent_id`.\n    - `Status` indicating success.\n\nThis test doesn’t need to be exhaustive; it should be a **golden happy-path** proving that:\n\n- gRPC plumbing is correct.\n- Stream semantics are followed (Hello first, then main loop).\n- Scheduler → CDPI → Agent → ScenarioState → Agent → CDPI response round-trip works.\n\n## Where to look\n\n- CDPI server implementation:\n\n  - Something like:\n\n        internal/sbi/controller/cdpi_server.go\n\n  - Types to expect:\n\n        type CDPIServer struct {\n            scheduling.UnimplementedControlDataPlaneInterfaceServer\n\n            State    *simstate.ScenarioState\n            Clock    sbi.EventScheduler\n            agentsMu sync.RWMutex\n            agents   map[string]*AgentHandle\n        }\n\n        type AgentHandle struct {\n            AgentID  string\n            NodeID   string\n            Stream   scheduling.ControlDataPlaneInterface_ReceiveRequestsServer\n            outgoing chan *scheduling.ReceiveRequestsMessageFromController\n            token    string\n        }\n\n  - `ReceiveRequests` RPC implementation.\n\n- Agent implementation:\n\n  - Something like:\n\n        internal/sbi/agent/agent.go\n\n  - Types and methods:\n\n        type Agent struct {\n            AgentID   string\n            NodeID    string\n            State     *simstate.ScenarioState\n            Scheduler sbi.EventScheduler\n\n            CDPIClient scheduling.ControlDataPlaneInterfaceClient\n            // plus telemetry, logging, etc.\n        }\n\n        func (a *Agent) Start(ctx context.Context) error\n        func (a *Agent) Stop()\n\n  - The loop that:\n    - Sends `Hello`.\n    - Reads controller messages.\n    - Schedules actions via `EventScheduler`.\n\n- Fake implementations:\n\n  - Fake `ScenarioState` used in unit tests under `internal/sbi` or `internal/sim/state` tests.\n  - Fake `EventScheduler` from earlier chunks:\n    - Manually advance time and fire events.\n\n- Generated stubs:\n\n  - CDPI protos:\n\n        internal/genproto/scheduling/v1alpha\n        // Or similar path that contains:\n        //   ControlDataPlaneInterfaceClient\n        //   ControlDataPlaneInterfaceServer\n        //   ReceiveRequestsMessageFromController / FromAgent\n\n- Test harness patterns:\n\n  - Other in-process gRPC tests already present (if any), e.g. NBI tests.\n  - How `grpc.NewServer` and `grpc.Dial` are used for in-process tests.\n\nSearch terms:\n\n- `ControlDataPlaneInterface`\n- `ReceiveRequests`\n- `Agent struct`\n- `AgentHandle`\n- `FakeEventScheduler`\n- `ApplyBeamUpdate` / `InstallRoute` / similar helpers\n- `grpc.NewServer` in tests\n\n## Tasks\n\n### 1. Define test skeleton\n\n- Create a new test file, e.g.:\n\n      internal/sbi/controller/cdpi_integration_test.go\n\n- Add a top-level test function:\n\n      func TestCDPIEndToEnd_UpdateBeam(t *testing.T) {\n          // arrange\n          // act\n          // assert\n      }\n\n- Use `testing.T` only; no external dependencies.\n\n### 2. Set up in-process gRPC server and CDPIServer\n\nInside `TestCDPIEndToEnd_UpdateBeam`:\n\n- Create an in-memory gRPC server:\n\n      lis := bufconn.Listen(1024 * 1024)\n      grpcServer := grpc.NewServer()\n      t.Cleanup(grpcServer.Stop)\n\n- Create a fake or lightweight `ScenarioState`:\n\n      fakeState := newFakeScenarioState() // implement as a test helper\n\n  - Requirements:\n\n    - Track when `ApplyBeamUpdate` (or equivalent) is called.\n    - Optionally store parameters (node ID, interface ID, target, etc.).\n\n- Create a fake or simple `EventScheduler`:\n\n      sched := NewFakeEventScheduler() // test helper from earlier chunks\n\n  - Must support:\n\n    - `Now()` (start at `T0`).\n    - `Schedule(at time.Time, f func())`.\n    - `AdvanceTo(t time.Time)` (execute pending events).\n\n- Instantiate a `CDPIServer`:\n\n      cdpiServer := \u0026CDPIServer{\n          State:  fakeState,\n          Clock:  sched,\n          agents: make(map[string]*AgentHandle),\n      }\n\n- Register the server on gRPC:\n\n      scheduling.RegisterControlDataPlaneInterfaceServer(grpcServer, cdpiServer)\n\n- Start the server in a goroutine:\n\n      go func() {\n          if err := grpcServer.Serve(lis); err != nil {\n              t.Fatalf(\"Serve failed: %v\", err)\n          }\n      }()\n\n### 3. Create in-process CDPI client and Agent\n\n- Set up a `grpc.ClientConn` using `bufconn.Dialer`:\n\n      ctx := context.Background()\n      conn, err := grpc.DialContext(\n          ctx,\n          \"bufnet\",\n          grpc.WithContextDialer(func(ctx context.Context, s string) (net.Conn, error) {\n              return lis.Dial()\n          }),\n          grpc.WithInsecure(),\n      )\n      if err != nil {\n          t.Fatalf(\"DialContext failed: %v\", err)\n      }\n      t.Cleanup(func() { _ = conn.Close() })\n\n- Create CDPI client:\n\n      cdpiClient := scheduling.NewControlDataPlaneInterfaceClient(conn)\n\n- Instantiate an `Agent`:\n\n      agent := \u0026Agent{\n          AgentID:   \"agent-1\",\n          NodeID:    \"node-1\",\n          State:     fakeState,\n          Scheduler: sched,\n          // plus any necessary logging\n          CDPIClient: cdpiClient,\n      }\n\n- Start the agent in a goroutine:\n\n      agentCtx, cancelAgent := context.WithCancel(ctx)\n      t.Cleanup(cancelAgent)\n\n      go func() {\n          if err := agent.Start(agentCtx); err != nil {\n              t.Errorf(\"agent.Start error: %v\", err)\n          }\n      }()\n\n- Ensure the agent sends `Hello` and the CDPI server registers it:\n\n  - Option 1: use a small `sched.AdvanceTo(...)` or `time.Sleep` (if needed) to allow the handshake.\n  - Option 2: expose a hook or accessor on `CDPIServer` for tests to wait until `agents[\"agent-1\"]` exists.\n\n### 4. Inject a scheduled `UpdateBeam` via CDPIServer\n\n- Once the agent is registered on `cdpiServer`:\n\n  - Create a simple `ScheduledAction`:\n\n        when := sched.Now().Add(10 * time.Second)\n        action := \u0026ScheduledAction{\n            EntryID:  \"entry-1\",\n            When:     when,\n            Type:     ScheduledUpdateBeam,\n            RequestID: \"req-1\",\n            // minimal BeamSpec payload:\n            Beam: \u0026BeamSpec{\n                NodeID:      \"node-1\",\n                InterfaceID: \"if-1\",\n                // other fields as needed by ApplyBeamUpdate\n            },\n        }\n\n  - Use a controller helper to send it:\n\n        if err := cdpiServer.SendCreateEntry(\"agent-1\", action); err != nil {\n            t.Fatalf(\"SendCreateEntry failed: %v\", err)\n        }\n\n- The agent should:\n\n  - Receive the `CreateEntryRequest` on its stream.\n  - Convert it to `ScheduledAction`.\n  - Call `Scheduler.Schedule(when, func() { a.execute(action) })`.\n\n### 5. Advance fake clock and execute scheduled action\n\n- Advance the fake scheduler to (or past) the scheduled time:\n\n      sched.AdvanceTo(when)\n\n  - `AdvanceTo` should:\n\n    - Update internal `now`.\n    - Run all events with `When \u003c= now`.\n    - This will trigger the agent’s `execute(action)`.\n\n- In the agent’s `execute` implementation, ensure:\n\n  - `ScenarioState.ApplyBeamUpdate(...)` (or equivalent) is called.\n  - A `Response` is sent back to the controller via the CDPI stream.\n\n### 6. Assert state updates and response delivery\n\n- On the **state** side, assert:\n\n  - `fakeState` recorded exactly one beam update:\n\n        if got := fakeState.BeamUpdates(); len(got) != 1 {\n            t.Fatalf(\"expected 1 beam update, got %d\", len(got))\n        }\n\n  - Verify details:\n\n        upd := got[0]\n        if upd.NodeID != \"node-1\" || upd.InterfaceID != \"if-1\" {\n            t.Errorf(\"unexpected beam update: %+v\", upd)\n        }\n\n- On the **controller** side, capture `Response` messages:\n\n  - Option 1: extend `CDPIServer` in tests to record received Responses (e.g. via a callback or a channel).\n  - Option 2: embed a test-only hook in `CDPIServer` compiled with `//go:build test`.\n\n  - For example:\n\n        type CDPIServer struct {\n            // ...\n            responsesMu sync.Mutex\n            responses   []*scheduling.ReceiveRequestsMessageFromAgent\n        }\n\n        func (s *CDPIServer) recordResponse(msg *scheduling.ReceiveRequestsMessageFromAgent) {\n            s.responsesMu.Lock()\n            defer s.responsesMu.Unlock()\n            s.responses = append(s.responses, msg)\n        }\n\n- In the test, after `sched.AdvanceTo(when)`, assert:\n\n  - Exactly one `Response` was recorded.\n  - It has the expected `request_id` and status:\n\n        resps := cdpiServer.Responses() // test accessor\n        if len(resps) != 1 {\n            t.Fatalf(\"expected 1 response, got %d\", len(resps))\n        }\n\n        resp := resps[0].GetResponse()\n        if resp.GetRequestId() != \"req-1\" {\n            t.Errorf(\"unexpected request_id in response: %q\", resp.GetRequestId())\n        }\n        if resp.GetStatus().GetCode() != scheduling.Status_OK {\n            t.Errorf(\"unexpected status in response: %v\", resp.GetStatus())\n        }\n\n### 7. Add small helpers / fakes for tests\n\n- Implement a minimal `fakeScenarioState` in the test file (or a small `_test.go` helper):\n\n      type fakeScenarioState struct {\n          mu          sync.Mutex\n          beamUpdates []BeamUpdateRecord\n      }\n\n      type BeamUpdateRecord struct {\n          NodeID      string\n          InterfaceID string\n          // other fields as needed\n      }\n\n      func (f *fakeScenarioState) ApplyBeamUpdate(nodeID string, spec BeamSpec) error {\n          f.mu.Lock()\n          defer f.mu.Unlock()\n          f.beamUpdates = append(f.beamUpdates, BeamUpdateRecord{\n              NodeID:      nodeID,\n              InterfaceID: spec.InterfaceID,\n          })\n          return nil\n      }\n\n      func (f *fakeScenarioState) BeamUpdates() []BeamUpdateRecord {\n          f.mu.Lock()\n          defer f.mu.Unlock()\n          out := make([]BeamUpdateRecord, len(f.beamUpdates))\n          copy(out, f.beamUpdates)\n          return out\n      }\n\n- Ensure the fake scheduler is deterministic and can be reused from earlier tests if possible.\n\n## Acceptance criteria\n\n- Test coverage:\n\n  - A new test `TestCDPIEndToEnd_UpdateBeam` exists under `internal/sbi/controller` (or equivalent SBI package).\n  - The test:\n    - Spins up an in-process gRPC server.\n    - Registers the real `CDPIServer`.\n    - Starts a real `Agent` using the generated CDPI client stub.\n    - Injects a `CreateEntryRequest` for a scheduled `UpdateBeam`.\n    - Uses a fake scheduler to advance sim time and trigger execution.\n\n- Behaviour:\n\n  - Agent sends `Hello` and is registered on the CDPI server.\n  - CDPI server successfully sends `CreateEntryRequest` to the agent.\n  - Agent schedules and executes the action at the right simulated time.\n  - `ScenarioState.ApplyBeamUpdate` (or equivalent) is called once with expected parameters.\n  - Agent sends a `Response` back to the controller.\n  - CDPI server receives and records the `Response` with:\n    - Correct `request_id`.\n    - `Status` indicating success.\n\n- Test design:\n\n  - Uses real generated gRPC stubs for CDPI (no hand-rolled fakes for the stream).\n  - Uses test doubles only for:\n    - `ScenarioState`.\n    - `EventScheduler`.\n    - Optional logging.\n  - The test is deterministic:\n    - Relies on fake scheduler and/or `bufconn`, not wall-clock sleeps where avoidable.\n\n- Repository health:\n\n  - `go test ./...` passes, including the new CDPI integration test.\n  - No race conditions introduced by test code (run `go test -race` cleanly, if used).\n",
        "closed_by":  null,
        "reactions":  {
                          "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/176/reactions",
                          "total_count":  0,
                          "+1":  0,
                          "-1":  0,
                          "laugh":  0,
                          "hooray":  0,
                          "confused":  0,
                          "heart":  0,
                          "rocket":  0,
                          "eyes":  0
                      },
        "timeline_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/176/timeline",
        "performed_via_github_app":  null,
        "state_reason":  null
    },
    {
        "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/177",
        "repository_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim",
        "labels_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/177/labels{/name}",
        "comments_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/177/comments",
        "events_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/177/events",
        "html_url":  "https://github.com/Cizor/spacetime-constellation-sim/issues/177",
        "id":  3715248710,
        "node_id":  "I_kwDOQfMfks7dcjJG",
        "number":  177,
        "title":  "[Scope 4][Chunk 11] Add in-process TelemetryService.ExportMetrics gRPC test",
        "user":  {
                     "login":  "Cizor",
                     "id":  11782718,
                     "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                     "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                     "gravatar_id":  "",
                     "url":  "https://api.github.com/users/Cizor",
                     "html_url":  "https://github.com/Cizor",
                     "followers_url":  "https://api.github.com/users/Cizor/followers",
                     "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                     "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                     "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                     "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                     "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                     "repos_url":  "https://api.github.com/users/Cizor/repos",
                     "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                     "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                     "type":  "User",
                     "user_view_type":  "public",
                     "site_admin":  false
                 },
        "labels":  [
                       {
                           "id":  9737891558,
                           "node_id":  "LA_kwDOQfMfks8AAAACRGxu5g",
                           "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/type:test",
                           "name":  "type:test",
                           "color":  "3c874f",
                           "default":  false,
                           "description":  ""
                       },
                       {
                           "id":  9782134341,
                           "node_id":  "LA_kwDOQfMfks8AAAACRw-GRQ",
                           "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/scope:4-sbi",
                           "name":  "scope:4-sbi",
                           "color":  "5a2e28",
                           "default":  false,
                           "description":  ""
                       },
                       {
                           "id":  9782141836,
                           "node_id":  "LA_kwDOQfMfks8AAAACRw-jjA",
                           "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/labels/chunk:11-sbi-e2e",
                           "name":  "chunk:11-sbi-e2e",
                           "color":  "d68358",
                           "default":  false,
                           "description":  ""
                       }
                   ],
        "state":  "open",
        "locked":  false,
        "assignee":  {
                         "login":  "Cizor",
                         "id":  11782718,
                         "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                         "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                         "gravatar_id":  "",
                         "url":  "https://api.github.com/users/Cizor",
                         "html_url":  "https://github.com/Cizor",
                         "followers_url":  "https://api.github.com/users/Cizor/followers",
                         "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                         "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                         "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                         "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                         "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                         "repos_url":  "https://api.github.com/users/Cizor/repos",
                         "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                         "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                         "type":  "User",
                         "user_view_type":  "public",
                         "site_admin":  false
                     },
        "assignees":  [
                          {
                              "login":  "Cizor",
                              "id":  11782718,
                              "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                              "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                              "gravatar_id":  "",
                              "url":  "https://api.github.com/users/Cizor",
                              "html_url":  "https://github.com/Cizor",
                              "followers_url":  "https://api.github.com/users/Cizor/followers",
                              "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                              "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                              "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                              "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                              "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                              "repos_url":  "https://api.github.com/users/Cizor/repos",
                              "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                              "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                              "type":  "User",
                              "user_view_type":  "public",
                              "site_admin":  false
                          }
                      ],
        "milestone":  {
                          "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4",
                          "html_url":  "https://github.com/Cizor/spacetime-constellation-sim/milestone/4",
                          "labels_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/milestones/4/labels",
                          "id":  14244293,
                          "node_id":  "MI_kwDOQfMfks4A2VnF",
                          "number":  4,
                          "title":  "Scope 4 – Planning \u0026 Scheduling",
                          "description":  "",
                          "creator":  {
                                          "login":  "Cizor",
                                          "id":  11782718,
                                          "node_id":  "MDQ6VXNlcjExNzgyNzE4",
                                          "avatar_url":  "https://avatars.githubusercontent.com/u/11782718?v=4",
                                          "gravatar_id":  "",
                                          "url":  "https://api.github.com/users/Cizor",
                                          "html_url":  "https://github.com/Cizor",
                                          "followers_url":  "https://api.github.com/users/Cizor/followers",
                                          "following_url":  "https://api.github.com/users/Cizor/following{/other_user}",
                                          "gists_url":  "https://api.github.com/users/Cizor/gists{/gist_id}",
                                          "starred_url":  "https://api.github.com/users/Cizor/starred{/owner}{/repo}",
                                          "subscriptions_url":  "https://api.github.com/users/Cizor/subscriptions",
                                          "organizations_url":  "https://api.github.com/users/Cizor/orgs",
                                          "repos_url":  "https://api.github.com/users/Cizor/repos",
                                          "events_url":  "https://api.github.com/users/Cizor/events{/privacy}",
                                          "received_events_url":  "https://api.github.com/users/Cizor/received_events",
                                          "type":  "User",
                                          "user_view_type":  "public",
                                          "site_admin":  false
                                      },
                          "open_issues":  73,
                          "closed_issues":  0,
                          "state":  "open",
                          "created_at":  "2025-11-29T09:54:27Z",
                          "updated_at":  "2025-12-10T17:09:37Z",
                          "due_on":  null,
                          "closed_at":  null
                      },
        "comments":  0,
        "created_at":  "2025-12-10T13:38:43Z",
        "updated_at":  "2025-12-10T13:38:43Z",
        "closed_at":  null,
        "author_association":  "OWNER",
        "active_lock_reason":  null,
        "sub_issues_summary":  {
                                   "total":  0,
                                   "completed":  0,
                                   "percent_completed":  0
                               },
        "parent_issue_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/174",
        "issue_dependencies_summary":  {
                                           "blocked_by":  0,
                                           "total_blocked_by":  0,
                                           "blocking":  0,
                                           "total_blocking":  0
                                       },
        "body":  "## Background\n\nBy this point in **Scope 4** you should have:\n\n- A `TelemetryServer` implementing the SBI `TelemetryService`, with:\n  - `ExportMetrics(ctx, *ExportMetricsRequest)` updating an internal `TelemetryState`.\n- An internal telemetry model:\n  - `InterfaceMetrics` (node/interface ID, `Up`, `BytesTx`, optional RF fields).\n  - `TelemetryState` with concurrency-safe `UpdateMetrics` / `GetMetrics`.\n- Agent-side telemetry loop (Chunk 6):\n  - Agents periodically compute per-interface metrics using **simulation time**.\n  - Agents call the SBI telemetry client:\n    - `TelemetryServiceClient.ExportMetrics(ctx, req)`.\n\nYou also have the **CDPI in-process test** from earlier Chunk 11 work, which proves:\n\n- An in-process gRPC server can host SBI services.\n- Agents can connect and exercise CDPI flows in tests.\n\nWhat’s missing is a **dedicated in-process gRPC test** for Telemetry:\n\n- Spin up a real `TelemetryServer` on an in-process gRPC server.\n- Use the **real generated Telemetry client stub**.\n- Simulate one or more `ExportMetrics` calls.\n- Assert that `TelemetryState` is updated as expected.\n\nThis test gives you confidence that:\n\n- Protos, server registration, and client stubs are wired correctly.\n- Controller-side telemetry storage behaves correctly over real gRPC.\n\n## Goal\n\nAdd a focused **in-process gRPC integration test** that:\n\n- Starts a gRPC server in-process and registers `TelemetryServer`.\n- Constructs a real `TelemetryServiceClient` using the generated stub.\n- Sends one or more `ExportMetricsRequest` messages with realistic `InterfaceMetrics` entries.\n- Verifies that `TelemetryState` contains the expected metrics after each call.\n\nThe test should be:\n\n- Deterministic and self-contained (no external ports or network).\n- Fast enough to run as part of `go test ./...`.\n- Structured similarly to the CDPI in-process test for consistency.\n\n## Where to look\n\n- **Telemetry server and state:**\n  - `TelemetryState` definition and methods:\n    - `NewTelemetryState()`\n    - `UpdateMetrics(m *InterfaceMetrics)`\n    - `GetMetrics(nodeID, ifaceID string) *InterfaceMetrics`\n  - `TelemetryServer` implementation:\n    - Likely under:\n      - `internal/sbi/telemetry`\n      - or `internal/sbi/controller/telemetry_server.go`\n    - Expected shape:\n\n          type TelemetryServer struct {\n              telemetry.UnimplementedTelemetryServiceServer\n              Telemetry *TelemetryState\n              Logger    Logger // optional\n          }\n\n- **Generated Telemetry protos:**\n  - Under something like:\n\n        internal/genproto/telemetry/v1alpha\n\n  - Look for:\n    - `TelemetryServiceServer`\n    - `TelemetryServiceClient`\n    - `ExportMetricsRequest`\n    - `ExportMetricsResponse`\n    - `InterfaceMetrics` proto message.\n\n- **Existing in-process gRPC patterns (CDPI test):**\n  - Under something like:\n    - `internal/sbi/controller/cdpi_integration_test.go`\n  - You can mirror:\n    - Creating a `grpc.Server`.\n    - Registering a service.\n    - Dialling it via `grpc.DialContext` and an in-memory listener.\n    - Using the generated client to exercise RPCs.\n\n- **Telemetry model tests (if any from Chunk 6):**\n  - `internal/sbi/telemetry_state_test.go` or similar, for how to assert against `TelemetryState`.\n\nSearch terms:\n\n- `TelemetryServer`\n- `ExportMetrics`\n- `TelemetryServiceClient`\n- `NewTelemetryState`\n- `cdpi_integration_test`\n\n## Tasks\n\n### 1. Create Telemetry integration test file\n\n- Add a new test file, for example:\n\n      internal/sbi/telemetry_integration_test.go\n\n- Package should match where the Telemetry server lives (e.g. `package sbi` or `package controller`).\n\n- Add standard test imports:\n\n      import (\n          \"context\"\n          \"net\"\n          \"testing\"\n          \"time\"\n\n          \"google.golang.org/grpc\"\n\n          telemetrypb \"github.com/yourorg/yourrepo/internal/genproto/telemetry/v1alpha\"\n      )\n\n### 2. Spin up in-process gRPC server with TelemetryServer\n\n- In the test, create:\n\n      func newTestTelemetryServer(t *testing.T) (addr string, shutdown func(), telemetryState *TelemetryState) {\n          t.Helper()\n\n          lis, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n          if err != nil {\n              t.Fatalf(\"listen: %v\", err)\n          }\n\n          grpcServer := grpc.NewServer()\n\n          telemetryState = NewTelemetryState()\n\n          srv := \u0026TelemetryServer{\n              Telemetry: telemetryState,\n              // Logger: optional test logger\n          }\n\n          telemetrypb.RegisterTelemetryServiceServer(grpcServer, srv)\n\n          go func() {\n              if err := grpcServer.Serve(lis); err != nil {\n                  // Optionally log; avoid t.Fatalf from goroutine.\n              }\n          }()\n\n          shutdown = func() {\n              grpcServer.GracefulStop()\n              lis.Close()\n          }\n\n          return lis.Addr().String(), shutdown, telemetryState\n      }\n\n- Use an ephemeral `127.0.0.1:0` port so tests don’t collide on hard-coded ports.\n\n### 3. Create TelemetryService client connected to test server\n\n- In the test, dial the server:\n\n      func newTelemetryClient(t *testing.T, addr string) telemetrypb.TelemetryServiceClient {\n          t.Helper()\n\n          ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n          t.Cleanup(cancel)\n\n          conn, err := grpc.DialContext(\n              ctx,\n              addr,\n              grpc.WithInsecure(),           // or grpc.WithTransportCredentials(insecure.NewCredentials())\n              grpc.WithBlock(),\n          )\n          if err != nil {\n              t.Fatalf(\"grpc dial: %v\", err)\n          }\n\n          t.Cleanup(func() {\n              conn.Close()\n          })\n\n          return telemetrypb.NewTelemetryServiceClient(conn)\n      }\n\n- Use `t.Cleanup` to ensure both the connection and server are shut down at the end of the test.\n\n### 4. Happy-path ExportMetrics integration test\n\n- Add a test like:\n\n      func TestTelemetryExportMetrics_Integration(t *testing.T) {\n          addr, shutdown, telemetryState := newTestTelemetryServer(t)\n          defer shutdown()\n\n          client := newTelemetryClient(t, addr)\n\n          ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n          defer cancel()\n\n          // 1) Build a request with one or more InterfaceMetrics.\n          req := \u0026telemetrypb.ExportMetricsRequest{\n              InterfaceMetrics: []*telemetrypb.InterfaceMetrics{\n                  {\n                      NodeId:      \"node-1\",\n                      InterfaceId: \"if-1\",\n                      Up:          true,\n                      BytesTx:     1234,\n                      // Optional fields: SNRdB, Modulation...\n                  },\n                  {\n                      NodeId:      \"node-1\",\n                      InterfaceId: \"if-2\",\n                      Up:          false,\n                      BytesTx:     0,\n                  },\n              },\n          }\n\n          // 2) Call ExportMetrics on the real gRPC client.\n          if _, err := client.ExportMetrics(ctx, req); err != nil {\n              t.Fatalf(\"ExportMetrics: %v\", err)\n          }\n\n          // 3) Assert TelemetryState has the expected metrics.\n          m1 := telemetryState.GetMetrics(\"node-1\", \"if-1\")\n          if m1 == nil {\n              t.Fatalf(\"expected metrics for node-1/if-1\")\n          }\n          if !m1.Up {\n              t.Errorf(\"expected Up=true for node-1/if-1, got false\")\n          }\n          if m1.BytesTx != 1234 {\n              t.Errorf(\"expected BytesTx=1234, got %d\", m1.BytesTx)\n          }\n\n          m2 := telemetryState.GetMetrics(\"node-1\", \"if-2\")\n          if m2 == nil {\n              t.Fatalf(\"expected metrics for node-1/if-2\")\n          }\n          if m2.Up {\n              t.Errorf(\"expected Up=false for node-1/if-2, got true\")\n          }\n      }\n\n- Keep the numbers simple and deterministic.\n\n### 5. Test multiple ExportMetrics calls (update semantics)\n\n- Add another test case in the same file to ensure `UpdateMetrics` behaves correctly when metrics are sent multiple times:\n\n      func TestTelemetryExportMetrics_UpdatesExistingEntries(t *testing.T) {\n          addr, shutdown, telemetryState := newTestTelemetryServer(t)\n          defer shutdown()\n\n          client := newTelemetryClient(t, addr)\n\n          ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n          defer cancel()\n\n          // First call.\n          _, err := client.ExportMetrics(ctx, \u0026telemetrypb.ExportMetricsRequest{\n              InterfaceMetrics: []*telemetrypb.InterfaceMetrics{\n                  {\n                      NodeId:      \"node-1\",\n                      InterfaceId: \"if-1\",\n                      Up:          true,\n                      BytesTx:     1000,\n                  },\n              },\n          })\n          if err != nil {\n              t.Fatalf(\"first ExportMetrics: %v\", err)\n          }\n\n          // Second call with updated counters.\n          _, err = client.ExportMetrics(ctx, \u0026telemetrypb.ExportMetricsRequest{\n              InterfaceMetrics: []*telemetrypb.InterfaceMetrics{\n                  {\n                      NodeId:      \"node-1\",\n                      InterfaceId: \"if-1\",\n                      Up:          true,\n                      BytesTx:     2500,\n                  },\n              },\n          })\n          if err != nil {\n              t.Fatalf(\"second ExportMetrics: %v\", err)\n          }\n\n          m := telemetryState.GetMetrics(\"node-1\", \"if-1\")\n          if m == nil {\n              t.Fatalf(\"expected metrics for node-1/if-1\")\n          }\n          if m.BytesTx != 2500 {\n              t.Errorf(\"expected BytesTx=2500 after update, got %d\", m.BytesTx)\n          }\n      }\n\n- This confirms that:\n  - The server’s `ExportMetrics` iterates over all entries.\n  - `TelemetryState.UpdateMetrics` overwrites existing entries as intended.\n\n### 6. Edge-case test: empty ExportMetricsRequest\n\n- Add a small test to ensure an empty request is handled gracefully:\n\n      func TestTelemetryExportMetrics_EmptyRequest(t *testing.T) {\n          addr, shutdown, telemetryState := newTestTelemetryServer(t)\n          defer shutdown()\n\n          client := newTelemetryClient(t, addr)\n\n          ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n          defer cancel()\n\n          _, err := client.ExportMetrics(ctx, \u0026telemetrypb.ExportMetricsRequest{})\n          if err != nil {\n              t.Fatalf(\"ExportMetrics(empty): %v\", err)\n          }\n\n          // No metrics should be stored.\n          if got := telemetryState.GetMetrics(\"node-1\", \"if-1\"); got != nil {\n              t.Fatalf(\"expected no metrics, found %+v\", got)\n          }\n      }\n\n- This documents and tests the behaviour for empty telemetry pushes:\n  - Server returns OK.\n  - No state changes.\n\n### 7. Keep tests fast and deterministic\n\n- Use short timeouts (e.g. 5 seconds) on all contexts.\n- Avoid sleeps; this test doesn’t depend on simulation time.\n- Ensure all goroutines (server, etc.) are shut down via `shutdown()` and `t.Cleanup` to avoid leaks or flakiness.\n\n## Acceptance criteria\n\n- In-process Telemetry integration test exists:\n  - New file added (e.g. `internal/sbi/telemetry_integration_test.go`).\n  - Uses a real `grpc.Server` and real `TelemetryServiceClient`.\n\n- Test server:\n  - `TelemetryServer` is registered on an in-process gRPC server.\n  - `TelemetryState` is constructed via `NewTelemetryState()` and injected into the server.\n  - Helper function returns:\n    - Server address.\n    - `shutdown()` function.\n    - Pointer to `TelemetryState` for assertions.\n\n- Happy-path test:\n  - Sends a non-empty `ExportMetricsRequest` with one or more `InterfaceMetrics`.\n  - Verifies `TelemetryState.GetMetrics(nodeID, ifaceID)` returns non-nil entries.\n  - Asserts that fields like `Up` and `BytesTx` match the request.\n\n- Update semantics test:\n  - Sends multiple `ExportMetricsRequest` calls for the same `(nodeID, ifaceID)`.\n  - Verifies that the last call’s values are reflected in `TelemetryState`.\n\n- Edge-case test:\n  - Empty `ExportMetricsRequest` is accepted (no panic, no error).\n  - No metrics are stored in `TelemetryState`.\n\n- Test hygiene:\n  - All gRPC resources (server, listeners, connections) are cleaned up at test end.\n  - No reliance on fixed ports.\n  - Tests are deterministic and do not require external services.\n\n- Repository health:\n  - `go build ./...` passes with the new integration test.\n  - `go test ./...` passes, including the new Telemetry integration tests.\n",
        "closed_by":  null,
        "reactions":  {
                          "url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/177/reactions",
                          "total_count":  0,
                          "+1":  0,
                          "-1":  0,
                          "laugh":  0,
                          "hooray":  0,
                          "confused":  0,
                          "heart":  0,
                          "rocket":  0,
                          "eyes":  0
                      },
        "timeline_url":  "https://api.github.com/repos/Cizor/spacetime-constellation-sim/issues/177/timeline",
        "performed_via_github_app":  null,
        "state_reason":  null
    }
]
